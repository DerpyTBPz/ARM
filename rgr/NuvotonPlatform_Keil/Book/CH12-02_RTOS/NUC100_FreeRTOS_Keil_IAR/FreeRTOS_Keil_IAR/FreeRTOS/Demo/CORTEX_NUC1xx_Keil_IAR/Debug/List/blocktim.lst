###############################################################################
#                                                                             #
#                                                       06/Jul/2010  14:34:53 #
# IAR ANSI C/C++ Compiler V5.50.0.21878/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\blockt #
#                    im.c                                                     #
#    Command line =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\blockt #
#                    im.c -D IAR_ARM_CM0 -lCN E:\FreeRTOS_Keil_IAR\FreeRTOS\D #
#                    emo\CORTEX_NUC1xx_Keil_IAR\Debug\List\ --diag_suppress   #
#                    Pe550,Pa082,Pa039 -o E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\ #
#                    CORTEX_NUC1xx_Keil_IAR\Debug\Obj\ --no_cse --no_unroll   #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M0  #
#                    -e --fpu=None --dlib_config "D:\Program                  #
#                    Files\ARM\INC\DLib_Config_Full.h" -I                     #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\..\common\include\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\De #
#                    mo\CORTEX_NUC1xx_Keil_IAR\..\..\source\include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_K #
#                    eil_IAR\NUC1xxBSP\NuvotonPlatform_Keil\Include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\NuvotonPlatform_Keil\Include\Driver\ -I      #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\CMSIS\CM0\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\ #
#                    Demo\CORTEX_NUC1xx_Keil_IAR\User_Demo\include\ -I        #
#                    "D:\Program Files\ARM\INC\" -Ol                          #
#    List file    =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\List\blocktim.lst                                #
#    Object file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\Obj\blocktim.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\blocktim.c
      1          /*
      2              FreeRTOS V6.0.5 - Copyright (C) 2010 Real Time Engineers Ltd.
      3          
      4              ***************************************************************************
      5              *                                                                         *
      6              * If you are:                                                             *
      7              *                                                                         *
      8              *    + New to FreeRTOS,                                                   *
      9              *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
     10              *    + Looking for basic training,                                        *
     11              *    + Wanting to improve your FreeRTOS skills and productivity           *
     12              *                                                                         *
     13              * then take a look at the FreeRTOS eBook                                  *
     14              *                                                                         *
     15              *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
     16              *                  http://www.FreeRTOS.org/Documentation                  *
     17              *                                                                         *
     18              * A pdf reference manual is also available.  Both are usually delivered   *
     19              * to your inbox within 20 minutes to two hours when purchased between 8am *
     20              * and 8pm GMT (although please allow up to 24 hours in case of            *
     21              * exceptional circumstances).  Thank you for your support!                *
     22              *                                                                         *
     23              ***************************************************************************
     24          
     25              This file is part of the FreeRTOS distribution.
     26          
     27              FreeRTOS is free software; you can redistribute it and/or modify it under
     28              the terms of the GNU General Public License (version 2) as published by the
     29              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     30              ***NOTE*** The exception to the GPL is included to allow you to distribute
     31              a combined work that includes FreeRTOS without being obliged to provide the
     32              source code for proprietary components outside of the FreeRTOS kernel.
     33              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
     34              ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     35              FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     36              more details. You should have received a copy of the GNU General Public 
     37              License and the FreeRTOS license exception along with FreeRTOS; if not it 
     38              can be viewed here: http://www.freertos.org/a00114.html and also obtained 
     39              by writing to Richard Barry, contact details for whom are available on the
     40              FreeRTOS WEB site.
     41          
     42              1 tab == 4 spaces!
     43          
     44              http://www.FreeRTOS.org - Documentation, latest information, license and
     45              contact details.
     46          
     47              http://www.SafeRTOS.com - A version that is certified for use in safety
     48              critical systems.
     49          
     50              http://www.OpenRTOS.com - Commercial support, development, porting,
     51              licensing and training services.
     52          */
     53          
     54          /*
     55           * This file contains some test scenarios that ensure tasks do not exit queue
     56           * send or receive functions prematurely.  A description of the tests is
     57           * included within the code.
     58           */
     59          
     60          /* Kernel includes. */
     61          #include "FreeRTOS.h"
     62          #include "task.h"
     63          #include "queue.h"
     64          
     65          /* Demo includes. */
     66          #include "blocktim.h"
     67          
     68          /* Task priorities.  Allow these to be overridden. */
     69          #ifndef bktPRIMARY_PRIORITY
     70          	#define bktPRIMARY_PRIORITY			( 3 )
     71          #endif
     72          
     73          #ifndef bktSECONDARY_PRIORITY
     74          	#define bktSECONDARY_PRIORITY		( 2 )
     75          #endif
     76          
     77          /* Task behaviour. */
     78          #define bktQUEUE_LENGTH				( 5 )
     79          #define bktSHORT_WAIT				( ( ( portTickType ) 20 ) / portTICK_RATE_MS )
     80          #define bktPRIMARY_BLOCK_TIME		( 10 )
     81          #define bktALLOWABLE_MARGIN			( 15 )
     82          #define bktTIME_TO_BLOCK			( 175 )
     83          #define bktDONT_BLOCK				( ( portTickType ) 0 )
     84          #define bktRUN_INDICATOR			( ( unsigned portBASE_TYPE ) 0x55 )
     85          
     86          /* The queue on which the tasks block. */

   \                                 In section .bss, align 4
     87          static xQueueHandle xTestQueue;
   \                     xTestQueue:
   \   00000000                      DS8 4
     88          
     89          /* Handle to the secondary task is required by the primary task for calls
     90          to vTaskSuspend/Resume(). */

   \                                 In section .bss, align 4
     91          static xTaskHandle xSecondary;
   \                     xSecondary:
   \   00000000                      DS8 4
     92          
     93          /* Used to ensure that tasks are still executing without error. */

   \                                 In section .bss, align 4
     94          static volatile portBASE_TYPE xPrimaryCycles = 0, xSecondaryCycles = 0;
   \                     xPrimaryCycles:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     xSecondaryCycles:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     95          static volatile portBASE_TYPE xErrorOccurred = pdFALSE;
   \                     xErrorOccurred:
   \   00000000                      DS8 4
     96          
     97          /* Provides a simple mechanism for the primary task to know when the
     98          secondary task has executed. */

   \                                 In section .bss, align 4
     99          static volatile unsigned portBASE_TYPE xRunIndicator;
   \                     xRunIndicator:
   \   00000000                      DS8 4
    100          
    101          /* The two test tasks.  Their behaviour is commented within the files. */
    102          static void vPrimaryBlockTimeTestTask( void *pvParameters );
    103          static void vSecondaryBlockTimeTestTask( void *pvParameters );
    104          
    105          /*-----------------------------------------------------------*/
    106          

   \                                 In section .text, align 2, keep-with-next
    107          void vCreateBlockTimeTasks( void )
    108          {
   \                     vCreateBlockTimeTasks:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    109          	/* Create the queue on which the two tasks block. */
    110              xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
   \   00000004   0421               MOVS     R1,#+4
   \   00000006   0520               MOVS     R0,#+5
   \   00000008   ........           BL       xQueueCreate
   \   0000000C   ....               LDR      R1,??DataTable1
   \   0000000E   0860               STR      R0,[R1, #+0]
    111          
    112          	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
    113          	in use.  The queue registry is provided as a means for kernel aware
    114          	debuggers to locate queues and has no purpose if a kernel aware debugger
    115          	is not being used.  The call to vQueueAddToRegistry() will be removed
    116          	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
    117          	defined to be less than 1. */
    118          	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );
    119          
    120          	/* Create the two test tasks. */
    121          	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed char * )"BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   0390               STR      R0,[SP, #+12]
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   0290               STR      R0,[SP, #+8]
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   0190               STR      R0,[SP, #+4]
   \   0000001C   0320               MOVS     R0,#+3
   \   0000001E   0090               STR      R0,[SP, #+0]
   \   00000020   0023               MOVS     R3,#+0
   \   00000022   8022               MOVS     R2,#+128
   \   00000024   ....               LDR      R1,??DataTable1_1
   \   00000026   ....               LDR      R0,??DataTable1_2
   \   00000028   ........           BL       xTaskGenericCreate
    122          	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed char * )"BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   0390               STR      R0,[SP, #+12]
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   0290               STR      R0,[SP, #+8]
   \   00000034   ....               LDR      R0,??DataTable1_3
   \   00000036   0190               STR      R0,[SP, #+4]
   \   00000038   0220               MOVS     R0,#+2
   \   0000003A   0090               STR      R0,[SP, #+0]
   \   0000003C   0023               MOVS     R3,#+0
   \   0000003E   8022               MOVS     R2,#+128
   \   00000040   ....               LDR      R1,??DataTable1_4
   \   00000042   ....               LDR      R0,??DataTable1_5
   \   00000044   ........           BL       xTaskGenericCreate
    123          }
   \   00000048   05B0               ADD      SP,SP,#+20
   \   0000004A   00BD               POP      {PC}             ;; return
    124          /*-----------------------------------------------------------*/
    125          

   \                                 In section .text, align 2, keep-with-next
    126          static void vPrimaryBlockTimeTestTask( void *pvParameters )
    127          {
   \                     vPrimaryBlockTimeTestTask:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    128          portBASE_TYPE xItem, xData;
    129          portTickType xTimeWhenBlocking;
    130          portTickType xTimeToBlock, xBlockedTime;
    131          
    132          	( void ) pvParameters;
   \   00000004   07E0               B        ??vPrimaryBlockTimeTestTask_0
    133          
    134          	for( ;; )
    135          	{
    136          		/*********************************************************************
    137                  Test 1
    138          
    139                  Simple block time wakeup test on queue receives. */
    140          		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    141          		{
    142          			/* The queue is empty. Attempt to read from the queue using a block
    143          			time.  When we wake, ensure the delta in time is as expected. */
    144          			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
    145          
    146          			xTimeWhenBlocking = xTaskGetTickCount();
    147          
    148          			/* We should unblock after xTimeToBlock having not received
    149          			anything on the queue. */
    150          			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
    151          			{
    152          				xErrorOccurred = pdTRUE;
    153          			}
    154          
    155          			/* How long were we blocked for? */
    156          			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
    157          
    158          			if( xBlockedTime < xTimeToBlock )
    159          			{
    160          				/* Should not have blocked for less than we requested. */
    161          				xErrorOccurred = pdTRUE;
    162          			}
    163          
    164          			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
    165          			{
    166          				/* Should not have blocked for longer than we requested,
    167          				although we would not necessarily run as soon as we were
    168          				unblocked so a margin is allowed. */
    169          				xErrorOccurred = pdTRUE;
    170          			}
    171          		}
    172          
    173          		/*********************************************************************
    174                  Test 2
    175          
    176                  Simple block time wakeup test on queue sends.
    177          
    178          		First fill the queue.  It should be empty so all sends should pass. */
    179          		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    180          		{
    181          			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
    182          			{
    183          				xErrorOccurred = pdTRUE;
    184          			}
    185          
    186          			#if configUSE_PREEMPTION == 0
    187          				taskYIELD();
    188          			#endif
    189          		}
    190          
    191          		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    192          		{
    193          			/* The queue is full. Attempt to write to the queue using a block
    194          			time.  When we wake, ensure the delta in time is as expected. */
    195          			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
    196          
    197          			xTimeWhenBlocking = xTaskGetTickCount();
    198          
    199          			/* We should unblock after xTimeToBlock having not received
    200          			anything on the queue. */
    201          			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
    202          			{
    203          				xErrorOccurred = pdTRUE;
    204          			}
    205          
    206          			/* How long were we blocked for? */
    207          			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
    208          
    209          			if( xBlockedTime < xTimeToBlock )
    210          			{
    211          				/* Should not have blocked for less than we requested. */
    212          				xErrorOccurred = pdTRUE;
    213          			}
    214          
    215          			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
    216          			{
    217          				/* Should not have blocked for longer than we requested,
    218          				although we would not necessarily run as soon as we were
    219          				unblocked so a margin is allowed. */
    220          				xErrorOccurred = pdTRUE;
    221          			}
    222          		}
    223          
    224          		/*********************************************************************
    225                  Test 3
    226          
    227          		Wake the other task, it will block attempting to post to the queue.
    228          		When we read from the queue the other task will wake, but before it
    229          		can run we will post to the queue again.  When the other task runs it
    230          		will find the queue still full, even though it was woken.  It should
    231          		recognise that its block time has not expired and return to block for
    232          		the remains of its block time.
    233          
    234          		Wake the other task so it blocks attempting to post to the already
    235          		full queue. */
    236          		xRunIndicator = 0;
    237          		vTaskResume( xSecondary );
    238          
    239          		/* We need to wait a little to ensure the other task executes. */
    240          		while( xRunIndicator != bktRUN_INDICATOR )
    241          		{
    242          			/* The other task has not yet executed. */
    243          			vTaskDelay( bktSHORT_WAIT );
    244          		}
    245          		/* Make sure the other task is blocked on the queue. */
    246          		vTaskDelay( bktSHORT_WAIT );
    247          		xRunIndicator = 0;
    248          
    249          		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    250          		{
    251          			/* Now when we make space on the queue the other task should wake
    252          			but not execute as this task has higher priority. */
    253          			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
    254          			{
    255          				xErrorOccurred = pdTRUE;
    256          			}
    257          
    258          			/* Now fill the queue again before the other task gets a chance to
    259          			execute.  If the other task had executed we would find the queue
    260          			full ourselves, and the other task have set xRunIndicator. */
    261          			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
    262          			{
    263          				xErrorOccurred = pdTRUE;
    264          			}
    265          
    266          			if( xRunIndicator == bktRUN_INDICATOR )
    267          			{
    268          				/* The other task should not have executed. */
    269          				xErrorOccurred = pdTRUE;
    270          			}
    271          
    272          			/* Raise the priority of the other task so it executes and blocks
    273          			on the queue again. */
    274          			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
    275          
    276          			/* The other task should now have re-blocked without exiting the
    277          			queue function. */
    278          			if( xRunIndicator == bktRUN_INDICATOR )
    279          			{
    280          				/* The other task should not have executed outside of the
    281          				queue function. */
    282          				xErrorOccurred = pdTRUE;
    283          			}
    284          
    285          			/* Set the priority back down. */
    286          			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
    287          		}
    288          
    289          		/* Let the other task timeout.  When it unblockes it will check that it
    290          		unblocked at the correct time, then suspend itself. */
    291          		while( xRunIndicator != bktRUN_INDICATOR )
    292          		{
    293          			vTaskDelay( bktSHORT_WAIT );
    294          		}
    295          		vTaskDelay( bktSHORT_WAIT );
    296          		xRunIndicator = 0;
    297          
    298          
    299          		/*********************************************************************
    300                  Test 4
    301          
    302          		As per test 3 - but with the send and receive the other way around.
    303          		The other task blocks attempting to read from the queue.
    304          
    305          		Empty the queue.  We should find that it is full. */
    306          		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    307          		{
    308          			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
    309          			{
    310          				xErrorOccurred = pdTRUE;
    311          			}
    312          		}
    313          
    314          		/* Wake the other task so it blocks attempting to read from  the
    315          		already	empty queue. */
    316          		vTaskResume( xSecondary );
    317          
    318          		/* We need to wait a little to ensure the other task executes. */
    319          		while( xRunIndicator != bktRUN_INDICATOR )
    320          		{
    321          			vTaskDelay( bktSHORT_WAIT );
    322          		}
    323          		vTaskDelay( bktSHORT_WAIT );
    324          		xRunIndicator = 0;
    325          
    326          		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    327          		{
    328          			/* Now when we place an item on the queue the other task should
    329          			wake but not execute as this task has higher priority. */
    330          			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
    331          			{
    332          				xErrorOccurred = pdTRUE;
    333          			}
    334          
    335          			/* Now empty the queue again before the other task gets a chance to
    336          			execute.  If the other task had executed we would find the queue
    337          			empty ourselves, and the other task would be suspended. */
    338          			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
    339          			{
    340          				xErrorOccurred = pdTRUE;
    341          			}
    342          
    343          			if( xRunIndicator == bktRUN_INDICATOR )
    344          			{
    345          				/* The other task should not have executed. */
    346          				xErrorOccurred = pdTRUE;
    347          			}
    348          
    349          			/* Raise the priority of the other task so it executes and blocks
    350          			on the queue again. */
    351          			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
    352          
    353          			/* The other task should now have re-blocked without exiting the
    354          			queue function. */
    355          			if( xRunIndicator == bktRUN_INDICATOR )
    356          			{
    357          				/* The other task should not have executed outside of the
    358          				queue function. */
    359          				xErrorOccurred = pdTRUE;
    360          			}
    361          			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
    362          		}
    363          
    364          		/* Let the other task timeout.  When it unblockes it will check that it
    365          		unblocked at the correct time, then suspend itself. */
    366          		while( xRunIndicator != bktRUN_INDICATOR )
    367          		{
    368          			vTaskDelay( bktSHORT_WAIT );
    369          		}
    370          		vTaskDelay( bktSHORT_WAIT );
   \                     ??vPrimaryBlockTimeTestTask_1:
   \   00000006   1420               MOVS     R0,#+20
   \   00000008   ........           BL       vTaskDelay
    371          
    372          		xPrimaryCycles++;
   \   0000000C   ....               LDR      R0,??DataTable1_6
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   401C               ADDS     R0,R0,#+1
   \   00000012   ....               LDR      R1,??DataTable1_6
   \   00000014   0860               STR      R0,[R1, #+0]
   \                     ??vPrimaryBlockTimeTestTask_0:
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   0090               STR      R0,[SP, #+0]
   \   0000001A   22E0               B        ??vPrimaryBlockTimeTestTask_2
   \                     ??vPrimaryBlockTimeTestTask_3:
   \   0000001C   0A24               MOVS     R4,#+10
   \   0000001E   0098               LDR      R0,[SP, #+0]
   \   00000020   8440               LSLS     R4,R4,R0
   \   00000022   ........           BL       xTaskGetTickCount
   \   00000026   0500               MOVS     R5,R0
   \   00000028   0023               MOVS     R3,#+0
   \   0000002A   2200               MOVS     R2,R4
   \   0000002C   01A9               ADD      R1,SP,#+4
   \   0000002E   ....               LDR      R0,??DataTable1
   \   00000030   0068               LDR      R0,[R0, #+0]
   \   00000032   ........           BL       xQueueGenericReceive
   \   00000036   0028               CMP      R0,#+0
   \   00000038   02D0               BEQ      ??vPrimaryBlockTimeTestTask_4
   \   0000003A   ....               LDR      R0,??DataTable2
   \   0000003C   0121               MOVS     R1,#+1
   \   0000003E   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_4:
   \   00000040   ........           BL       xTaskGetTickCount
   \   00000044   401B               SUBS     R0,R0,R5
   \   00000046   A042               CMP      R0,R4
   \   00000048   02D2               BCS      ??vPrimaryBlockTimeTestTask_5
   \   0000004A   ....               LDR      R1,??DataTable2
   \   0000004C   0122               MOVS     R2,#+1
   \   0000004E   0A60               STR      R2,[R1, #+0]
   \                     ??vPrimaryBlockTimeTestTask_5:
   \   00000050   0F34               ADDS     R4,R4,#+15
   \   00000052   8442               CMP      R4,R0
   \   00000054   02D2               BCS      ??vPrimaryBlockTimeTestTask_6
   \   00000056   ....               LDR      R0,??DataTable2
   \   00000058   0121               MOVS     R1,#+1
   \   0000005A   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_6:
   \   0000005C   0098               LDR      R0,[SP, #+0]
   \   0000005E   401C               ADDS     R0,R0,#+1
   \   00000060   0090               STR      R0,[SP, #+0]
   \                     ??vPrimaryBlockTimeTestTask_2:
   \   00000062   0098               LDR      R0,[SP, #+0]
   \   00000064   0528               CMP      R0,#+5
   \   00000066   D9DB               BLT      ??vPrimaryBlockTimeTestTask_3
   \   00000068   0020               MOVS     R0,#+0
   \   0000006A   0090               STR      R0,[SP, #+0]
   \   0000006C   0EE0               B        ??vPrimaryBlockTimeTestTask_7
   \                     ??vPrimaryBlockTimeTestTask_8:
   \   0000006E   0023               MOVS     R3,#+0
   \   00000070   0022               MOVS     R2,#+0
   \   00000072   6946               MOV      R1,SP
   \   00000074   ....               LDR      R0,??DataTable1
   \   00000076   0068               LDR      R0,[R0, #+0]
   \   00000078   ........           BL       xQueueGenericSend
   \   0000007C   0128               CMP      R0,#+1
   \   0000007E   02D0               BEQ      ??vPrimaryBlockTimeTestTask_9
   \   00000080   ....               LDR      R0,??DataTable2
   \   00000082   0121               MOVS     R1,#+1
   \   00000084   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_9:
   \   00000086   0098               LDR      R0,[SP, #+0]
   \   00000088   401C               ADDS     R0,R0,#+1
   \   0000008A   0090               STR      R0,[SP, #+0]
   \                     ??vPrimaryBlockTimeTestTask_7:
   \   0000008C   0098               LDR      R0,[SP, #+0]
   \   0000008E   0528               CMP      R0,#+5
   \   00000090   EDDB               BLT      ??vPrimaryBlockTimeTestTask_8
   \   00000092   0020               MOVS     R0,#+0
   \   00000094   0090               STR      R0,[SP, #+0]
   \   00000096   22E0               B        ??vPrimaryBlockTimeTestTask_10
   \                     ??vPrimaryBlockTimeTestTask_11:
   \   00000098   0A24               MOVS     R4,#+10
   \   0000009A   0098               LDR      R0,[SP, #+0]
   \   0000009C   8440               LSLS     R4,R4,R0
   \   0000009E   ........           BL       xTaskGetTickCount
   \   000000A2   0500               MOVS     R5,R0
   \   000000A4   0023               MOVS     R3,#+0
   \   000000A6   2200               MOVS     R2,R4
   \   000000A8   6946               MOV      R1,SP
   \   000000AA   ....               LDR      R0,??DataTable1
   \   000000AC   0068               LDR      R0,[R0, #+0]
   \   000000AE   ........           BL       xQueueGenericSend
   \   000000B2   0028               CMP      R0,#+0
   \   000000B4   02D0               BEQ      ??vPrimaryBlockTimeTestTask_12
   \   000000B6   ....               LDR      R0,??DataTable2
   \   000000B8   0121               MOVS     R1,#+1
   \   000000BA   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_12:
   \   000000BC   ........           BL       xTaskGetTickCount
   \   000000C0   401B               SUBS     R0,R0,R5
   \   000000C2   A042               CMP      R0,R4
   \   000000C4   02D2               BCS      ??vPrimaryBlockTimeTestTask_13
   \   000000C6   ....               LDR      R1,??DataTable2
   \   000000C8   0122               MOVS     R2,#+1
   \   000000CA   0A60               STR      R2,[R1, #+0]
   \                     ??vPrimaryBlockTimeTestTask_13:
   \   000000CC   0F34               ADDS     R4,R4,#+15
   \   000000CE   8442               CMP      R4,R0
   \   000000D0   02D2               BCS      ??vPrimaryBlockTimeTestTask_14
   \   000000D2   ....               LDR      R0,??DataTable2
   \   000000D4   0121               MOVS     R1,#+1
   \   000000D6   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_14:
   \   000000D8   0098               LDR      R0,[SP, #+0]
   \   000000DA   401C               ADDS     R0,R0,#+1
   \   000000DC   0090               STR      R0,[SP, #+0]
   \                     ??vPrimaryBlockTimeTestTask_10:
   \   000000DE   0098               LDR      R0,[SP, #+0]
   \   000000E0   0528               CMP      R0,#+5
   \   000000E2   D9DB               BLT      ??vPrimaryBlockTimeTestTask_11
   \   000000E4   ....               LDR      R0,??DataTable3
   \   000000E6   0021               MOVS     R1,#+0
   \   000000E8   0160               STR      R1,[R0, #+0]
   \   000000EA   ....               LDR      R0,??DataTable1_3
   \   000000EC   0068               LDR      R0,[R0, #+0]
   \   000000EE   ........           BL       vTaskResume
   \   000000F2   02E0               B        ??vPrimaryBlockTimeTestTask_15
   \                     ??vPrimaryBlockTimeTestTask_16:
   \   000000F4   1420               MOVS     R0,#+20
   \   000000F6   ........           BL       vTaskDelay
   \                     ??vPrimaryBlockTimeTestTask_15:
   \   000000FA   ....               LDR      R0,??DataTable3
   \   000000FC   0068               LDR      R0,[R0, #+0]
   \   000000FE   5528               CMP      R0,#+85
   \   00000100   F8D1               BNE      ??vPrimaryBlockTimeTestTask_16
   \   00000102   1420               MOVS     R0,#+20
   \   00000104   ........           BL       vTaskDelay
   \   00000108   ....               LDR      R0,??DataTable3
   \   0000010A   0021               MOVS     R1,#+0
   \   0000010C   0160               STR      R1,[R0, #+0]
   \   0000010E   0020               MOVS     R0,#+0
   \   00000110   0090               STR      R0,[SP, #+0]
   \   00000112   32E0               B        ??vPrimaryBlockTimeTestTask_17
   \                     ??vPrimaryBlockTimeTestTask_18:
   \   00000114   0023               MOVS     R3,#+0
   \   00000116   0022               MOVS     R2,#+0
   \   00000118   01A9               ADD      R1,SP,#+4
   \   0000011A   ....               LDR      R0,??DataTable1
   \   0000011C   0068               LDR      R0,[R0, #+0]
   \   0000011E   ........           BL       xQueueGenericReceive
   \   00000122   0128               CMP      R0,#+1
   \   00000124   02D0               BEQ      ??vPrimaryBlockTimeTestTask_19
   \   00000126   ....               LDR      R0,??DataTable2
   \   00000128   0121               MOVS     R1,#+1
   \   0000012A   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_19:
   \   0000012C   0023               MOVS     R3,#+0
   \   0000012E   0022               MOVS     R2,#+0
   \   00000130   6946               MOV      R1,SP
   \   00000132   ....               LDR      R0,??DataTable1
   \   00000134   0068               LDR      R0,[R0, #+0]
   \   00000136   ........           BL       xQueueGenericSend
   \   0000013A   0128               CMP      R0,#+1
   \   0000013C   02D0               BEQ      ??vPrimaryBlockTimeTestTask_20
   \   0000013E   ....               LDR      R0,??DataTable2
   \   00000140   0121               MOVS     R1,#+1
   \   00000142   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_20:
   \   00000144   ....               LDR      R0,??DataTable3
   \   00000146   0068               LDR      R0,[R0, #+0]
   \   00000148   5528               CMP      R0,#+85
   \   0000014A   02D1               BNE      ??vPrimaryBlockTimeTestTask_21
   \   0000014C   ....               LDR      R0,??DataTable2
   \   0000014E   0121               MOVS     R1,#+1
   \   00000150   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_21:
   \   00000152   0521               MOVS     R1,#+5
   \   00000154   ....               LDR      R0,??DataTable1_3
   \   00000156   0068               LDR      R0,[R0, #+0]
   \   00000158   ........           BL       vTaskPrioritySet
   \   0000015C   ....               LDR      R0,??DataTable3
   \   0000015E   0068               LDR      R0,[R0, #+0]
   \   00000160   5528               CMP      R0,#+85
   \   00000162   02D1               BNE      ??vPrimaryBlockTimeTestTask_22
   \   00000164   ....               LDR      R0,??DataTable2
   \   00000166   0121               MOVS     R1,#+1
   \   00000168   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_22:
   \   0000016A   0221               MOVS     R1,#+2
   \   0000016C   ....               LDR      R0,??DataTable1_3
   \   0000016E   0068               LDR      R0,[R0, #+0]
   \   00000170   ........           BL       vTaskPrioritySet
   \   00000174   0098               LDR      R0,[SP, #+0]
   \   00000176   401C               ADDS     R0,R0,#+1
   \   00000178   0090               STR      R0,[SP, #+0]
   \                     ??vPrimaryBlockTimeTestTask_17:
   \   0000017A   0098               LDR      R0,[SP, #+0]
   \   0000017C   0528               CMP      R0,#+5
   \   0000017E   C9DB               BLT      ??vPrimaryBlockTimeTestTask_18
   \                     ??vPrimaryBlockTimeTestTask_23:
   \   00000180   ....               LDR      R0,??DataTable3
   \   00000182   0068               LDR      R0,[R0, #+0]
   \   00000184   5528               CMP      R0,#+85
   \   00000186   03D0               BEQ      ??vPrimaryBlockTimeTestTask_24
   \   00000188   1420               MOVS     R0,#+20
   \   0000018A   ........           BL       vTaskDelay
   \   0000018E   F7E7               B        ??vPrimaryBlockTimeTestTask_23
   \                     ??vPrimaryBlockTimeTestTask_24:
   \   00000190   1420               MOVS     R0,#+20
   \   00000192   ........           BL       vTaskDelay
   \   00000196   ....               LDR      R0,??DataTable3
   \   00000198   0021               MOVS     R1,#+0
   \   0000019A   0160               STR      R1,[R0, #+0]
   \   0000019C   0020               MOVS     R0,#+0
   \   0000019E   0090               STR      R0,[SP, #+0]
   \   000001A0   0EE0               B        ??vPrimaryBlockTimeTestTask_25
   \                     ??vPrimaryBlockTimeTestTask_26:
   \   000001A2   0023               MOVS     R3,#+0
   \   000001A4   0022               MOVS     R2,#+0
   \   000001A6   01A9               ADD      R1,SP,#+4
   \   000001A8   ....               LDR      R0,??DataTable1
   \   000001AA   0068               LDR      R0,[R0, #+0]
   \   000001AC   ........           BL       xQueueGenericReceive
   \   000001B0   0128               CMP      R0,#+1
   \   000001B2   02D0               BEQ      ??vPrimaryBlockTimeTestTask_27
   \   000001B4   ....               LDR      R0,??DataTable2
   \   000001B6   0121               MOVS     R1,#+1
   \   000001B8   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_27:
   \   000001BA   0098               LDR      R0,[SP, #+0]
   \   000001BC   401C               ADDS     R0,R0,#+1
   \   000001BE   0090               STR      R0,[SP, #+0]
   \                     ??vPrimaryBlockTimeTestTask_25:
   \   000001C0   0098               LDR      R0,[SP, #+0]
   \   000001C2   0528               CMP      R0,#+5
   \   000001C4   EDDB               BLT      ??vPrimaryBlockTimeTestTask_26
   \   000001C6   ....               LDR      R0,??DataTable1_3
   \   000001C8   0068               LDR      R0,[R0, #+0]
   \   000001CA   ........           BL       vTaskResume
   \   000001CE   02E0               B        ??vPrimaryBlockTimeTestTask_28
   \                     ??vPrimaryBlockTimeTestTask_29:
   \   000001D0   1420               MOVS     R0,#+20
   \   000001D2   ........           BL       vTaskDelay
   \                     ??vPrimaryBlockTimeTestTask_28:
   \   000001D6   ....               LDR      R0,??DataTable3
   \   000001D8   0068               LDR      R0,[R0, #+0]
   \   000001DA   5528               CMP      R0,#+85
   \   000001DC   F8D1               BNE      ??vPrimaryBlockTimeTestTask_29
   \   000001DE   1420               MOVS     R0,#+20
   \   000001E0   ........           BL       vTaskDelay
   \   000001E4   ....               LDR      R0,??DataTable3
   \   000001E6   0021               MOVS     R1,#+0
   \   000001E8   0160               STR      R1,[R0, #+0]
   \   000001EA   0020               MOVS     R0,#+0
   \   000001EC   0090               STR      R0,[SP, #+0]
   \   000001EE   32E0               B        ??vPrimaryBlockTimeTestTask_30
   \                     ??vPrimaryBlockTimeTestTask_31:
   \   000001F0   0023               MOVS     R3,#+0
   \   000001F2   0022               MOVS     R2,#+0
   \   000001F4   6946               MOV      R1,SP
   \   000001F6   ....               LDR      R0,??DataTable1
   \   000001F8   0068               LDR      R0,[R0, #+0]
   \   000001FA   ........           BL       xQueueGenericSend
   \   000001FE   0128               CMP      R0,#+1
   \   00000200   02D0               BEQ      ??vPrimaryBlockTimeTestTask_32
   \   00000202   ....               LDR      R0,??DataTable2
   \   00000204   0121               MOVS     R1,#+1
   \   00000206   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_32:
   \   00000208   0023               MOVS     R3,#+0
   \   0000020A   0022               MOVS     R2,#+0
   \   0000020C   01A9               ADD      R1,SP,#+4
   \   0000020E   ....               LDR      R0,??DataTable1
   \   00000210   0068               LDR      R0,[R0, #+0]
   \   00000212   ........           BL       xQueueGenericReceive
   \   00000216   0128               CMP      R0,#+1
   \   00000218   02D0               BEQ      ??vPrimaryBlockTimeTestTask_33
   \   0000021A   ....               LDR      R0,??DataTable2
   \   0000021C   0121               MOVS     R1,#+1
   \   0000021E   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_33:
   \   00000220   ....               LDR      R0,??DataTable3
   \   00000222   0068               LDR      R0,[R0, #+0]
   \   00000224   5528               CMP      R0,#+85
   \   00000226   02D1               BNE      ??vPrimaryBlockTimeTestTask_34
   \   00000228   ....               LDR      R0,??DataTable2
   \   0000022A   0121               MOVS     R1,#+1
   \   0000022C   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_34:
   \   0000022E   0521               MOVS     R1,#+5
   \   00000230   ....               LDR      R0,??DataTable1_3
   \   00000232   0068               LDR      R0,[R0, #+0]
   \   00000234   ........           BL       vTaskPrioritySet
   \   00000238   ....               LDR      R0,??DataTable3
   \   0000023A   0068               LDR      R0,[R0, #+0]
   \   0000023C   5528               CMP      R0,#+85
   \   0000023E   02D1               BNE      ??vPrimaryBlockTimeTestTask_35
   \   00000240   ....               LDR      R0,??DataTable2
   \   00000242   0121               MOVS     R1,#+1
   \   00000244   0160               STR      R1,[R0, #+0]
   \                     ??vPrimaryBlockTimeTestTask_35:
   \   00000246   0221               MOVS     R1,#+2
   \   00000248   ....               LDR      R0,??DataTable1_3
   \   0000024A   0068               LDR      R0,[R0, #+0]
   \   0000024C   ........           BL       vTaskPrioritySet
   \   00000250   0098               LDR      R0,[SP, #+0]
   \   00000252   401C               ADDS     R0,R0,#+1
   \   00000254   0090               STR      R0,[SP, #+0]
   \                     ??vPrimaryBlockTimeTestTask_30:
   \   00000256   0098               LDR      R0,[SP, #+0]
   \   00000258   0528               CMP      R0,#+5
   \   0000025A   C9DB               BLT      ??vPrimaryBlockTimeTestTask_31
   \                     ??vPrimaryBlockTimeTestTask_36:
   \   0000025C   ....               LDR      R0,??DataTable3
   \   0000025E   0068               LDR      R0,[R0, #+0]
   \   00000260   5528               CMP      R0,#+85
   \   00000262   00D1               BNE      .+4
   \   00000264   CFE6               B        ??vPrimaryBlockTimeTestTask_1
   \   00000266   1420               MOVS     R0,#+20
   \   00000268   ........           BL       vTaskDelay
   \   0000026C   F6E7               B        ??vPrimaryBlockTimeTestTask_36
    373          	}
    374          }
    375          /*-----------------------------------------------------------*/
    376          

   \                                 In section .text, align 2, keep-with-next
    377          static void vSecondaryBlockTimeTestTask( void *pvParameters )
    378          {
   \                     vSecondaryBlockTimeTestTask:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    379          portTickType xTimeWhenBlocking, xBlockedTime;
    380          portBASE_TYPE xData;
    381          
    382          	( void ) pvParameters;
    383          
    384          	for( ;; )
    385          	{
    386          		/*********************************************************************
    387                  Test 1 and 2
    388          
    389          		This task does does not participate in these tests. */
    390          		vTaskSuspend( NULL );
   \                     ??vSecondaryBlockTimeTestTask_0:
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   ........           BL       vTaskSuspend
    391          
    392          		/*********************************************************************
    393                  Test 3
    394          
    395          		The first thing we do is attempt to read from the queue.  It should be
    396          		full so we block.  Note the time before we block so we can check the
    397          		wake time is as per that expected. */
    398          		xTimeWhenBlocking = xTaskGetTickCount();
   \   0000000A   ........           BL       xTaskGetTickCount
   \   0000000E   0400               MOVS     R4,R0
    399          
    400          		/* We should unblock after bktTIME_TO_BLOCK having not sent
    401          		anything to the queue. */
    402          		xData = 0;
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   0090               STR      R0,[SP, #+0]
    403          		xRunIndicator = bktRUN_INDICATOR;
   \   00000014   ....               LDR      R0,??DataTable3
   \   00000016   5521               MOVS     R1,#+85
   \   00000018   0160               STR      R1,[R0, #+0]
    404          		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
   \   0000001A   0023               MOVS     R3,#+0
   \   0000001C   AF22               MOVS     R2,#+175
   \   0000001E   6946               MOV      R1,SP
   \   00000020   ....               LDR      R0,??DataTable3_1
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   ........           BL       xQueueGenericSend
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   02D0               BEQ      ??vSecondaryBlockTimeTestTask_1
    405          		{
    406          			xErrorOccurred = pdTRUE;
   \   0000002C   ....               LDR      R0,??DataTable2
   \   0000002E   0121               MOVS     R1,#+1
   \   00000030   0160               STR      R1,[R0, #+0]
    407          		}
    408          
    409          		/* How long were we inside the send function? */
    410          		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
   \                     ??vSecondaryBlockTimeTestTask_1:
   \   00000032   ........           BL       xTaskGetTickCount
   \   00000036   001B               SUBS     R0,R0,R4
    411          
    412          		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
    413          		if( xBlockedTime < bktTIME_TO_BLOCK )
   \   00000038   AF28               CMP      R0,#+175
   \   0000003A   02D2               BCS      ??vSecondaryBlockTimeTestTask_2
    414          		{
    415          			xErrorOccurred = pdTRUE;
   \   0000003C   ....               LDR      R1,??DataTable2
   \   0000003E   0122               MOVS     R2,#+1
   \   00000040   0A60               STR      R2,[R1, #+0]
    416          		}
    417          
    418          		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
    419          		either.  A margin is permitted as we would not necessarily run as
    420          		soon as we unblocked. */
    421          		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
   \                     ??vSecondaryBlockTimeTestTask_2:
   \   00000042   BF28               CMP      R0,#+191
   \   00000044   02D3               BCC      ??vSecondaryBlockTimeTestTask_3
    422          		{
    423          			xErrorOccurred = pdTRUE;
   \   00000046   ....               LDR      R0,??DataTable2
   \   00000048   0121               MOVS     R1,#+1
   \   0000004A   0160               STR      R1,[R0, #+0]
    424          		}
    425          
    426          		/* Suspend ready for test 3. */
    427          		xRunIndicator = bktRUN_INDICATOR;
   \                     ??vSecondaryBlockTimeTestTask_3:
   \   0000004C   ....               LDR      R0,??DataTable3
   \   0000004E   5521               MOVS     R1,#+85
   \   00000050   0160               STR      R1,[R0, #+0]
    428          		vTaskSuspend( NULL );
   \   00000052   0020               MOVS     R0,#+0
   \   00000054   ........           BL       vTaskSuspend
    429          
    430          		/*********************************************************************
    431                  Test 4
    432          
    433          		As per test three, but with the send and receive reversed. */
    434          		xTimeWhenBlocking = xTaskGetTickCount();
   \   00000058   ........           BL       xTaskGetTickCount
   \   0000005C   0400               MOVS     R4,R0
    435          
    436          		/* We should unblock after bktTIME_TO_BLOCK having not received
    437          		anything on the queue. */
    438          		xRunIndicator = bktRUN_INDICATOR;
   \   0000005E   ....               LDR      R0,??DataTable3
   \   00000060   5521               MOVS     R1,#+85
   \   00000062   0160               STR      R1,[R0, #+0]
    439          		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
   \   00000064   0023               MOVS     R3,#+0
   \   00000066   AF22               MOVS     R2,#+175
   \   00000068   6946               MOV      R1,SP
   \   0000006A   ....               LDR      R0,??DataTable3_1
   \   0000006C   0068               LDR      R0,[R0, #+0]
   \   0000006E   ........           BL       xQueueGenericReceive
   \   00000072   0028               CMP      R0,#+0
   \   00000074   02D0               BEQ      ??vSecondaryBlockTimeTestTask_4
    440          		{
    441          			xErrorOccurred = pdTRUE;
   \   00000076   ....               LDR      R0,??DataTable2
   \   00000078   0121               MOVS     R1,#+1
   \   0000007A   0160               STR      R1,[R0, #+0]
    442          		}
    443          
    444          		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
   \                     ??vSecondaryBlockTimeTestTask_4:
   \   0000007C   ........           BL       xTaskGetTickCount
   \   00000080   001B               SUBS     R0,R0,R4
    445          
    446          		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
    447          		if( xBlockedTime < bktTIME_TO_BLOCK )
   \   00000082   AF28               CMP      R0,#+175
   \   00000084   02D2               BCS      ??vSecondaryBlockTimeTestTask_5
    448          		{
    449          			xErrorOccurred = pdTRUE;
   \   00000086   ....               LDR      R1,??DataTable2
   \   00000088   0122               MOVS     R2,#+1
   \   0000008A   0A60               STR      R2,[R1, #+0]
    450          		}
    451          
    452          		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
    453          		either.  A margin is permitted as we would not necessarily run as soon
    454          		as we unblocked. */
    455          		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
   \                     ??vSecondaryBlockTimeTestTask_5:
   \   0000008C   BF28               CMP      R0,#+191
   \   0000008E   02D3               BCC      ??vSecondaryBlockTimeTestTask_6
    456          		{
    457          			xErrorOccurred = pdTRUE;
   \   00000090   ....               LDR      R0,??DataTable2
   \   00000092   0121               MOVS     R1,#+1
   \   00000094   0160               STR      R1,[R0, #+0]
    458          		}
    459          
    460          		xRunIndicator = bktRUN_INDICATOR;
   \                     ??vSecondaryBlockTimeTestTask_6:
   \   00000096   ....               LDR      R0,??DataTable3
   \   00000098   5521               MOVS     R1,#+85
   \   0000009A   0160               STR      R1,[R0, #+0]
    461          
    462          		xSecondaryCycles++;
   \   0000009C   ....               LDR      R0,??DataTable3_2
   \   0000009E   0068               LDR      R0,[R0, #+0]
   \   000000A0   401C               ADDS     R0,R0,#+1
   \   000000A2   ....               LDR      R1,??DataTable3_2
   \   000000A4   0860               STR      R0,[R1, #+0]
   \   000000A6   ADE7               B        ??vSecondaryBlockTimeTestTask_0
    463          	}
    464          }
    465          /*-----------------------------------------------------------*/
    466          

   \                                 In section .text, align 2, keep-with-next
    467          portBASE_TYPE xAreBlockTimeTestTasksStillRunning( void )
    468          {
   \                     xAreBlockTimeTestTasksStillRunning:
   \   00000000   00B5               PUSH     {LR}
    469          static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
    470          portBASE_TYPE xReturn = pdPASS;
   \   00000002   0120               MOVS     R0,#+1
    471          
    472          	/* Have both tasks performed at least one cycle since this function was
    473          	last called? */
    474          	if( xPrimaryCycles == xLastPrimaryCycleCount )
   \   00000004   ....               LDR      R1,??DataTable3_3
   \   00000006   0968               LDR      R1,[R1, #+0]
   \   00000008   ....               LDR      R2,??DataTable3_4
   \   0000000A   1268               LDR      R2,[R2, #+0]
   \   0000000C   9142               CMP      R1,R2
   \   0000000E   00D1               BNE      ??xAreBlockTimeTestTasksStillRunning_0
    475          	{
    476          		xReturn = pdFAIL;
   \   00000010   0020               MOVS     R0,#+0
    477          	}
    478          
    479          	if( xSecondaryCycles == xLastSecondaryCycleCount )
   \                     ??xAreBlockTimeTestTasksStillRunning_0:
   \   00000012   ....               LDR      R1,??DataTable3_2
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   ....               LDR      R2,??DataTable3_5
   \   00000018   1268               LDR      R2,[R2, #+0]
   \   0000001A   9142               CMP      R1,R2
   \   0000001C   00D1               BNE      ??xAreBlockTimeTestTasksStillRunning_1
    480          	{
    481          		xReturn = pdFAIL;
   \   0000001E   0020               MOVS     R0,#+0
    482          	}
    483          
    484          	if( xErrorOccurred == pdTRUE )
   \                     ??xAreBlockTimeTestTasksStillRunning_1:
   \   00000020   ....               LDR      R1,??DataTable3_6
   \   00000022   0968               LDR      R1,[R1, #+0]
   \   00000024   0129               CMP      R1,#+1
   \   00000026   00D1               BNE      ??xAreBlockTimeTestTasksStillRunning_2
    485          	{
    486          		xReturn = pdFAIL;
   \   00000028   0020               MOVS     R0,#+0
    487          	}
    488          
    489          	xLastSecondaryCycleCount = xSecondaryCycles;
   \                     ??xAreBlockTimeTestTasksStillRunning_2:
   \   0000002A   ....               LDR      R1,??DataTable3_5
   \   0000002C   ....               LDR      R2,??DataTable3_2
   \   0000002E   1268               LDR      R2,[R2, #+0]
   \   00000030   0A60               STR      R2,[R1, #+0]
    490          	xLastPrimaryCycleCount = xPrimaryCycles;
   \   00000032   ....               LDR      R1,??DataTable3_4
   \   00000034   ....               LDR      R2,??DataTable3_3
   \   00000036   1268               LDR      R2,[R2, #+0]
   \   00000038   0A60               STR      R2,[R1, #+0]
    491          
    492          	return xReturn;
   \   0000003A   00BD               POP      {PC}             ;; return
    493          }

   \                                 In section .bss, align 4
   \                     ??xLastPrimaryCycleCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ??xLastSecondaryCycleCount:
   \   00000000                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     xTestQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   ........           DC32     `?<Constant "BTest1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   ........           DC32     vPrimaryBlockTimeTestTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   ........           DC32     xSecondary

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   ........           DC32     `?<Constant "BTest2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   ........           DC32     vSecondaryBlockTimeTestTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   ........           DC32     xPrimaryCycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     xErrorOccurred

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     xRunIndicator

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     xTestQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     xSecondaryCycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     xPrimaryCycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     ??xLastPrimaryCycleCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   ........           DC32     ??xLastSecondaryCycleCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   ........           DC32     xErrorOccurred

   \                                 In section .rodata, align 4
   \                     `?<Constant "BTest1">`:
   \   00000000   425465737431       DC8 "BTest1"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "BTest2">`:
   \   00000000   425465737432       DC8 "BTest2"
   \              00          
   \   00000007   00                 DC8 0

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     vCreateBlockTimeTasks              24
     vPrimaryBlockTimeTestTask          24
     vSecondaryBlockTimeTestTask        16
     xAreBlockTimeTestTasksStillRunning
                                         4


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     xTestQueue                        4
     xSecondary                        4
     xPrimaryCycles                    4
     xSecondaryCycles                  4
     xErrorOccurred                    4
     xRunIndicator                     4
     vCreateBlockTimeTasks            76
     vPrimaryBlockTimeTestTask       622
     vSecondaryBlockTimeTestTask     168
     xAreBlockTimeTestTasksStillRunning
                                      60
     xLastPrimaryCycleCount            4
     xLastSecondaryCycleCount          4
     ??DataTable1                      4
     ??DataTable1_1                    4
     ??DataTable1_2                    4
     ??DataTable1_3                    4
     ??DataTable1_4                    4
     ??DataTable1_5                    4
     ??DataTable1_6                    4
     ??DataTable2                      4
     ??DataTable3                      4
     ??DataTable3_1                    4
     ??DataTable3_2                    4
     ??DataTable3_3                    4
     ??DataTable3_4                    4
     ??DataTable3_5                    4
     ??DataTable3_6                    4
     ?<Constant "BTest1">              8
     ?<Constant "BTest2">              8

 
  32 bytes in section .bss
  16 bytes in section .rodata
 986 bytes in section .text
 
 986 bytes of CODE  memory
  16 bytes of CONST memory
  32 bytes of DATA  memory

Errors: none
Warnings: none
