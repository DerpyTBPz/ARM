###############################################################################
#                                                                             #
#                                                       06/Jul/2010  14:34:54 #
# IAR ANSI C/C++ Compiler V5.50.0.21878/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\dynami #
#                    c.c                                                      #
#    Command line =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\dynami #
#                    c.c -D IAR_ARM_CM0 -lCN E:\FreeRTOS_Keil_IAR\FreeRTOS\De #
#                    mo\CORTEX_NUC1xx_Keil_IAR\Debug\List\ --diag_suppress    #
#                    Pe550,Pa082,Pa039 -o E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\ #
#                    CORTEX_NUC1xx_Keil_IAR\Debug\Obj\ --no_cse --no_unroll   #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M0  #
#                    -e --fpu=None --dlib_config "D:\Program                  #
#                    Files\ARM\INC\DLib_Config_Full.h" -I                     #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\..\common\include\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\De #
#                    mo\CORTEX_NUC1xx_Keil_IAR\..\..\source\include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_K #
#                    eil_IAR\NUC1xxBSP\NuvotonPlatform_Keil\Include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\NuvotonPlatform_Keil\Include\Driver\ -I      #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\CMSIS\CM0\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\ #
#                    Demo\CORTEX_NUC1xx_Keil_IAR\User_Demo\include\ -I        #
#                    "D:\Program Files\ARM\INC\" -Ol                          #
#    List file    =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\List\dynamic.lst                                 #
#    Object file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\Obj\dynamic.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\dynamic.c
      1          /*
      2              FreeRTOS V6.0.5 - Copyright (C) 2010 Real Time Engineers Ltd.
      3          
      4              ***************************************************************************
      5              *                                                                         *
      6              * If you are:                                                             *
      7              *                                                                         *
      8              *    + New to FreeRTOS,                                                   *
      9              *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
     10              *    + Looking for basic training,                                        *
     11              *    + Wanting to improve your FreeRTOS skills and productivity           *
     12              *                                                                         *
     13              * then take a look at the FreeRTOS eBook                                  *
     14              *                                                                         *
     15              *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
     16              *                  http://www.FreeRTOS.org/Documentation                  *
     17              *                                                                         *
     18              * A pdf reference manual is also available.  Both are usually delivered   *
     19              * to your inbox within 20 minutes to two hours when purchased between 8am *
     20              * and 8pm GMT (although please allow up to 24 hours in case of            *
     21              * exceptional circumstances).  Thank you for your support!                *
     22              *                                                                         *
     23              ***************************************************************************
     24          
     25              This file is part of the FreeRTOS distribution.
     26          
     27              FreeRTOS is free software; you can redistribute it and/or modify it under
     28              the terms of the GNU General Public License (version 2) as published by the
     29              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     30              ***NOTE*** The exception to the GPL is included to allow you to distribute
     31              a combined work that includes FreeRTOS without being obliged to provide the
     32              source code for proprietary components outside of the FreeRTOS kernel.
     33              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
     34              ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     35              FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     36              more details. You should have received a copy of the GNU General Public 
     37              License and the FreeRTOS license exception along with FreeRTOS; if not it 
     38              can be viewed here: http://www.freertos.org/a00114.html and also obtained 
     39              by writing to Richard Barry, contact details for whom are available on the
     40              FreeRTOS WEB site.
     41          
     42              1 tab == 4 spaces!
     43          
     44              http://www.FreeRTOS.org - Documentation, latest information, license and
     45              contact details.
     46          
     47              http://www.SafeRTOS.com - A version that is certified for use in safety
     48              critical systems.
     49          
     50              http://www.OpenRTOS.com - Commercial support, development, porting,
     51              licensing and training services.
     52          */
     53          
     54          /*
     55           * The first test creates three tasks - two counter tasks (one continuous count 
     56           * and one limited count) and one controller.  A "count" variable is shared 
     57           * between all three tasks.  The two counter tasks should never be in a "ready" 
     58           * state at the same time.  The controller task runs at the same priority as 
     59           * the continuous count task, and at a lower priority than the limited count 
     60           * task.
     61           *
     62           * One counter task loops indefinitely, incrementing the shared count variable
     63           * on each iteration.  To ensure it has exclusive access to the variable it
     64           * raises it's priority above that of the controller task before each 
     65           * increment, lowering it again to it's original priority before starting the
     66           * next iteration.
     67           *
     68           * The other counter task increments the shared count variable on each
     69           * iteration of it's loop until the count has reached a limit of 0xff - at
     70           * which point it suspends itself.  It will not start a new loop until the 
     71           * controller task has made it "ready" again by calling vTaskResume ().  
     72           * This second counter task operates at a higher priority than controller 
     73           * task so does not need to worry about mutual exclusion of the counter 
     74           * variable.
     75           *
     76           * The controller task is in two sections.  The first section controls and
     77           * monitors the continuous count task.  When this section is operational the 
     78           * limited count task is suspended.  Likewise, the second section controls 
     79           * and monitors the limited count task.  When this section is operational the 
     80           * continuous count task is suspended.
     81           *
     82           * In the first section the controller task first takes a copy of the shared
     83           * count variable.  To ensure mutual exclusion on the count variable it
     84           * suspends the continuous count task, resuming it again when the copy has been
     85           * taken.  The controller task then sleeps for a fixed period - during which
     86           * the continuous count task will execute and increment the shared variable.
     87           * When the controller task wakes it checks that the continuous count task
     88           * has executed by comparing the copy of the shared variable with its current
     89           * value.  This time, to ensure mutual exclusion, the scheduler itself is 
     90           * suspended with a call to vTaskSuspendAll ().  This is for demonstration 
     91           * purposes only and is not a recommended technique due to its inefficiency.
     92           *
     93           * After a fixed number of iterations the controller task suspends the 
     94           * continuous count task, and moves on to its second section.
     95           *
     96           * At the start of the second section the shared variable is cleared to zero.
     97           * The limited count task is then woken from it's suspension by a call to
     98           * vTaskResume ().  As this counter task operates at a higher priority than
     99           * the controller task the controller task should not run again until the
    100           * shared variable has been counted up to the limited value causing the counter
    101           * task to suspend itself.  The next line after vTaskResume () is therefore
    102           * a check on the shared variable to ensure everything is as expected.
    103           *
    104           *
    105           * The second test consists of a couple of very simple tasks that post onto a 
    106           * queue while the scheduler is suspended.  This test was added to test parts
    107           * of the scheduler not exercised by the first test.
    108           *
    109           */
    110          
    111          #include <stdlib.h>
    112          
    113          /* Scheduler include files. */
    114          #include "FreeRTOS.h"
    115          #include "task.h"
    116          #include "semphr.h"
    117          
    118          /* Demo app include files. */
    119          #include "dynamic.h"
    120          
    121          /* Function that implements the "limited count" task as described above. */
    122          static portTASK_FUNCTION_PROTO( vLimitedIncrementTask, pvParameters );
    123          
    124          /* Function that implements the "continuous count" task as described above. */
    125          static portTASK_FUNCTION_PROTO( vContinuousIncrementTask, pvParameters );
    126          
    127          /* Function that implements the controller task as described above. */
    128          static portTASK_FUNCTION_PROTO( vCounterControlTask, pvParameters );
    129          
    130          static portTASK_FUNCTION_PROTO( vQueueReceiveWhenSuspendedTask, pvParameters );
    131          static portTASK_FUNCTION_PROTO( vQueueSendWhenSuspendedTask, pvParameters );
    132          
    133          /* Demo task specific constants. */
    134          #define priSTACK_SIZE				( configMINIMAL_STACK_SIZE )
    135          #define priSLEEP_TIME				( ( portTickType ) 128 / portTICK_RATE_MS )
    136          #define priLOOPS					( 5 )
    137          #define priMAX_COUNT				( ( unsigned long ) 0xff )
    138          #define priNO_BLOCK					( ( portTickType ) 0 )
    139          #define priSUSPENDED_QUEUE_LENGTH	( 1 )
    140          
    141          /*-----------------------------------------------------------*/
    142          
    143          /* Handles to the two counter tasks.  These could be passed in as parameters
    144          to the controller task to prevent them having to be file scope. */

   \                                 In section .bss, align 4
    145          static xTaskHandle xContinousIncrementHandle, xLimitedIncrementHandle;
   \                     xContinousIncrementHandle:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     xLimitedIncrementHandle:
   \   00000000                      DS8 4
    146          
    147          /* The shared counter variable.  This is passed in as a parameter to the two 
    148          counter variables for demonstration purposes. */

   \                                 In section .bss, align 4
    149          static unsigned long ulCounter;
   \                     ulCounter:
   \   00000000                      DS8 4
    150          
    151          /* Variables used to check that the tasks are still operating without error.
    152          Each complete iteration of the controller task increments this variable
    153          provided no errors have been found.  The variable maintaining the same value
    154          is therefore indication of an error. */

   \                                 In section .bss, align 2
    155          static volatile unsigned short usCheckVariable = ( unsigned short ) 0;
   \                     usCheckVariable:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
    156          static volatile portBASE_TYPE xSuspendedQueueSendError = pdFALSE;
   \                     xSuspendedQueueSendError:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    157          static volatile portBASE_TYPE xSuspendedQueueReceiveError = pdFALSE;
   \                     xSuspendedQueueReceiveError:
   \   00000000                      DS8 4
    158          
    159          /* Queue used by the second test. */

   \                                 In section .bss, align 4
    160          xQueueHandle xSuspendedTestQueue;
   \                     xSuspendedTestQueue:
   \   00000000                      DS8 4
    161          
    162          /*-----------------------------------------------------------*/
    163          /*
    164           * Start the three tasks as described at the top of the file.
    165           * Note that the limited count task is given a higher priority.
    166           */

   \                                 In section .text, align 2, keep-with-next
    167          void vStartDynamicPriorityTasks( void )
    168          {
   \                     vStartDynamicPriorityTasks:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    169          	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
   \   00000004   0421               MOVS     R1,#+4
   \   00000006   0120               MOVS     R0,#+1
   \   00000008   ........           BL       xQueueCreate
   \   0000000C   ....               LDR      R1,??DataTable4
   \   0000000E   0860               STR      R0,[R1, #+0]
    170          
    171          	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
    172          	in use.  The queue registry is provided as a means for kernel aware 
    173          	debuggers to locate queues and has no purpose if a kernel aware debugger
    174          	is not being used.  The call to vQueueAddToRegistry() will be removed
    175          	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
    176          	defined to be less than 1. */
    177          	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );
    178          
    179          	xTaskCreate( vContinuousIncrementTask, ( signed char * ) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinousIncrementHandle );
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   0390               STR      R0,[SP, #+12]
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   0290               STR      R0,[SP, #+8]
   \   00000018   ....               LDR      R0,??DataTable4_1
   \   0000001A   0190               STR      R0,[SP, #+4]
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   0090               STR      R0,[SP, #+0]
   \   00000020   ....               LDR      R3,??DataTable4_2
   \   00000022   8022               MOVS     R2,#+128
   \   00000024   ....               LDR      R1,??DataTable4_3
   \   00000026   ....               LDR      R0,??DataTable4_4
   \   00000028   ........           BL       xTaskGenericCreate
    180          	xTaskCreate( vLimitedIncrementTask, ( signed char * ) "LIM_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY + 1, &xLimitedIncrementHandle );
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   0390               STR      R0,[SP, #+12]
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   0290               STR      R0,[SP, #+8]
   \   00000034   ....               LDR      R0,??DataTable4_5
   \   00000036   0190               STR      R0,[SP, #+4]
   \   00000038   0120               MOVS     R0,#+1
   \   0000003A   0090               STR      R0,[SP, #+0]
   \   0000003C   ....               LDR      R3,??DataTable4_2
   \   0000003E   8022               MOVS     R2,#+128
   \   00000040   ....               LDR      R1,??DataTable4_6
   \   00000042   ....               LDR      R0,??DataTable4_7
   \   00000044   ........           BL       xTaskGenericCreate
    181          	xTaskCreate( vCounterControlTask, ( signed char * ) "C_CTRL", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   0390               STR      R0,[SP, #+12]
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   0290               STR      R0,[SP, #+8]
   \   00000050   0020               MOVS     R0,#+0
   \   00000052   0190               STR      R0,[SP, #+4]
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   0090               STR      R0,[SP, #+0]
   \   00000058   0023               MOVS     R3,#+0
   \   0000005A   8022               MOVS     R2,#+128
   \   0000005C   ....               LDR      R1,??DataTable4_8
   \   0000005E   ....               LDR      R0,??DataTable4_9
   \   00000060   ........           BL       xTaskGenericCreate
    182          	xTaskCreate( vQueueSendWhenSuspendedTask, ( signed char * ) "SUSP_TX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   0390               STR      R0,[SP, #+12]
   \   00000068   0020               MOVS     R0,#+0
   \   0000006A   0290               STR      R0,[SP, #+8]
   \   0000006C   0020               MOVS     R0,#+0
   \   0000006E   0190               STR      R0,[SP, #+4]
   \   00000070   0020               MOVS     R0,#+0
   \   00000072   0090               STR      R0,[SP, #+0]
   \   00000074   0023               MOVS     R3,#+0
   \   00000076   8022               MOVS     R2,#+128
   \   00000078   ....               LDR      R1,??DataTable4_10
   \   0000007A   ....               LDR      R0,??DataTable4_11
   \   0000007C   ........           BL       xTaskGenericCreate
    183          	xTaskCreate( vQueueReceiveWhenSuspendedTask, ( signed char * ) "SUSP_RX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
   \   00000080   0020               MOVS     R0,#+0
   \   00000082   0390               STR      R0,[SP, #+12]
   \   00000084   0020               MOVS     R0,#+0
   \   00000086   0290               STR      R0,[SP, #+8]
   \   00000088   0020               MOVS     R0,#+0
   \   0000008A   0190               STR      R0,[SP, #+4]
   \   0000008C   0020               MOVS     R0,#+0
   \   0000008E   0090               STR      R0,[SP, #+0]
   \   00000090   0023               MOVS     R3,#+0
   \   00000092   8022               MOVS     R2,#+128
   \   00000094   ....               LDR      R1,??DataTable4_12
   \   00000096   ....               LDR      R0,??DataTable4_13
   \   00000098   ........           BL       xTaskGenericCreate
    184          }
   \   0000009C   05B0               ADD      SP,SP,#+20
   \   0000009E   00BD               POP      {PC}             ;; return
    185          /*-----------------------------------------------------------*/
    186          
    187          /*
    188           * Just loops around incrementing the shared variable until the limit has been
    189           * reached.  Once the limit has been reached it suspends itself. 
    190           */

   \                                 In section .text, align 2, keep-with-next
    191          static portTASK_FUNCTION( vLimitedIncrementTask, pvParameters )
    192          {
   \                     vLimitedIncrementTask:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    193          unsigned long *pulCounter;
    194          
    195          	/* Take a pointer to the shared variable from the parameters passed into
    196          	the task. */
    197          	pulCounter = ( unsigned long * ) pvParameters;
    198          
    199          	/* This will run before the control task, so the first thing it does is
    200          	suspend - the control task will resume it when ready. */
    201          	vTaskSuspend( NULL );
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   ........           BL       vTaskSuspend
    202          
    203          	for( ;; )
    204          	{
    205          		/* Just count up to a value then suspend. */
    206          		( *pulCounter )++;	
   \                     ??vLimitedIncrementTask_0:
   \   0000000A   2068               LDR      R0,[R4, #+0]
   \   0000000C   401C               ADDS     R0,R0,#+1
   \   0000000E   2060               STR      R0,[R4, #+0]
    207          		
    208          		if( *pulCounter >= priMAX_COUNT )
   \   00000010   2068               LDR      R0,[R4, #+0]
   \   00000012   FF28               CMP      R0,#+255
   \   00000014   F9D3               BCC      ??vLimitedIncrementTask_0
    209          		{
    210          			vTaskSuspend( NULL );
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   ........           BL       vTaskSuspend
   \   0000001C   F5E7               B        ??vLimitedIncrementTask_0
    211          		} 	
    212          	}
    213          }
    214          /*-----------------------------------------------------------*/
    215          
    216          /*
    217           * Just keep counting the shared variable up.  The control task will suspend
    218           * this task when it wants.
    219           */

   \                                 In section .text, align 2, keep-with-next
    220          static portTASK_FUNCTION( vContinuousIncrementTask, pvParameters )
    221          {
   \                     vContinuousIncrementTask:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
    222          unsigned long *pulCounter;
    223          unsigned portBASE_TYPE uxOurPriority;
    224          
    225          	/* Take a pointer to the shared variable from the parameters passed into
    226          	the task. */
    227          	pulCounter = ( unsigned long * ) pvParameters;
    228          
    229          	/* Query our priority so we can raise it when exclusive access to the 
    230          	shared variable is required. */
    231          	uxOurPriority = uxTaskPriorityGet( NULL );
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   ........           BL       uxTaskPriorityGet
   \   0000000A   0400               MOVS     R4,R0
    232          
    233          	for( ;; )
    234          	{
    235          		/* Raise our priority above the controller task to ensure a context
    236          		switch does not occur while we are accessing this variable. */
    237          		vTaskPrioritySet( NULL, uxOurPriority + 1 );
   \                     ??vContinuousIncrementTask_0:
   \   0000000C   2100               MOVS     R1,R4
   \   0000000E   491C               ADDS     R1,R1,#+1
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   ........           BL       vTaskPrioritySet
    238          			( *pulCounter )++;		
   \   00000016   2868               LDR      R0,[R5, #+0]
   \   00000018   401C               ADDS     R0,R0,#+1
   \   0000001A   2860               STR      R0,[R5, #+0]
    239          		vTaskPrioritySet( NULL, uxOurPriority );
   \   0000001C   2100               MOVS     R1,R4
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   ........           BL       vTaskPrioritySet
   \   00000024   F2E7               B        ??vContinuousIncrementTask_0
    240          	}
    241          }
    242          /*-----------------------------------------------------------*/
    243          
    244          /*
    245           * Controller task as described above.
    246           */

   \                                 In section .text, align 2, keep-with-next
    247          static portTASK_FUNCTION( vCounterControlTask, pvParameters )
    248          {
   \                     vCounterControlTask:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    249          unsigned long ulLastCounter;
    250          short sLoops;
    251          short sError = pdFALSE;
   \   00000002   0024               MOVS     R4,#+0
    252          
    253          	/* Just to stop warning messages. */
    254          	( void ) pvParameters;
   \   00000004   39E0               B        ??vCounterControlTask_0
    255          
    256          	for( ;; )
    257          	{
    258          		/* Start with the counter at zero. */
    259          		ulCounter = ( unsigned long ) 0;
    260          
    261          		/* First section : */
    262          
    263          		/* Check the continuous count task is running. */
    264          		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
    265          		{
    266          			/* Suspend the continuous count task so we can take a mirror of the
    267          			shared variable without risk of corruption. */
    268          			vTaskSuspend( xContinousIncrementHandle );
   \                     ??vCounterControlTask_1:
   \   00000006   ....               LDR      R0,??DataTable4_1
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   ........           BL       vTaskSuspend
    269          				ulLastCounter = ulCounter;
   \   0000000E   ....               LDR      R0,??DataTable4_2
   \   00000010   0668               LDR      R6,[R0, #+0]
    270          			vTaskResume( xContinousIncrementHandle );
   \   00000012   ....               LDR      R0,??DataTable4_1
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   ........           BL       vTaskResume
    271          			
    272          			/* Now delay to ensure the other task has processor time. */
    273          			vTaskDelay( priSLEEP_TIME );
   \   0000001A   8020               MOVS     R0,#+128
   \   0000001C   ........           BL       vTaskDelay
    274          
    275          			/* Check the shared variable again.  This time to ensure mutual 
    276          			exclusion the whole scheduler will be locked.  This is just for
    277          			demo purposes! */
    278          			vTaskSuspendAll();
   \   00000020   ........           BL       vTaskSuspendAll
    279          			{
    280          				if( ulLastCounter == ulCounter )
   \   00000024   ....               LDR      R0,??DataTable4_2
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   8642               CMP      R6,R0
   \   0000002A   00D1               BNE      ??vCounterControlTask_2
    281          				{
    282          					/* The shared variable has not changed.  There is a problem
    283          					with the continuous count task so flag an error. */
    284          					sError = pdTRUE;
   \   0000002C   0124               MOVS     R4,#+1
    285          				}
    286          			}
    287          			xTaskResumeAll();
   \                     ??vCounterControlTask_2:
   \   0000002E   ........           BL       xTaskResumeAll
    288          		}
   \   00000032   6D1C               ADDS     R5,R5,#+1
   \                     ??vCounterControlTask_3:
   \   00000034   2DB2               SXTH     R5,R5
   \   00000036   052D               CMP      R5,#+5
   \   00000038   E5DB               BLT      ??vCounterControlTask_1
    289          
    290          
    291          		/* Second section: */
    292          
    293          		/* Suspend the continuous counter task so it stops accessing the shared variable. */
    294          		vTaskSuspend( xContinousIncrementHandle );
   \   0000003A   ....               LDR      R0,??DataTable4_1
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   ........           BL       vTaskSuspend
    295          
    296          		/* Reset the variable. */
    297          		ulCounter = ( unsigned long ) 0;
   \   00000042   ....               LDR      R0,??DataTable4_2
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0160               STR      R1,[R0, #+0]
    298          
    299          		/* Resume the limited count task which has a higher priority than us.
    300          		We should therefore not return from this call until the limited count
    301          		task has suspended itself with a known value in the counter variable. */
    302          		vTaskResume( xLimitedIncrementHandle );
   \   00000048   ....               LDR      R0,??DataTable4_5
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   ........           BL       vTaskResume
    303          
    304          		/* Does the counter variable have the expected value? */
    305          		if( ulCounter != priMAX_COUNT )
   \   00000050   ....               LDR      R0,??DataTable4_2
   \   00000052   0068               LDR      R0,[R0, #+0]
   \   00000054   FF28               CMP      R0,#+255
   \   00000056   00D0               BEQ      ??vCounterControlTask_4
    306          		{
    307          			sError = pdTRUE;
   \   00000058   0124               MOVS     R4,#+1
    308          		}
    309          
    310          		if( sError == pdFALSE )
   \                     ??vCounterControlTask_4:
   \   0000005A   24B2               SXTH     R4,R4
   \   0000005C   002C               CMP      R4,#+0
   \   0000005E   08D1               BNE      ??vCounterControlTask_5
    311          		{
    312          			/* If no errors have occurred then increment the check variable. */
    313          			portENTER_CRITICAL();
   \   00000060   ........           BL       vPortEnterCritical
    314          				usCheckVariable++;
   \   00000064   ....               LDR      R0,??DataTable4_14
   \   00000066   0088               LDRH     R0,[R0, #+0]
   \   00000068   401C               ADDS     R0,R0,#+1
   \   0000006A   ....               LDR      R1,??DataTable4_14
   \   0000006C   0880               STRH     R0,[R1, #+0]
    315          			portEXIT_CRITICAL();
   \   0000006E   ........           BL       vPortExitCritical
    316          		}
    317          
    318          		/* Resume the continuous count task and do it all again. */
    319          		vTaskResume( xContinousIncrementHandle );
   \                     ??vCounterControlTask_5:
   \   00000072   ....               LDR      R0,??DataTable4_1
   \   00000074   0068               LDR      R0,[R0, #+0]
   \   00000076   ........           BL       vTaskResume
   \                     ??vCounterControlTask_0:
   \   0000007A   ....               LDR      R0,??DataTable4_2
   \   0000007C   0021               MOVS     R1,#+0
   \   0000007E   0160               STR      R1,[R0, #+0]
   \   00000080   0025               MOVS     R5,#+0
   \   00000082   D7E7               B        ??vCounterControlTask_3
    320          	}
    321          }
    322          /*-----------------------------------------------------------*/
    323          

   \                                 In section .text, align 2, keep-with-next
    324          static portTASK_FUNCTION( vQueueSendWhenSuspendedTask, pvParameters )
    325          {
   \                     vQueueSendWhenSuspendedTask:
   \   00000000   80B5               PUSH     {R7,LR}
    326          static unsigned long ulValueToSend = ( unsigned long ) 0;
    327          
    328          	/* Just to stop warning messages. */
    329          	( void ) pvParameters;
    330          
    331          	for( ;; )
    332          	{
    333          		vTaskSuspendAll();
   \                     ??vQueueSendWhenSuspendedTask_0:
   \   00000002   ........           BL       vTaskSuspendAll
    334          		{
    335          			/* We must not block while the scheduler is suspended! */
    336          			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   ....               LDR      R1,??DataTable4_15
   \   0000000C   ....               LDR      R0,??DataTable4
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   ........           BL       xQueueGenericSend
   \   00000014   0128               CMP      R0,#+1
   \   00000016   02D0               BEQ      ??vQueueSendWhenSuspendedTask_1
    337          			{
    338          				xSuspendedQueueSendError = pdTRUE;
   \   00000018   ....               LDR      R0,??DataTable4_16
   \   0000001A   0121               MOVS     R1,#+1
   \   0000001C   0160               STR      R1,[R0, #+0]
    339          			}
    340          		}
    341          		xTaskResumeAll();
   \                     ??vQueueSendWhenSuspendedTask_1:
   \   0000001E   ........           BL       xTaskResumeAll
    342          
    343          		vTaskDelay( priSLEEP_TIME );
   \   00000022   8020               MOVS     R0,#+128
   \   00000024   ........           BL       vTaskDelay
    344          
    345          		++ulValueToSend;
   \   00000028   ....               LDR      R0,??DataTable4_15
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   401C               ADDS     R0,R0,#+1
   \   0000002E   ....               LDR      R1,??DataTable4_15
   \   00000030   0860               STR      R0,[R1, #+0]
   \   00000032   E6E7               B        ??vQueueSendWhenSuspendedTask_0
    346          	}
    347          }

   \                                 In section .bss, align 4
   \                     ??ulValueToSend:
   \   00000000                      DS8 4
    348          /*-----------------------------------------------------------*/
    349          

   \                                 In section .text, align 2, keep-with-next
    350          static portTASK_FUNCTION( vQueueReceiveWhenSuspendedTask, pvParameters )
    351          {
   \                     vQueueReceiveWhenSuspendedTask:
   \   00000000   10B5               PUSH     {R4,LR}
    352          static unsigned long ulExpectedValue = ( unsigned long ) 0, ulReceivedValue;
    353          portBASE_TYPE xGotValue;
    354          
    355          	/* Just to stop warning messages. */
    356          	( void ) pvParameters;
    357          
    358          	for( ;; )
    359          	{
    360          		do
    361          		{
    362          			/* Suspending the scheduler here is fairly pointless and 
    363          			undesirable for a normal application.  It is done here purely
    364          			to test the scheduler.  The inner xTaskResumeAll() should
    365          			never return pdTRUE as the scheduler is still locked by the
    366          			outer call. */
    367          			vTaskSuspendAll();
   \                     ??vQueueReceiveWhenSuspendedTask_0:
   \   00000002   ........           BL       vTaskSuspendAll
    368          			{
    369          				vTaskSuspendAll();
   \   00000006   ........           BL       vTaskSuspendAll
    370          				{
    371          					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
   \   0000000A   0023               MOVS     R3,#+0
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   ....               LDR      R1,??DataTable4_17
   \   00000010   ....               LDR      R0,??DataTable4
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   ........           BL       xQueueGenericReceive
   \   00000018   0400               MOVS     R4,R0
    372          				}
    373          				if( xTaskResumeAll() )
   \   0000001A   ........           BL       xTaskResumeAll
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   02D0               BEQ      ??vQueueReceiveWhenSuspendedTask_1
    374          				{
    375          					xSuspendedQueueReceiveError = pdTRUE;
   \   00000022   ....               LDR      R0,??DataTable4_18
   \   00000024   0121               MOVS     R1,#+1
   \   00000026   0160               STR      R1,[R0, #+0]
    376          				}
    377          			}
    378          			xTaskResumeAll();
   \                     ??vQueueReceiveWhenSuspendedTask_1:
   \   00000028   ........           BL       xTaskResumeAll
    379          
    380          			#if configUSE_PREEMPTION == 0
    381          			{
    382          				taskYIELD();
    383          			}
    384          			#endif
    385          
    386          		} while( xGotValue == pdFALSE );
   \   0000002C   002C               CMP      R4,#+0
   \   0000002E   E8D0               BEQ      ??vQueueReceiveWhenSuspendedTask_0
    387          
    388          		if( ulReceivedValue != ulExpectedValue )
   \   00000030   ....               LDR      R0,??DataTable4_17
   \   00000032   0068               LDR      R0,[R0, #+0]
   \   00000034   ....               LDR      R1,??DataTable4_19
   \   00000036   0968               LDR      R1,[R1, #+0]
   \   00000038   8842               CMP      R0,R1
   \   0000003A   02D0               BEQ      ??vQueueReceiveWhenSuspendedTask_2
    389          		{
    390          			xSuspendedQueueReceiveError = pdTRUE;
   \   0000003C   ....               LDR      R0,??DataTable4_18
   \   0000003E   0121               MOVS     R1,#+1
   \   00000040   0160               STR      R1,[R0, #+0]
    391          		}
    392          
    393          		++ulExpectedValue;
   \                     ??vQueueReceiveWhenSuspendedTask_2:
   \   00000042   ....               LDR      R0,??DataTable4_19
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   401C               ADDS     R0,R0,#+1
   \   00000048   ....               LDR      R1,??DataTable4_19
   \   0000004A   0860               STR      R0,[R1, #+0]
   \   0000004C   D9E7               B        ??vQueueReceiveWhenSuspendedTask_0
    394          	}
    395          }

   \                                 In section .bss, align 4
   \                     ??ulExpectedValue:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ??ulReceivedValue:
   \   00000000                      DS8 4
    396          /*-----------------------------------------------------------*/
    397          
    398          /* Called to check that all the created tasks are still running without error. */

   \                                 In section .text, align 2, keep-with-next
    399          portBASE_TYPE xAreDynamicPriorityTasksStillRunning( void )
    400          {
   \                     xAreDynamicPriorityTasksStillRunning:
   \   00000000   00B5               PUSH     {LR}
    401          /* Keep a history of the check variables so we know if it has been incremented 
    402          since the last call. */
    403          static unsigned short usLastTaskCheck = ( unsigned short ) 0;
    404          portBASE_TYPE xReturn = pdTRUE;
   \   00000002   0120               MOVS     R0,#+1
    405          
    406          	/* Check the tasks are still running by ensuring the check variable
    407          	is still incrementing. */
    408          
    409          	if( usCheckVariable == usLastTaskCheck )
   \   00000004   ....               LDR      R1,??DataTable4_14
   \   00000006   0988               LDRH     R1,[R1, #+0]
   \   00000008   ....               LDR      R2,??DataTable4_20
   \   0000000A   1288               LDRH     R2,[R2, #+0]
   \   0000000C   9142               CMP      R1,R2
   \   0000000E   00D1               BNE      ??xAreDynamicPriorityTasksStillRunning_0
    410          	{
    411          		/* The check has not incremented so an error exists. */
    412          		xReturn = pdFALSE;
   \   00000010   0020               MOVS     R0,#+0
    413          	}
    414          
    415          	if( xSuspendedQueueSendError == pdTRUE )
   \                     ??xAreDynamicPriorityTasksStillRunning_0:
   \   00000012   ....               LDR      R1,??DataTable4_16
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   0129               CMP      R1,#+1
   \   00000018   00D1               BNE      ??xAreDynamicPriorityTasksStillRunning_1
    416          	{
    417          		xReturn = pdFALSE;
   \   0000001A   0020               MOVS     R0,#+0
    418          	}
    419          
    420          	if( xSuspendedQueueReceiveError == pdTRUE )
   \                     ??xAreDynamicPriorityTasksStillRunning_1:
   \   0000001C   ....               LDR      R1,??DataTable4_18
   \   0000001E   0968               LDR      R1,[R1, #+0]
   \   00000020   0129               CMP      R1,#+1
   \   00000022   00D1               BNE      ??xAreDynamicPriorityTasksStillRunning_2
    421          	{
    422          		xReturn = pdFALSE;
   \   00000024   0020               MOVS     R0,#+0
    423          	}
    424          
    425          	usLastTaskCheck = usCheckVariable;
   \                     ??xAreDynamicPriorityTasksStillRunning_2:
   \   00000026   ....               LDR      R1,??DataTable4_20
   \   00000028   ....               LDR      R2,??DataTable4_14
   \   0000002A   1288               LDRH     R2,[R2, #+0]
   \   0000002C   0A80               STRH     R2,[R1, #+0]
    426          	return xReturn;
   \   0000002E   00BD               POP      {PC}             ;; return
    427          }

   \                                 In section .bss, align 2
   \                     ??usLastTaskCheck:
   \   00000000                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     xSuspendedTestQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     xContinousIncrementHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     ulCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   ........           DC32     `?<Constant "CNT_INC">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     vContinuousIncrementTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   ........           DC32     xLimitedIncrementHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   ........           DC32     `?<Constant "LIM_INC">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   ........           DC32     vLimitedIncrementTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   ........           DC32     `?<Constant "C_CTRL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   ........           DC32     vCounterControlTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   ........           DC32     `?<Constant "SUSP_TX">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   ........           DC32     vQueueSendWhenSuspendedTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   ........           DC32     `?<Constant "SUSP_RX">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   ........           DC32     vQueueReceiveWhenSuspendedTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   ........           DC32     usCheckVariable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   ........           DC32     ??ulValueToSend

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   ........           DC32     xSuspendedQueueSendError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   ........           DC32     ??ulReceivedValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_18:
   \   00000000   ........           DC32     xSuspendedQueueReceiveError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_19:
   \   00000000   ........           DC32     ??ulExpectedValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_20:
   \   00000000   ........           DC32     ??usLastTaskCheck

   \                                 In section .rodata, align 4
   \                     `?<Constant "CNT_INC">`:
   \   00000000   434E545F494E       DC8 "CNT_INC"
   \              4300        

   \                                 In section .rodata, align 4
   \                     `?<Constant "LIM_INC">`:
   \   00000000   4C494D5F494E       DC8 "LIM_INC"
   \              4300        

   \                                 In section .rodata, align 4
   \                     `?<Constant "C_CTRL">`:
   \   00000000   435F4354524C       DC8 "C_CTRL"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "SUSP_TX">`:
   \   00000000   535553505F54       DC8 "SUSP_TX"
   \              5800        

   \                                 In section .rodata, align 4
   \                     `?<Constant "SUSP_RX">`:
   \   00000000   535553505F52       DC8 "SUSP_RX"
   \              5800        

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     vContinuousIncrementTask           16
     vCounterControlTask                16
     vLimitedIncrementTask               8
     vQueueReceiveWhenSuspendedTask      8
     vQueueSendWhenSuspendedTask         8
     vStartDynamicPriorityTasks         24
     xAreDynamicPriorityTasksStillRunning
                                         4


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     xContinousIncrementHandle         4
     xLimitedIncrementHandle           4
     ulCounter                         4
     usCheckVariable                   2
     xSuspendedQueueSendError          4
     xSuspendedQueueReceiveError       4
     xSuspendedTestQueue               4
     vStartDynamicPriorityTasks      160
     vLimitedIncrementTask            30
     vContinuousIncrementTask         38
     vCounterControlTask             132
     vQueueSendWhenSuspendedTask      52
     ulValueToSend                     4
     vQueueReceiveWhenSuspendedTask   78
     ulExpectedValue                   4
     ulReceivedValue                   4
     xAreDynamicPriorityTasksStillRunning
                                      48
     usLastTaskCheck                   2
     ??DataTable4                      4
     ??DataTable4_1                    4
     ??DataTable4_2                    4
     ??DataTable4_3                    4
     ??DataTable4_4                    4
     ??DataTable4_5                    4
     ??DataTable4_6                    4
     ??DataTable4_7                    4
     ??DataTable4_8                    4
     ??DataTable4_9                    4
     ??DataTable4_10                   4
     ??DataTable4_11                   4
     ??DataTable4_12                   4
     ??DataTable4_13                   4
     ??DataTable4_14                   4
     ??DataTable4_15                   4
     ??DataTable4_16                   4
     ??DataTable4_17                   4
     ??DataTable4_18                   4
     ??DataTable4_19                   4
     ??DataTable4_20                   4
     ?<Constant "CNT_INC">             8
     ?<Constant "LIM_INC">             8
     ?<Constant "C_CTRL">              8
     ?<Constant "SUSP_TX">             8
     ?<Constant "SUSP_RX">             8

 
  40 bytes in section .bss
  40 bytes in section .rodata
 622 bytes in section .text
 
 622 bytes of CODE  memory
  40 bytes of CONST memory
  40 bytes of DATA  memory

Errors: none
Warnings: none
