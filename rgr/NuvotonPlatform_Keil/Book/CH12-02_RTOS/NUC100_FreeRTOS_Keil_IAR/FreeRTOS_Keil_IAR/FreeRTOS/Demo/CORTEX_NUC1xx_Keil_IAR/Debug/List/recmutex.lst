###############################################################################
#                                                                             #
#                                                       06/Jul/2010  14:34:57 #
# IAR ANSI C/C++ Compiler V5.50.0.21878/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\recmut #
#                    ex.c                                                     #
#    Command line =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\recmut #
#                    ex.c -D IAR_ARM_CM0 -lCN E:\FreeRTOS_Keil_IAR\FreeRTOS\D #
#                    emo\CORTEX_NUC1xx_Keil_IAR\Debug\List\ --diag_suppress   #
#                    Pe550,Pa082,Pa039 -o E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\ #
#                    CORTEX_NUC1xx_Keil_IAR\Debug\Obj\ --no_cse --no_unroll   #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M0  #
#                    -e --fpu=None --dlib_config "D:\Program                  #
#                    Files\ARM\INC\DLib_Config_Full.h" -I                     #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\..\common\include\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\De #
#                    mo\CORTEX_NUC1xx_Keil_IAR\..\..\source\include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_K #
#                    eil_IAR\NUC1xxBSP\NuvotonPlatform_Keil\Include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\NuvotonPlatform_Keil\Include\Driver\ -I      #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\CMSIS\CM0\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\ #
#                    Demo\CORTEX_NUC1xx_Keil_IAR\User_Demo\include\ -I        #
#                    "D:\Program Files\ARM\INC\" -Ol                          #
#    List file    =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\List\recmutex.lst                                #
#    Object file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\Obj\recmutex.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\recmutex.c
      1          /*
      2              FreeRTOS V6.0.5 - Copyright (C) 2010 Real Time Engineers Ltd.
      3          
      4              ***************************************************************************
      5              *                                                                         *
      6              * If you are:                                                             *
      7              *                                                                         *
      8              *    + New to FreeRTOS,                                                   *
      9              *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
     10              *    + Looking for basic training,                                        *
     11              *    + Wanting to improve your FreeRTOS skills and productivity           *
     12              *                                                                         *
     13              * then take a look at the FreeRTOS eBook                                  *
     14              *                                                                         *
     15              *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
     16              *                  http://www.FreeRTOS.org/Documentation                  *
     17              *                                                                         *
     18              * A pdf reference manual is also available.  Both are usually delivered   *
     19              * to your inbox within 20 minutes to two hours when purchased between 8am *
     20              * and 8pm GMT (although please allow up to 24 hours in case of            *
     21              * exceptional circumstances).  Thank you for your support!                *
     22              *                                                                         *
     23              ***************************************************************************
     24          
     25              This file is part of the FreeRTOS distribution.
     26          
     27              FreeRTOS is free software; you can redistribute it and/or modify it under
     28              the terms of the GNU General Public License (version 2) as published by the
     29              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     30              ***NOTE*** The exception to the GPL is included to allow you to distribute
     31              a combined work that includes FreeRTOS without being obliged to provide the
     32              source code for proprietary components outside of the FreeRTOS kernel.
     33              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
     34              ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     35              FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     36              more details. You should have received a copy of the GNU General Public 
     37              License and the FreeRTOS license exception along with FreeRTOS; if not it 
     38              can be viewed here: http://www.freertos.org/a00114.html and also obtained 
     39              by writing to Richard Barry, contact details for whom are available on the
     40              FreeRTOS WEB site.
     41          
     42              1 tab == 4 spaces!
     43          
     44              http://www.FreeRTOS.org - Documentation, latest information, license and
     45              contact details.
     46          
     47              http://www.SafeRTOS.com - A version that is certified for use in safety
     48              critical systems.
     49          
     50              http://www.OpenRTOS.com - Commercial support, development, porting,
     51              licensing and training services.
     52          */
     53          
     54          /*
     55          	The tasks defined on this page demonstrate the use of recursive mutexes.
     56          
     57          	For recursive mutex functionality the created mutex should be created using
     58          	xSemaphoreCreateRecursiveMutex(), then be manipulated
     59          	using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() API
     60          	functions.
     61          
     62          	This demo creates three tasks all of which access the same recursive mutex:
     63          
     64          	prvRecursiveMutexControllingTask() has the highest priority so executes 
     65          	first and grabs the mutex.  It then performs some recursive accesses - 
     66          	between each of which it sleeps for a short period to let the lower 
     67          	priority tasks execute.  When it has completed its demo functionality
     68          	it gives the mutex back before suspending itself.
     69          
     70          	prvRecursiveMutexBlockingTask() attempts to access the mutex by performing
     71          	a blocking 'take'.  The blocking task has a lower priority than the 
     72          	controlling	task so by the time it executes the mutex has already been
     73          	taken by the controlling task,  causing the blocking task to block.  It 
     74          	does not unblock until the controlling task has given the mutex back, 
     75          	and it does not actually run until the controlling task has suspended 
     76          	itself (due to the relative priorities).  When it eventually does obtain
     77          	the mutex all it does is give the mutex back prior to also suspending 
     78          	itself.  At this point both the controlling task and the blocking task are 
     79          	suspended.
     80          
     81          	prvRecursiveMutexPollingTask() runs at the idle priority.  It spins round
     82          	a tight loop attempting to obtain the mutex with a non-blocking call.  As
     83          	the lowest priority task it will not successfully obtain the mutex until
     84          	both the controlling and blocking tasks are suspended.  Once it eventually 
     85          	does obtain the mutex it first unsuspends both the controlling task and
     86          	blocking task prior to giving the mutex back - resulting in the polling
     87          	task temporarily inheriting the controlling tasks priority.
     88          */
     89          
     90          /* Scheduler include files. */
     91          #include "FreeRTOS.h"
     92          #include "task.h"
     93          #include "semphr.h"
     94          
     95          /* Demo app include files. */
     96          #include "recmutex.h"
     97          
     98          /* Priorities assigned to the three tasks. */
     99          #define recmuCONTROLLING_TASK_PRIORITY	( tskIDLE_PRIORITY + 2 )
    100          #define recmuBLOCKING_TASK_PRIORITY		( tskIDLE_PRIORITY + 1 )
    101          #define recmuPOLLING_TASK_PRIORITY		( tskIDLE_PRIORITY + 0 )
    102          
    103          /* The recursive call depth. */
    104          #define recmuMAX_COUNT					( 10 )
    105          
    106          /* Misc. */
    107          #define recmuSHORT_DELAY				( 20 / portTICK_RATE_MS )
    108          #define recmuNO_DELAY					( ( portTickType ) 0 )
    109          #define recmuTWO_TICK_DELAY				( ( portTickType ) 2 )
    110          
    111          /* The three tasks as described at the top of this file. */
    112          static void prvRecursiveMutexControllingTask( void *pvParameters );
    113          static void prvRecursiveMutexBlockingTask( void *pvParameters );
    114          static void prvRecursiveMutexPollingTask( void *pvParameters );
    115          
    116          /* The mutex used by the demo. */

   \                                 In section .bss, align 4
    117          static xSemaphoreHandle xMutex;
   \                     xMutex:
   \   00000000                      DS8 4
    118          
    119          /* Variables used to detect and latch errors. */

   \                                 In section .bss, align 4
    120          static volatile portBASE_TYPE xErrorOccurred = pdFALSE, xControllingIsSuspended = pdFALSE, xBlockingIsSuspended = pdFALSE;
   \                     xErrorOccurred:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     xControllingIsSuspended:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     xBlockingIsSuspended:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    121          static volatile unsigned portBASE_TYPE uxControllingCycles = 0, uxBlockingCycles, uxPollingCycles = 0;
   \                     uxControllingCycles:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     uxBlockingCycles:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     uxPollingCycles:
   \   00000000                      DS8 4
    122          
    123          /* Handles of the two higher priority tasks, required so they can be resumed 
    124          (unsuspended). */

   \                                 In section .bss, align 4
    125          static xTaskHandle xControllingTaskHandle, xBlockingTaskHandle;
   \                     xControllingTaskHandle:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     xBlockingTaskHandle:
   \   00000000                      DS8 4
    126          
    127          /*-----------------------------------------------------------*/
    128          

   \                                 In section .text, align 2, keep-with-next
    129          void vStartRecursiveMutexTasks( void )
    130          {
   \                     vStartRecursiveMutexTasks:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    131          	/* Just creates the mutex and the three tasks. */
    132          
    133          	xMutex = xSemaphoreCreateRecursiveMutex();
   \   00000004   ........           BL       xQueueCreateMutex
   \   00000008   ....               LDR      R1,??DataTable4
   \   0000000A   0860               STR      R0,[R1, #+0]
    134          
    135          	/* vQueueAddToRegistry() adds the mutex to the registry, if one is
    136          	in use.  The registry is provided as a means for kernel aware 
    137          	debuggers to locate mutex and has no purpose if a kernel aware debugger
    138          	is not being used.  The call to vQueueAddToRegistry() will be removed
    139          	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
    140          	defined to be less than 1. */
    141          	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Recursive_Mutex" );
    142          
    143          
    144          	if( xMutex != NULL )
   \   0000000C   ....               LDR      R0,??DataTable4
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   0028               CMP      R0,#+0
   \   00000012   29D0               BEQ      ??vStartRecursiveMutexTasks_0
    145          	{
    146          		xTaskCreate( prvRecursiveMutexControllingTask, ( signed portCHAR * ) "Rec1", configMINIMAL_STACK_SIZE, NULL, recmuCONTROLLING_TASK_PRIORITY, &xControllingTaskHandle );
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   0390               STR      R0,[SP, #+12]
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   0290               STR      R0,[SP, #+8]
   \   0000001C   ....               LDR      R0,??DataTable4_1
   \   0000001E   0190               STR      R0,[SP, #+4]
   \   00000020   0220               MOVS     R0,#+2
   \   00000022   0090               STR      R0,[SP, #+0]
   \   00000024   0023               MOVS     R3,#+0
   \   00000026   8022               MOVS     R2,#+128
   \   00000028   ....               LDR      R1,??DataTable4_2
   \   0000002A   ....               LDR      R0,??DataTable4_3
   \   0000002C   ........           BL       xTaskGenericCreate
    147                  xTaskCreate( prvRecursiveMutexBlockingTask, ( signed portCHAR * ) "Rec2", configMINIMAL_STACK_SIZE, NULL, recmuBLOCKING_TASK_PRIORITY, &xBlockingTaskHandle );
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   0390               STR      R0,[SP, #+12]
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   0290               STR      R0,[SP, #+8]
   \   00000038   ....               LDR      R0,??DataTable4_4
   \   0000003A   0190               STR      R0,[SP, #+4]
   \   0000003C   0120               MOVS     R0,#+1
   \   0000003E   0090               STR      R0,[SP, #+0]
   \   00000040   0023               MOVS     R3,#+0
   \   00000042   8022               MOVS     R2,#+128
   \   00000044   ....               LDR      R1,??DataTable4_5
   \   00000046   ....               LDR      R0,??DataTable4_6
   \   00000048   ........           BL       xTaskGenericCreate
    148                  xTaskCreate( prvRecursiveMutexPollingTask, ( signed portCHAR * ) "Rec3", configMINIMAL_STACK_SIZE, NULL, recmuPOLLING_TASK_PRIORITY, NULL );
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   0390               STR      R0,[SP, #+12]
   \   00000050   0020               MOVS     R0,#+0
   \   00000052   0290               STR      R0,[SP, #+8]
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   0190               STR      R0,[SP, #+4]
   \   00000058   0020               MOVS     R0,#+0
   \   0000005A   0090               STR      R0,[SP, #+0]
   \   0000005C   0023               MOVS     R3,#+0
   \   0000005E   8022               MOVS     R2,#+128
   \   00000060   ....               LDR      R1,??DataTable4_7
   \   00000062   ....               LDR      R0,??DataTable4_8
   \   00000064   ........           BL       xTaskGenericCreate
    149          	}
    150          }
   \                     ??vStartRecursiveMutexTasks_0:
   \   00000068   05B0               ADD      SP,SP,#+20
   \   0000006A   00BD               POP      {PC}             ;; return
    151          /*-----------------------------------------------------------*/
    152          

   \                                 In section .text, align 2, keep-with-next
    153          static void prvRecursiveMutexControllingTask( void *pvParameters )
    154          {
   \                     prvRecursiveMutexControllingTask:
   \   00000000   10B5               PUSH     {R4,LR}
    155          unsigned portBASE_TYPE ux;
    156          
    157          	/* Just to remove compiler warning. */
    158          	( void ) pvParameters;
   \   00000002   25E0               B        ??prvRecursiveMutexControllingTask_0
    159          
    160          	for( ;; )
    161          	{
    162          		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
    163          		it. */
    164          		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
    165          		{
    166          			xErrorOccurred = pdTRUE;
    167          		}
    168          
    169          		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
    170          		{
    171          			/* We should now be able to take the mutex as many times as
    172          			we like.  A one tick delay is used so the polling task will
    173          			inherit our priority on all but the first cycle of this task. 
    174          			If we did not block attempting to receive the mutex then no
    175          			priority inheritance would occur. */
    176          			if( xSemaphoreTakeRecursive( xMutex, recmuTWO_TICK_DELAY ) != pdPASS )
    177          			{
    178          				xErrorOccurred = pdTRUE;
    179          			}
    180          
    181          			/* Ensure the other task attempting to access the mutex (and the
    182          			other demo tasks) are able to execute. */
    183          			vTaskDelay( recmuSHORT_DELAY );
    184          		}
    185          
    186          		/* For each time we took the mutex, give it back. */
    187          		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
    188          		{
    189          			/* Ensure the other task attempting to access the mutex (and the
    190          			other demo tasks) are able to execute. */
    191          			vTaskDelay( recmuSHORT_DELAY );
   \                     ??prvRecursiveMutexControllingTask_1:
   \   00000004   1420               MOVS     R0,#+20
   \   00000006   ........           BL       vTaskDelay
    192          
    193          			/* We should now be able to give the mutex as many times as we
    194          			took it. */
    195          			if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
   \   0000000A   ....               LDR      R0,??DataTable4
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   ........           BL       xQueueGiveMutexRecursive
   \   00000012   0128               CMP      R0,#+1
   \   00000014   02D0               BEQ      ??prvRecursiveMutexControllingTask_2
    196          			{
    197          				xErrorOccurred = pdTRUE;
   \   00000016   ....               LDR      R0,??DataTable4_9
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   0160               STR      R1,[R0, #+0]
    198          			}
    199          		}
   \                     ??prvRecursiveMutexControllingTask_2:
   \   0000001C   641C               ADDS     R4,R4,#+1
   \                     ??prvRecursiveMutexControllingTask_3:
   \   0000001E   0A2C               CMP      R4,#+10
   \   00000020   F0D3               BCC      ??prvRecursiveMutexControllingTask_1
    200          
    201          		/* Having given it back the same number of times as it was taken, we
    202          		should no longer be the mutex owner, so the next give sh ould fail. */
    203          		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
   \   00000022   ....               LDR      R0,??DataTable4
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   ........           BL       xQueueGiveMutexRecursive
   \   0000002A   0128               CMP      R0,#+1
   \   0000002C   02D1               BNE      ??prvRecursiveMutexControllingTask_4
    204          		{
    205          			xErrorOccurred = pdTRUE;
   \   0000002E   ....               LDR      R0,??DataTable4_9
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   0160               STR      R1,[R0, #+0]
    206          		}
    207          
    208          		/* Keep count of the number of cycles this task has performed so a 
    209          		stall can be detected. */
    210          		uxControllingCycles++;
   \                     ??prvRecursiveMutexControllingTask_4:
   \   00000034   ....               LDR      R0,??DataTable4_10
   \   00000036   0068               LDR      R0,[R0, #+0]
   \   00000038   401C               ADDS     R0,R0,#+1
   \   0000003A   ....               LDR      R1,??DataTable4_10
   \   0000003C   0860               STR      R0,[R1, #+0]
    211          
    212          		/* Suspend ourselves to the blocking task can execute. */
    213          		xControllingIsSuspended = pdTRUE;
   \   0000003E   ....               LDR      R0,??DataTable4_11
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   0160               STR      R1,[R0, #+0]
    214          		vTaskSuspend( NULL );
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   ........           BL       vTaskSuspend
    215          		xControllingIsSuspended = pdFALSE;
   \   0000004A   ....               LDR      R0,??DataTable4_11
   \   0000004C   0021               MOVS     R1,#+0
   \   0000004E   0160               STR      R1,[R0, #+0]
   \                     ??prvRecursiveMutexControllingTask_0:
   \   00000050   ....               LDR      R0,??DataTable4
   \   00000052   0068               LDR      R0,[R0, #+0]
   \   00000054   ........           BL       xQueueGiveMutexRecursive
   \   00000058   0128               CMP      R0,#+1
   \   0000005A   02D1               BNE      ??prvRecursiveMutexControllingTask_5
   \   0000005C   ....               LDR      R0,??DataTable4_9
   \   0000005E   0121               MOVS     R1,#+1
   \   00000060   0160               STR      R1,[R0, #+0]
   \                     ??prvRecursiveMutexControllingTask_5:
   \   00000062   0024               MOVS     R4,#+0
   \   00000064   0DE0               B        ??prvRecursiveMutexControllingTask_6
   \                     ??prvRecursiveMutexControllingTask_7:
   \   00000066   0221               MOVS     R1,#+2
   \   00000068   ....               LDR      R0,??DataTable4
   \   0000006A   0068               LDR      R0,[R0, #+0]
   \   0000006C   ........           BL       xQueueTakeMutexRecursive
   \   00000070   0128               CMP      R0,#+1
   \   00000072   02D0               BEQ      ??prvRecursiveMutexControllingTask_8
   \   00000074   ....               LDR      R0,??DataTable4_9
   \   00000076   0121               MOVS     R1,#+1
   \   00000078   0160               STR      R1,[R0, #+0]
   \                     ??prvRecursiveMutexControllingTask_8:
   \   0000007A   1420               MOVS     R0,#+20
   \   0000007C   ........           BL       vTaskDelay
   \   00000080   641C               ADDS     R4,R4,#+1
   \                     ??prvRecursiveMutexControllingTask_6:
   \   00000082   0A2C               CMP      R4,#+10
   \   00000084   EFD3               BCC      ??prvRecursiveMutexControllingTask_7
   \   00000086   0024               MOVS     R4,#+0
   \   00000088   C9E7               B        ??prvRecursiveMutexControllingTask_3
    216          	}
    217          }
    218          /*-----------------------------------------------------------*/
    219          

   \                                 In section .text, align 2, keep-with-next
    220          static void prvRecursiveMutexBlockingTask( void *pvParameters )
    221          {
   \                     prvRecursiveMutexBlockingTask:
   \   00000000   80B5               PUSH     {R7,LR}
    222          	/* Just to remove compiler warning. */
    223          	( void ) pvParameters;
   \   00000002   11E0               B        ??prvRecursiveMutexBlockingTask_0
    224          
    225          	for( ;; )
    226          	{
    227          		/* Attempt to obtain the mutex.  We should block until the 
    228          		controlling task has given up the mutex, and not actually execute
    229          		past this call until the controlling task is suspended. */
    230          		if( xSemaphoreTakeRecursive( xMutex, portMAX_DELAY ) == pdPASS )
    231          		{
    232          			if( xControllingIsSuspended != pdTRUE )
    233          			{
    234          				/* Did not expect to execute until the controlling task was
    235          				suspended. */
    236          				xErrorOccurred = pdTRUE;
    237          			}
    238          			else
    239          			{
    240          				/* Give the mutex back before suspending ourselves to allow
    241          				the polling task to obtain the mutex. */
    242          				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
    243          				{
    244          					xErrorOccurred = pdTRUE;
    245          				}
    246          
    247          				xBlockingIsSuspended = pdTRUE;
    248          				vTaskSuspend( NULL );
    249          				xBlockingIsSuspended = pdFALSE;
    250          			}
    251          		}
    252          		else
    253          		{
    254          			/* We should not leave the xSemaphoreTakeRecursive() function
    255          			until the mutex was obtained. */
    256          			xErrorOccurred = pdTRUE;
   \                     ??prvRecursiveMutexBlockingTask_1:
   \   00000004   ....               LDR      R0,??DataTable4_9
   \   00000006   0121               MOVS     R1,#+1
   \   00000008   0160               STR      R1,[R0, #+0]
    257          		}
    258          
    259          		/* The controlling and blocking tasks should be in lock step. */
    260          		if( uxControllingCycles != ( uxBlockingCycles + 1 ) )
   \                     ??prvRecursiveMutexBlockingTask_2:
   \   0000000A   ....               LDR      R0,??DataTable4_10
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   ....               LDR      R1,??DataTable4_12
   \   00000010   0968               LDR      R1,[R1, #+0]
   \   00000012   491C               ADDS     R1,R1,#+1
   \   00000014   8842               CMP      R0,R1
   \   00000016   02D0               BEQ      ??prvRecursiveMutexBlockingTask_3
    261          		{
    262          			xErrorOccurred = pdTRUE;
   \   00000018   ....               LDR      R0,??DataTable4_9
   \   0000001A   0121               MOVS     R1,#+1
   \   0000001C   0160               STR      R1,[R0, #+0]
    263          		}
    264          
    265          		/* Keep count of the number of cycles this task has performed so a 
    266          		stall can be detected. */
    267          		uxBlockingCycles++;
   \                     ??prvRecursiveMutexBlockingTask_3:
   \   0000001E   ....               LDR      R0,??DataTable4_12
   \   00000020   0068               LDR      R0,[R0, #+0]
   \   00000022   401C               ADDS     R0,R0,#+1
   \   00000024   ....               LDR      R1,??DataTable4_12
   \   00000026   0860               STR      R0,[R1, #+0]
   \                     ??prvRecursiveMutexBlockingTask_0:
   \   00000028   0021               MOVS     R1,#+0
   \   0000002A   C943               MVNS     R1,R1            ;; #-1
   \   0000002C   ....               LDR      R0,??DataTable4
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   ........           BL       xQueueTakeMutexRecursive
   \   00000034   0128               CMP      R0,#+1
   \   00000036   E5D1               BNE      ??prvRecursiveMutexBlockingTask_1
   \   00000038   ....               LDR      R0,??DataTable4_11
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   0128               CMP      R0,#+1
   \   0000003E   03D0               BEQ      ??prvRecursiveMutexBlockingTask_4
   \   00000040   ....               LDR      R0,??DataTable4_9
   \   00000042   0121               MOVS     R1,#+1
   \   00000044   0160               STR      R1,[R0, #+0]
   \   00000046   E0E7               B        ??prvRecursiveMutexBlockingTask_2
   \                     ??prvRecursiveMutexBlockingTask_4:
   \   00000048   ....               LDR      R0,??DataTable4
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   ........           BL       xQueueGiveMutexRecursive
   \   00000050   0128               CMP      R0,#+1
   \   00000052   02D0               BEQ      ??prvRecursiveMutexBlockingTask_5
   \   00000054   ....               LDR      R0,??DataTable4_9
   \   00000056   0121               MOVS     R1,#+1
   \   00000058   0160               STR      R1,[R0, #+0]
   \                     ??prvRecursiveMutexBlockingTask_5:
   \   0000005A   ....               LDR      R0,??DataTable4_13
   \   0000005C   0121               MOVS     R1,#+1
   \   0000005E   0160               STR      R1,[R0, #+0]
   \   00000060   0020               MOVS     R0,#+0
   \   00000062   ........           BL       vTaskSuspend
   \   00000066   ....               LDR      R0,??DataTable4_13
   \   00000068   0021               MOVS     R1,#+0
   \   0000006A   0160               STR      R1,[R0, #+0]
   \   0000006C   CDE7               B        ??prvRecursiveMutexBlockingTask_2
    268          	}
    269          }
    270          /*-----------------------------------------------------------*/
    271          

   \                                 In section .text, align 2, keep-with-next
    272          static void prvRecursiveMutexPollingTask( void *pvParameters )
    273          {
   \                     prvRecursiveMutexPollingTask:
   \   00000000   80B5               PUSH     {R7,LR}
    274          	/* Just to remove compiler warning. */
    275          	( void ) pvParameters;
   \   00000002   02E0               B        ??prvRecursiveMutexPollingTask_0
    276          
    277          	for( ;; )
    278          	{
    279          		/* Keep attempting to obtain the mutex.  We should only obtain it when
    280          		the blocking task has suspended itself. */
    281          		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
    282          		{
    283          			/* Is the blocking task suspended? */
    284          			if( xBlockingIsSuspended != pdTRUE )
    285          			{
    286          				xErrorOccurred = pdTRUE;
   \                     ??prvRecursiveMutexPollingTask_1:
   \   00000004   ....               LDR      R0,??DataTable4_9
   \   00000006   0121               MOVS     R1,#+1
   \   00000008   0160               STR      R1,[R0, #+0]
    287          			}
   \                     ??prvRecursiveMutexPollingTask_0:
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   ....               LDR      R0,??DataTable4
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   ........           BL       xQueueTakeMutexRecursive
   \   00000014   0128               CMP      R0,#+1
   \   00000016   F8D1               BNE      ??prvRecursiveMutexPollingTask_0
   \   00000018   ....               LDR      R0,??DataTable4_13
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   0128               CMP      R0,#+1
   \   0000001E   F1D1               BNE      ??prvRecursiveMutexPollingTask_1
    288          			else
    289          			{
    290          				/* Keep count of the number of cycles this task has performed so 
    291          				a stall can be detected. */
    292          				uxPollingCycles++;
   \   00000020   ....               LDR      R0,??DataTable4_14
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   401C               ADDS     R0,R0,#+1
   \   00000026   ....               LDR      R1,??DataTable4_14
   \   00000028   0860               STR      R0,[R1, #+0]
    293          
    294          				/* We can resume the other tasks here even though they have a
    295          				higher priority than the polling task.  When they execute they
    296          				will attempt to obtain the mutex but fail because the polling
    297          				task is still the mutex holder.  The polling task (this task)
    298          				will then inherit the higher priority. */				
    299          				vTaskResume( xBlockingTaskHandle );
   \   0000002A   ....               LDR      R0,??DataTable4_4
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   ........           BL       vTaskResume
    300                          vTaskResume( xControllingTaskHandle );
   \   00000032   ....               LDR      R0,??DataTable4_1
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   ........           BL       vTaskResume
    301          			
    302          				/* Release the mutex, disinheriting the higher priority again. */
    303          				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
   \   0000003A   ....               LDR      R0,??DataTable4
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   ........           BL       xQueueGiveMutexRecursive
   \   00000042   0128               CMP      R0,#+1
   \   00000044   E1D0               BEQ      ??prvRecursiveMutexPollingTask_0
    304          				{
    305          					xErrorOccurred = pdTRUE;
   \   00000046   ....               LDR      R0,??DataTable4_9
   \   00000048   0121               MOVS     R1,#+1
   \   0000004A   0160               STR      R1,[R0, #+0]
   \   0000004C   DDE7               B        ??prvRecursiveMutexPollingTask_0
    306          				}
    307          			}
    308          		}
    309          
    310          		#if configUSE_PREEMPTION == 0
    311          		{
    312          			taskYIELD();
    313          		}
    314          		#endif
    315          	}
    316          }
    317          /*-----------------------------------------------------------*/
    318          
    319          /* This is called to check that all the created tasks are still running. */

   \                                 In section .text, align 2, keep-with-next
    320          portBASE_TYPE xAreRecursiveMutexTasksStillRunning( void )
    321          {
   \                     xAreRecursiveMutexTasksStillRunning:
   \   00000000   00B5               PUSH     {LR}
    322          portBASE_TYPE xReturn;
    323          static unsigned portBASE_TYPE uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;
    324          
    325          	/* Is the controlling task still cycling? */
    326          	if( uxLastControllingCycles == uxControllingCycles )
   \   00000002   ....               LDR      R0,??DataTable4_15
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   ....               LDR      R1,??DataTable4_10
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   8842               CMP      R0,R1
   \   0000000C   03D1               BNE      ??xAreRecursiveMutexTasksStillRunning_0
    327          	{
    328          		xErrorOccurred = pdTRUE;
   \   0000000E   ....               LDR      R0,??DataTable4_9
   \   00000010   0121               MOVS     R1,#+1
   \   00000012   0160               STR      R1,[R0, #+0]
   \   00000014   03E0               B        ??xAreRecursiveMutexTasksStillRunning_1
    329          	}
    330          	else
    331          	{
    332          		uxLastControllingCycles = uxControllingCycles;
   \                     ??xAreRecursiveMutexTasksStillRunning_0:
   \   00000016   ....               LDR      R0,??DataTable4_15
   \   00000018   ....               LDR      R1,??DataTable4_10
   \   0000001A   0968               LDR      R1,[R1, #+0]
   \   0000001C   0160               STR      R1,[R0, #+0]
    333          	}
    334          
    335          	/* Is the blocking task still cycling? */
    336          	if( uxLastBlockingCycles == uxBlockingCycles )
   \                     ??xAreRecursiveMutexTasksStillRunning_1:
   \   0000001E   ....               LDR      R0,??DataTable4_16
   \   00000020   0068               LDR      R0,[R0, #+0]
   \   00000022   ....               LDR      R1,??DataTable4_12
   \   00000024   0968               LDR      R1,[R1, #+0]
   \   00000026   8842               CMP      R0,R1
   \   00000028   03D1               BNE      ??xAreRecursiveMutexTasksStillRunning_2
    337          	{
    338          		xErrorOccurred = pdTRUE;
   \   0000002A   ....               LDR      R0,??DataTable4_9
   \   0000002C   0121               MOVS     R1,#+1
   \   0000002E   0160               STR      R1,[R0, #+0]
   \   00000030   03E0               B        ??xAreRecursiveMutexTasksStillRunning_3
    339          	}
    340          	else
    341          	{
    342          		uxLastBlockingCycles = uxBlockingCycles;
   \                     ??xAreRecursiveMutexTasksStillRunning_2:
   \   00000032   ....               LDR      R0,??DataTable4_16
   \   00000034   ....               LDR      R1,??DataTable4_12
   \   00000036   0968               LDR      R1,[R1, #+0]
   \   00000038   0160               STR      R1,[R0, #+0]
    343          	}
    344          
    345          	/* Is the polling task still cycling? */
    346          	if( uxLastPollingCycles == uxPollingCycles )
   \                     ??xAreRecursiveMutexTasksStillRunning_3:
   \   0000003A   ....               LDR      R0,??DataTable4_17
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   ....               LDR      R1,??DataTable4_14
   \   00000040   0968               LDR      R1,[R1, #+0]
   \   00000042   8842               CMP      R0,R1
   \   00000044   03D1               BNE      ??xAreRecursiveMutexTasksStillRunning_4
    347          	{
    348          		xErrorOccurred = pdTRUE;
   \   00000046   ....               LDR      R0,??DataTable4_9
   \   00000048   0121               MOVS     R1,#+1
   \   0000004A   0160               STR      R1,[R0, #+0]
   \   0000004C   03E0               B        ??xAreRecursiveMutexTasksStillRunning_5
    349          	}
    350          	else
    351          	{
    352          		uxLastPollingCycles = uxPollingCycles;
   \                     ??xAreRecursiveMutexTasksStillRunning_4:
   \   0000004E   ....               LDR      R0,??DataTable4_17
   \   00000050   ....               LDR      R1,??DataTable4_14
   \   00000052   0968               LDR      R1,[R1, #+0]
   \   00000054   0160               STR      R1,[R0, #+0]
    353          	}
    354          
    355          	if( xErrorOccurred == pdTRUE )
   \                     ??xAreRecursiveMutexTasksStillRunning_5:
   \   00000056   ....               LDR      R0,??DataTable4_9
   \   00000058   0068               LDR      R0,[R0, #+0]
   \   0000005A   0128               CMP      R0,#+1
   \   0000005C   01D1               BNE      ??xAreRecursiveMutexTasksStillRunning_6
    356          	{
    357          		xReturn = pdFAIL;
   \   0000005E   0020               MOVS     R0,#+0
   \   00000060   00E0               B        ??xAreRecursiveMutexTasksStillRunning_7
    358          	}
    359          	else
    360          	{
    361          		xReturn = pdTRUE;
   \                     ??xAreRecursiveMutexTasksStillRunning_6:
   \   00000062   0120               MOVS     R0,#+1
    362          	}
    363          
    364          	return xReturn;
   \                     ??xAreRecursiveMutexTasksStillRunning_7:
   \   00000064   00BD               POP      {PC}             ;; return
    365          }

   \                                 In section .bss, align 4
   \                     ??uxLastControllingCycles:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ??uxLastBlockingCycles:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ??uxLastPollingCycles:
   \   00000000                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     xMutex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     xControllingTaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     `?<Constant "Rec1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   ........           DC32     prvRecursiveMutexControllingTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     xBlockingTaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   ........           DC32     `?<Constant "Rec2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   ........           DC32     prvRecursiveMutexBlockingTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   ........           DC32     `?<Constant "Rec3">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   ........           DC32     prvRecursiveMutexPollingTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   ........           DC32     xErrorOccurred

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   ........           DC32     uxControllingCycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   ........           DC32     xControllingIsSuspended

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   ........           DC32     uxBlockingCycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   ........           DC32     xBlockingIsSuspended

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   ........           DC32     uxPollingCycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   ........           DC32     ??uxLastControllingCycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   ........           DC32     ??uxLastBlockingCycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   ........           DC32     ??uxLastPollingCycles

   \                                 In section .rodata, align 4
   \                     `?<Constant "Rec1">`:
   \   00000000   5265633100         DC8 "Rec1"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Rec2">`:
   \   00000000   5265633200         DC8 "Rec2"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Rec3">`:
   \   00000000   5265633300         DC8 "Rec3"
   \   00000005   000000             DC8 0, 0, 0
    366          
    367          
    368          
    369          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     prvRecursiveMutexBlockingTask       8
     prvRecursiveMutexControllingTask
                                         8
     prvRecursiveMutexPollingTask        8
     vStartRecursiveMutexTasks          24
     xAreRecursiveMutexTasksStillRunning
                                         4


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     xMutex                            4
     xErrorOccurred                    4
     xControllingIsSuspended           4
     xBlockingIsSuspended              4
     uxControllingCycles               4
     uxBlockingCycles                  4
     uxPollingCycles                   4
     xControllingTaskHandle            4
     xBlockingTaskHandle               4
     vStartRecursiveMutexTasks       108
     prvRecursiveMutexControllingTask
                                     138
     prvRecursiveMutexBlockingTask   110
     prvRecursiveMutexPollingTask     78
     xAreRecursiveMutexTasksStillRunning
                                     102
     uxLastControllingCycles           4
     uxLastBlockingCycles              4
     uxLastPollingCycles               4
     ??DataTable4                      4
     ??DataTable4_1                    4
     ??DataTable4_2                    4
     ??DataTable4_3                    4
     ??DataTable4_4                    4
     ??DataTable4_5                    4
     ??DataTable4_6                    4
     ??DataTable4_7                    4
     ??DataTable4_8                    4
     ??DataTable4_9                    4
     ??DataTable4_10                   4
     ??DataTable4_11                   4
     ??DataTable4_12                   4
     ??DataTable4_13                   4
     ??DataTable4_14                   4
     ??DataTable4_15                   4
     ??DataTable4_16                   4
     ??DataTable4_17                   4
     ?<Constant "Rec1">                8
     ?<Constant "Rec2">                8
     ?<Constant "Rec3">                8

 
  48 bytes in section .bss
  24 bytes in section .rodata
 608 bytes in section .text
 
 608 bytes of CODE  memory
  24 bytes of CONST memory
  48 bytes of DATA  memory

Errors: none
Warnings: none
