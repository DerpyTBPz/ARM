###############################################################################
#                                                                             #
#                                                       06/Jul/2010  14:34:52 #
# IAR ANSI C/C++ Compiler V5.50.0.21878/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\QPeek. #
#                    c                                                        #
#    Command line =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\QPeek. #
#                    c -D IAR_ARM_CM0 -lCN E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo #
#                    \CORTEX_NUC1xx_Keil_IAR\Debug\List\ --diag_suppress      #
#                    Pe550,Pa082,Pa039 -o E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\ #
#                    CORTEX_NUC1xx_Keil_IAR\Debug\Obj\ --no_cse --no_unroll   #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M0  #
#                    -e --fpu=None --dlib_config "D:\Program                  #
#                    Files\ARM\INC\DLib_Config_Full.h" -I                     #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\..\common\include\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\De #
#                    mo\CORTEX_NUC1xx_Keil_IAR\..\..\source\include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_K #
#                    eil_IAR\NUC1xxBSP\NuvotonPlatform_Keil\Include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\NuvotonPlatform_Keil\Include\Driver\ -I      #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\CMSIS\CM0\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\ #
#                    Demo\CORTEX_NUC1xx_Keil_IAR\User_Demo\include\ -I        #
#                    "D:\Program Files\ARM\INC\" -Ol                          #
#    List file    =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\List\QPeek.lst                                   #
#    Object file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\Obj\QPeek.o                                      #
#                                                                             #
#                                                                             #
###############################################################################

E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\Common\Minimal\QPeek.c
      1          /*
      2              FreeRTOS V6.0.5 - Copyright (C) 2010 Real Time Engineers Ltd.
      3          
      4              ***************************************************************************
      5              *                                                                         *
      6              * If you are:                                                             *
      7              *                                                                         *
      8              *    + New to FreeRTOS,                                                   *
      9              *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
     10              *    + Looking for basic training,                                        *
     11              *    + Wanting to improve your FreeRTOS skills and productivity           *
     12              *                                                                         *
     13              * then take a look at the FreeRTOS eBook                                  *
     14              *                                                                         *
     15              *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
     16              *                  http://www.FreeRTOS.org/Documentation                  *
     17              *                                                                         *
     18              * A pdf reference manual is also available.  Both are usually delivered   *
     19              * to your inbox within 20 minutes to two hours when purchased between 8am *
     20              * and 8pm GMT (although please allow up to 24 hours in case of            *
     21              * exceptional circumstances).  Thank you for your support!                *
     22              *                                                                         *
     23              ***************************************************************************
     24          
     25              This file is part of the FreeRTOS distribution.
     26          
     27              FreeRTOS is free software; you can redistribute it and/or modify it under
     28              the terms of the GNU General Public License (version 2) as published by the
     29              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     30              ***NOTE*** The exception to the GPL is included to allow you to distribute
     31              a combined work that includes FreeRTOS without being obliged to provide the
     32              source code for proprietary components outside of the FreeRTOS kernel.
     33              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
     34              ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     35              FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     36              more details. You should have received a copy of the GNU General Public 
     37              License and the FreeRTOS license exception along with FreeRTOS; if not it 
     38              can be viewed here: http://www.freertos.org/a00114.html and also obtained 
     39              by writing to Richard Barry, contact details for whom are available on the
     40              FreeRTOS WEB site.
     41          
     42              1 tab == 4 spaces!
     43          
     44              http://www.FreeRTOS.org - Documentation, latest information, license and
     45              contact details.
     46          
     47              http://www.SafeRTOS.com - A version that is certified for use in safety
     48              critical systems.
     49          
     50              http://www.OpenRTOS.com - Commercial support, development, porting,
     51              licensing and training services.
     52          */
     53          
     54          
     55          /* 
     56           * Tests the behaviour when data is peeked from a queue when there are
     57           * multiple tasks blocked on the queue.
     58           */
     59          
     60          
     61          #include <stdlib.h>
     62          
     63          /* Scheduler include files. */
     64          #include "FreeRTOS.h"
     65          #include "task.h"
     66          #include "queue.h"
     67          #include "semphr.h"
     68          
     69          /* Demo program include files. */
     70          #include "QPeek.h"
     71          
     72          #define qpeekQUEUE_LENGTH		( 5 )
     73          #define qpeekNO_BLOCK			( 0 )
     74          #define qpeekSHORT_DELAY		( 10 )
     75          
     76          #define qpeekLOW_PRIORITY			( tskIDLE_PRIORITY + 0 )
     77          #define qpeekMEDIUM_PRIORITY		( tskIDLE_PRIORITY + 1 )
     78          #define qpeekHIGH_PRIORITY			( tskIDLE_PRIORITY + 2 )
     79          #define qpeekHIGHEST_PRIORITY		( tskIDLE_PRIORITY + 3 )
     80          
     81          /*-----------------------------------------------------------*/
     82          
     83          /*
     84           * The following three tasks are used to demonstrate the peeking behaviour.
     85           * Each task is given a different priority to demonstrate the order in which
     86           * tasks are woken as data is peeked from a queue.
     87           */
     88          static void prvLowPriorityPeekTask( void *pvParameters );
     89          static void prvMediumPriorityPeekTask( void *pvParameters );
     90          static void prvHighPriorityPeekTask( void *pvParameters );
     91          static void prvHighestPriorityPeekTask( void *pvParameters );
     92          
     93          /*-----------------------------------------------------------*/
     94          
     95          /* Flag that will be latched to pdTRUE should any unexpected behaviour be
     96          detected in any of the tasks. */

   \                                 In section .bss, align 4
     97          static volatile portBASE_TYPE xErrorDetected = pdFALSE;
   \                     xErrorDetected:
   \   00000000                      DS8 4
     98          
     99          /* Counter that is incremented on each cycle of a test.  This is used to
    100          detect a stalled task - a test that is no longer running. */

   \                                 In section .bss, align 4
    101          static volatile unsigned portLONG ulLoopCounter = 0;
   \                     ulLoopCounter:
   \   00000000                      DS8 4
    102          
    103          /* Handles to the test tasks. */

   \                                 In section .bss, align 4
    104          xTaskHandle xMediumPriorityTask, xHighPriorityTask, xHighestPriorityTask;
   \                     xMediumPriorityTask:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     xHighPriorityTask:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     xHighestPriorityTask:
   \   00000000                      DS8 4
    105          /*-----------------------------------------------------------*/
    106          

   \                                 In section .text, align 2, keep-with-next
    107          void vStartQueuePeekTasks( void )
    108          {
   \                     vStartQueuePeekTasks:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
    109          xQueueHandle xQueue;
    110          
    111          	/* Create the queue that we are going to use for the test/demo. */
    112          	xQueue = xQueueCreate( qpeekQUEUE_LENGTH, sizeof( unsigned portLONG ) );
   \   00000002   0421               MOVS     R1,#+4
   \   00000004   0520               MOVS     R0,#+5
   \   00000006   ........           BL       xQueueCreate
   \   0000000A   0400               MOVS     R4,R0
    113          
    114          	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
    115          	in use.  The queue registry is provided as a means for kernel aware 
    116          	debuggers to locate queues and has no purpose if a kernel aware debugger
    117          	is not being used.  The call to vQueueAddToRegistry() will be removed
    118          	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
    119          	defined to be less than 1. */
    120          	vQueueAddToRegistry( xQueue, ( signed portCHAR * ) "QPeek_Test_Queue" );
    121          
    122          	/* Create the demo tasks and pass it the queue just created.  We are
    123          	passing the queue handle by value so it does not matter that it is declared
    124          	on the stack here. */
    125          	xTaskCreate( prvLowPriorityPeekTask, ( signed portCHAR * )"PeekL", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekLOW_PRIORITY, NULL );
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   0390               STR      R0,[SP, #+12]
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   0290               STR      R0,[SP, #+8]
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   0190               STR      R0,[SP, #+4]
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   0090               STR      R0,[SP, #+0]
   \   0000001C   2300               MOVS     R3,R4
   \   0000001E   8022               MOVS     R2,#+128
   \   00000020   ....               LDR      R1,??DataTable3
   \   00000022   ....               LDR      R0,??DataTable3_1
   \   00000024   ........           BL       xTaskGenericCreate
    126          	xTaskCreate( prvMediumPriorityPeekTask, ( signed portCHAR * )"PeekM", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekMEDIUM_PRIORITY, &xMediumPriorityTask );
   \   00000028   0020               MOVS     R0,#+0
   \   0000002A   0390               STR      R0,[SP, #+12]
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   0290               STR      R0,[SP, #+8]
   \   00000030   ....               LDR      R0,??DataTable3_2
   \   00000032   0190               STR      R0,[SP, #+4]
   \   00000034   0120               MOVS     R0,#+1
   \   00000036   0090               STR      R0,[SP, #+0]
   \   00000038   2300               MOVS     R3,R4
   \   0000003A   8022               MOVS     R2,#+128
   \   0000003C   ....               LDR      R1,??DataTable3_3
   \   0000003E   ....               LDR      R0,??DataTable3_4
   \   00000040   ........           BL       xTaskGenericCreate
    127          	xTaskCreate( prvHighPriorityPeekTask, ( signed portCHAR * )"PeekH1", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGH_PRIORITY, &xHighPriorityTask );
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   0390               STR      R0,[SP, #+12]
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   0290               STR      R0,[SP, #+8]
   \   0000004C   ....               LDR      R0,??DataTable4
   \   0000004E   0190               STR      R0,[SP, #+4]
   \   00000050   0220               MOVS     R0,#+2
   \   00000052   0090               STR      R0,[SP, #+0]
   \   00000054   2300               MOVS     R3,R4
   \   00000056   8022               MOVS     R2,#+128
   \   00000058   ....               LDR      R1,??DataTable4_1
   \   0000005A   ....               LDR      R0,??DataTable4_2
   \   0000005C   ........           BL       xTaskGenericCreate
    128          	xTaskCreate( prvHighestPriorityPeekTask, ( signed portCHAR * )"PeekH2", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGHEST_PRIORITY, &xHighestPriorityTask );
   \   00000060   0020               MOVS     R0,#+0
   \   00000062   0390               STR      R0,[SP, #+12]
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   0290               STR      R0,[SP, #+8]
   \   00000068   ....               LDR      R0,??DataTable4_3
   \   0000006A   0190               STR      R0,[SP, #+4]
   \   0000006C   0320               MOVS     R0,#+3
   \   0000006E   0090               STR      R0,[SP, #+0]
   \   00000070   2300               MOVS     R3,R4
   \   00000072   8022               MOVS     R2,#+128
   \   00000074   ....               LDR      R1,??DataTable4_4
   \   00000076   ....               LDR      R0,??DataTable5
   \   00000078   ........           BL       xTaskGenericCreate
    129          }
   \   0000007C   1FBD               POP      {R0-R4,PC}       ;; return
    130          /*-----------------------------------------------------------*/
    131          

   \                                 In section .text, align 2, keep-with-next
    132          static void prvHighestPriorityPeekTask( void *pvParameters )
    133          {
   \                     prvHighestPriorityPeekTask:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    134          xQueueHandle xQueue = ( xQueueHandle ) pvParameters;
   \   00000004   0400               MOVS     R4,R0
    135          unsigned portLONG ulValue;
    136          
    137          	#ifdef USE_STDIO
    138          	{
    139          		void vPrintDisplayMessage( const portCHAR * const * ppcMessageToSend );
    140          	
    141          		const portCHAR * const pcTaskStartMsg = "Queue peek test started.\r\n";
    142          
    143          		/* Queue a message for printing to say the task has started. */
    144          		vPrintDisplayMessage( &pcTaskStartMsg );
    145          	}
    146          	#endif
    147          
    148          	for( ;; )
    149          	{
    150          		/* Try peeking from the queue.  The queue should be empty so we will
    151          		block, allowing the high priority task to execute. */
    152          		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
   \                     ??prvHighestPriorityPeekTask_0:
   \   00000006   0123               MOVS     R3,#+1
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   D243               MVNS     R2,R2            ;; #-1
   \   0000000C   6946               MOV      R1,SP
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       xQueueGenericReceive
   \   00000014   0128               CMP      R0,#+1
   \   00000016   02D0               BEQ      ??prvHighestPriorityPeekTask_1
    153          		{
    154          			/* We expected to have received something by the time we unblock. */
    155          			xErrorDetected = pdTRUE;
   \   00000018   ....               LDR      R0,??DataTable5_1
   \   0000001A   0121               MOVS     R1,#+1
   \   0000001C   0160               STR      R1,[R0, #+0]
    156          		}
    157          
    158          		/* When we reach here the high and medium priority tasks should still
    159          		be blocked on the queue.  We unblocked because the low priority task
    160          		wrote a value to the queue, which we should have peeked.  Peeking the
    161          		data (rather than receiving it) will leave the data on the queue, so
    162          		the high priority task should then have also been unblocked, but not
    163          		yet executed. */
    164          		if( ulValue != 0x11223344 )
   \                     ??prvHighestPriorityPeekTask_1:
   \   0000001E   0098               LDR      R0,[SP, #+0]
   \   00000020   ....               LDR      R1,??DataTable5_2  ;; 0x11223344
   \   00000022   8842               CMP      R0,R1
   \   00000024   02D0               BEQ      ??prvHighestPriorityPeekTask_2
    165          		{
    166          			/* We did not receive the expected value. */
    167          			xErrorDetected = pdTRUE;
   \   00000026   ....               LDR      R0,??DataTable5_1
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   0160               STR      R1,[R0, #+0]
    168          		}
    169          
    170          		if( uxQueueMessagesWaiting( xQueue ) != 1 )
   \                     ??prvHighestPriorityPeekTask_2:
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       uxQueueMessagesWaiting
   \   00000032   0128               CMP      R0,#+1
   \   00000034   02D0               BEQ      ??prvHighestPriorityPeekTask_3
    171          		{
    172          			/* The message should have been left on the queue. */
    173          			xErrorDetected = pdTRUE;
   \   00000036   ....               LDR      R0,??DataTable5_1
   \   00000038   0121               MOVS     R1,#+1
   \   0000003A   0160               STR      R1,[R0, #+0]
    174          		}
    175          
    176          		/* Now we are going to actually receive the data, so when the high
    177          		priority task runs it will find the queue empty and return to the
    178          		blocked state. */
    179          		ulValue = 0;
   \                     ??prvHighestPriorityPeekTask_3:
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   0090               STR      R0,[SP, #+0]
    180          		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
   \   00000040   0023               MOVS     R3,#+0
   \   00000042   0022               MOVS     R2,#+0
   \   00000044   6946               MOV      R1,SP
   \   00000046   2000               MOVS     R0,R4
   \   00000048   ........           BL       xQueueGenericReceive
   \   0000004C   0128               CMP      R0,#+1
   \   0000004E   02D0               BEQ      ??prvHighestPriorityPeekTask_4
    181          		{
    182          			/* We expected to receive the value. */
    183          			xErrorDetected = pdTRUE;
   \   00000050   ....               LDR      R0,??DataTable5_1
   \   00000052   0121               MOVS     R1,#+1
   \   00000054   0160               STR      R1,[R0, #+0]
    184          		}
    185          
    186          		if( ulValue != 0x11223344 )
   \                     ??prvHighestPriorityPeekTask_4:
   \   00000056   0098               LDR      R0,[SP, #+0]
   \   00000058   ....               LDR      R1,??DataTable5_2  ;; 0x11223344
   \   0000005A   8842               CMP      R0,R1
   \   0000005C   02D0               BEQ      ??prvHighestPriorityPeekTask_5
    187          		{
    188          			/* We did not receive the expected value - which should have been
    189          			the same value as was peeked. */
    190          			xErrorDetected = pdTRUE;
   \   0000005E   ....               LDR      R0,??DataTable5_1
   \   00000060   0121               MOVS     R1,#+1
   \   00000062   0160               STR      R1,[R0, #+0]
    191          		}
    192          
    193          		/* Now we will block again as the queue is once more empty.  The low 
    194          		priority task can then execute again. */
    195          		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
   \                     ??prvHighestPriorityPeekTask_5:
   \   00000064   0123               MOVS     R3,#+1
   \   00000066   0022               MOVS     R2,#+0
   \   00000068   D243               MVNS     R2,R2            ;; #-1
   \   0000006A   6946               MOV      R1,SP
   \   0000006C   2000               MOVS     R0,R4
   \   0000006E   ........           BL       xQueueGenericReceive
   \   00000072   0128               CMP      R0,#+1
   \   00000074   02D0               BEQ      ??prvHighestPriorityPeekTask_6
    196          		{
    197          			/* We expected to have received something by the time we unblock. */
    198          			xErrorDetected = pdTRUE;
   \   00000076   ....               LDR      R0,??DataTable5_1
   \   00000078   0121               MOVS     R1,#+1
   \   0000007A   0160               STR      R1,[R0, #+0]
    199          		}
    200          
    201          		/* When we get here the low priority task should have again written to the
    202          		queue. */
    203          		if( ulValue != 0x01234567 )
   \                     ??prvHighestPriorityPeekTask_6:
   \   0000007C   0098               LDR      R0,[SP, #+0]
   \   0000007E   ....               LDR      R1,??DataTable5_3  ;; 0x1234567
   \   00000080   8842               CMP      R0,R1
   \   00000082   02D0               BEQ      ??prvHighestPriorityPeekTask_7
    204          		{
    205          			/* We did not receive the expected value. */
    206          			xErrorDetected = pdTRUE;
   \   00000084   ....               LDR      R0,??DataTable5_1
   \   00000086   0121               MOVS     R1,#+1
   \   00000088   0160               STR      R1,[R0, #+0]
    207          		}
    208          
    209          		if( uxQueueMessagesWaiting( xQueue ) != 1 )
   \                     ??prvHighestPriorityPeekTask_7:
   \   0000008A   2000               MOVS     R0,R4
   \   0000008C   ........           BL       uxQueueMessagesWaiting
   \   00000090   0128               CMP      R0,#+1
   \   00000092   02D0               BEQ      ??prvHighestPriorityPeekTask_8
    210          		{
    211          			/* The message should have been left on the queue. */
    212          			xErrorDetected = pdTRUE;
   \   00000094   ....               LDR      R0,??DataTable5_1
   \   00000096   0121               MOVS     R1,#+1
   \   00000098   0160               STR      R1,[R0, #+0]
    213          		}
    214          
    215          		/* We only peeked the data, so suspending ourselves now should enable
    216          		the high priority task to also peek the data.  The high priority task
    217          		will have been unblocked when we peeked the data as we left the data
    218          		in the queue. */
    219          		vTaskSuspend( NULL );
   \                     ??prvHighestPriorityPeekTask_8:
   \   0000009A   0020               MOVS     R0,#+0
   \   0000009C   ........           BL       vTaskSuspend
    220          
    221          
    222          
    223          		/* This time we are going to do the same as the above test, but the
    224          		high priority task is going to receive the data, rather than peek it.
    225          		This means that the medium priority task should never peek the value. */
    226          		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
   \   000000A0   0123               MOVS     R3,#+1
   \   000000A2   0022               MOVS     R2,#+0
   \   000000A4   D243               MVNS     R2,R2            ;; #-1
   \   000000A6   6946               MOV      R1,SP
   \   000000A8   2000               MOVS     R0,R4
   \   000000AA   ........           BL       xQueueGenericReceive
   \   000000AE   0128               CMP      R0,#+1
   \   000000B0   02D0               BEQ      ??prvHighestPriorityPeekTask_9
    227          		{
    228          			xErrorDetected = pdTRUE;
   \   000000B2   ....               LDR      R0,??DataTable5_1
   \   000000B4   0121               MOVS     R1,#+1
   \   000000B6   0160               STR      R1,[R0, #+0]
    229          		}
    230          
    231          		if( ulValue != 0xaabbaabb )
   \                     ??prvHighestPriorityPeekTask_9:
   \   000000B8   0098               LDR      R0,[SP, #+0]
   \   000000BA   ....               LDR      R1,??DataTable5_4  ;; 0xaabbaabb
   \   000000BC   8842               CMP      R0,R1
   \   000000BE   02D0               BEQ      ??prvHighestPriorityPeekTask_10
    232          		{
    233          			xErrorDetected = pdTRUE;
   \   000000C0   ....               LDR      R0,??DataTable5_1
   \   000000C2   0121               MOVS     R1,#+1
   \   000000C4   0160               STR      R1,[R0, #+0]
    234          		}
    235          
    236          		vTaskSuspend( NULL );		
   \                     ??prvHighestPriorityPeekTask_10:
   \   000000C6   0020               MOVS     R0,#+0
   \   000000C8   ........           BL       vTaskSuspend
   \   000000CC   9BE7               B        ??prvHighestPriorityPeekTask_0
    237          	}
    238          }
    239          /*-----------------------------------------------------------*/
    240          

   \                                 In section .text, align 2, keep-with-next
    241          static void prvHighPriorityPeekTask( void *pvParameters )
    242          {
   \                     prvHighPriorityPeekTask:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    243          xQueueHandle xQueue = ( xQueueHandle ) pvParameters;
   \   00000004   0400               MOVS     R4,R0
    244          unsigned portLONG ulValue;
    245          
    246          	for( ;; )
    247          	{
    248          		/* Try peeking from the queue.  The queue should be empty so we will
    249          		block, allowing the medium priority task to execute.  Both the high
    250          		and highest priority tasks will then be blocked on the queue. */
    251          		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
   \                     ??prvHighPriorityPeekTask_0:
   \   00000006   0123               MOVS     R3,#+1
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   D243               MVNS     R2,R2            ;; #-1
   \   0000000C   6946               MOV      R1,SP
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       xQueueGenericReceive
   \   00000014   0128               CMP      R0,#+1
   \   00000016   02D0               BEQ      ??prvHighPriorityPeekTask_1
    252          		{
    253          			/* We expected to have received something by the time we unblock. */
    254          			xErrorDetected = pdTRUE;
   \   00000018   ....               LDR      R0,??DataTable5_1
   \   0000001A   0121               MOVS     R1,#+1
   \   0000001C   0160               STR      R1,[R0, #+0]
    255          		}
    256          
    257          		/* When we get here the highest priority task should have peeked the data
    258          		(unblocking this task) then suspended (allowing this task to also peek
    259          		the data). */
    260          		if( ulValue != 0x01234567 )
   \                     ??prvHighPriorityPeekTask_1:
   \   0000001E   0098               LDR      R0,[SP, #+0]
   \   00000020   ....               LDR      R1,??DataTable5_3  ;; 0x1234567
   \   00000022   8842               CMP      R0,R1
   \   00000024   02D0               BEQ      ??prvHighPriorityPeekTask_2
    261          		{
    262          			/* We did not receive the expected value. */
    263          			xErrorDetected = pdTRUE;
   \   00000026   ....               LDR      R0,??DataTable5_1
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   0160               STR      R1,[R0, #+0]
    264          		}
    265          
    266          		if( uxQueueMessagesWaiting( xQueue ) != 1 )
   \                     ??prvHighPriorityPeekTask_2:
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       uxQueueMessagesWaiting
   \   00000032   0128               CMP      R0,#+1
   \   00000034   02D0               BEQ      ??prvHighPriorityPeekTask_3
    267          		{
    268          			/* The message should have been left on the queue. */
    269          			xErrorDetected = pdTRUE;
   \   00000036   ....               LDR      R0,??DataTable5_1
   \   00000038   0121               MOVS     R1,#+1
   \   0000003A   0160               STR      R1,[R0, #+0]
    270          		}
    271          
    272          		/* We only peeked the data, so suspending ourselves now should enable
    273          		the medium priority task to also peek the data.  The medium priority task
    274          		will have been unblocked when we peeked the data as we left the data
    275          		in the queue. */
    276          		vTaskSuspend( NULL );
   \                     ??prvHighPriorityPeekTask_3:
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   ........           BL       vTaskSuspend
    277          
    278          
    279          		/* This time we are going actually receive the value, so the medium
    280          		priority task will never peek the data - we removed it from the queue. */
    281          		if( xQueueReceive( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
   \   00000042   0023               MOVS     R3,#+0
   \   00000044   0022               MOVS     R2,#+0
   \   00000046   D243               MVNS     R2,R2            ;; #-1
   \   00000048   6946               MOV      R1,SP
   \   0000004A   2000               MOVS     R0,R4
   \   0000004C   ........           BL       xQueueGenericReceive
   \   00000050   0128               CMP      R0,#+1
   \   00000052   02D0               BEQ      ??prvHighPriorityPeekTask_4
    282          		{
    283          			xErrorDetected = pdTRUE;
   \   00000054   ....               LDR      R0,??DataTable5_1
   \   00000056   0121               MOVS     R1,#+1
   \   00000058   0160               STR      R1,[R0, #+0]
    284          		}
    285          
    286          		if( ulValue != 0xaabbaabb )
   \                     ??prvHighPriorityPeekTask_4:
   \   0000005A   0098               LDR      R0,[SP, #+0]
   \   0000005C   ....               LDR      R1,??DataTable5_4  ;; 0xaabbaabb
   \   0000005E   8842               CMP      R0,R1
   \   00000060   02D0               BEQ      ??prvHighPriorityPeekTask_5
    287          		{
    288          			xErrorDetected = pdTRUE;
   \   00000062   ....               LDR      R0,??DataTable5_1
   \   00000064   0121               MOVS     R1,#+1
   \   00000066   0160               STR      R1,[R0, #+0]
    289          		}
    290          
    291          		vTaskSuspend( NULL );				
   \                     ??prvHighPriorityPeekTask_5:
   \   00000068   0020               MOVS     R0,#+0
   \   0000006A   ........           BL       vTaskSuspend
   \   0000006E   CAE7               B        ??prvHighPriorityPeekTask_0
    292          	}
    293          }
    294          /*-----------------------------------------------------------*/
    295          

   \                                 In section .text, align 2, keep-with-next
    296          static void prvMediumPriorityPeekTask( void *pvParameters )
    297          {
   \                     prvMediumPriorityPeekTask:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    298          xQueueHandle xQueue = ( xQueueHandle ) pvParameters;
   \   00000004   0400               MOVS     R4,R0
    299          unsigned portLONG ulValue;
    300          
    301          	for( ;; )
    302          	{
    303          		/* Try peeking from the queue.  The queue should be empty so we will
    304          		block, allowing the low priority task to execute.  The highest, high
    305          		and medium priority tasks will then all be blocked on the queue. */
    306          		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
   \                     ??prvMediumPriorityPeekTask_0:
   \   00000006   0123               MOVS     R3,#+1
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   D243               MVNS     R2,R2            ;; #-1
   \   0000000C   6946               MOV      R1,SP
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       xQueueGenericReceive
   \   00000014   0128               CMP      R0,#+1
   \   00000016   02D0               BEQ      ??prvMediumPriorityPeekTask_1
    307          		{
    308          			/* We expected to have received something by the time we unblock. */
    309          			xErrorDetected = pdTRUE;
   \   00000018   ....               LDR      R0,??DataTable5_1
   \   0000001A   0121               MOVS     R1,#+1
   \   0000001C   0160               STR      R1,[R0, #+0]
    310          		}
    311          
    312          		/* When we get here the high priority task should have peeked the data
    313          		(unblocking this task) then suspended (allowing this task to also peek
    314          		the data). */
    315          		if( ulValue != 0x01234567 )
   \                     ??prvMediumPriorityPeekTask_1:
   \   0000001E   0098               LDR      R0,[SP, #+0]
   \   00000020   ....               LDR      R1,??DataTable5_3  ;; 0x1234567
   \   00000022   8842               CMP      R0,R1
   \   00000024   02D0               BEQ      ??prvMediumPriorityPeekTask_2
    316          		{
    317          			/* We did not receive the expected value. */
    318          			xErrorDetected = pdTRUE;
   \   00000026   ....               LDR      R0,??DataTable5_1
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   0160               STR      R1,[R0, #+0]
    319          		}
    320          
    321          		if( uxQueueMessagesWaiting( xQueue ) != 1 )
   \                     ??prvMediumPriorityPeekTask_2:
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       uxQueueMessagesWaiting
   \   00000032   0128               CMP      R0,#+1
   \   00000034   02D0               BEQ      ??prvMediumPriorityPeekTask_3
    322          		{
    323          			/* The message should have been left on the queue. */
    324          			xErrorDetected = pdTRUE;
   \   00000036   ....               LDR      R0,??DataTable5_1
   \   00000038   0121               MOVS     R1,#+1
   \   0000003A   0160               STR      R1,[R0, #+0]
    325          		}
    326          
    327          		/* Just so we know the test is still running. */
    328          		ulLoopCounter++;
   \                     ??prvMediumPriorityPeekTask_3:
   \   0000003C   ....               LDR      R0,??DataTable5_5
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   401C               ADDS     R0,R0,#+1
   \   00000042   ....               LDR      R1,??DataTable5_5
   \   00000044   0860               STR      R0,[R1, #+0]
    329          
    330          		/* Now we can suspend ourselves so the low priority task can execute
    331          		again. */
    332          		vTaskSuspend( NULL );
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   ........           BL       vTaskSuspend
   \   0000004C   DBE7               B        ??prvMediumPriorityPeekTask_0
    333          	}
    334          }
    335          /*-----------------------------------------------------------*/
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static void prvLowPriorityPeekTask( void *pvParameters )
    338          {
   \                     prvLowPriorityPeekTask:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    339          xQueueHandle xQueue = ( xQueueHandle ) pvParameters;
   \   00000004   0400               MOVS     R4,R0
    340          unsigned portLONG ulValue;
    341          
    342          	for( ;; )
    343          	{
    344          		/* Write some data to the queue.  This should unblock the highest 
    345          		priority task that is waiting to peek data from the queue. */
    346          		ulValue = 0x11223344;
   \                     ??prvLowPriorityPeekTask_0:
   \   00000006   ....               LDR      R0,??DataTable5_2  ;; 0x11223344
   \   00000008   0090               STR      R0,[SP, #+0]
    347          		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
   \   0000000A   0023               MOVS     R3,#+0
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   6946               MOV      R1,SP
   \   00000010   2000               MOVS     R0,R4
   \   00000012   ........           BL       xQueueGenericSend
   \   00000016   0128               CMP      R0,#+1
   \   00000018   02D0               BEQ      ??prvLowPriorityPeekTask_1
    348          		{
    349          			/* We were expecting the queue to be empty so we should not of
    350          			had a problem writing to the queue. */
    351          			xErrorDetected = pdTRUE;
   \   0000001A   ....               LDR      R0,??DataTable5_1
   \   0000001C   0121               MOVS     R1,#+1
   \   0000001E   0160               STR      R1,[R0, #+0]
    352          		}
    353          
    354          		/* By the time we get here the data should have been removed from
    355          		the queue. */
    356          		if( uxQueueMessagesWaiting( xQueue ) != 0 )
   \                     ??prvLowPriorityPeekTask_1:
   \   00000020   2000               MOVS     R0,R4
   \   00000022   ........           BL       uxQueueMessagesWaiting
   \   00000026   0028               CMP      R0,#+0
   \   00000028   02D0               BEQ      ??prvLowPriorityPeekTask_2
    357          		{
    358          			xErrorDetected = pdTRUE;
   \   0000002A   ....               LDR      R0,??DataTable5_1
   \   0000002C   0121               MOVS     R1,#+1
   \   0000002E   0160               STR      R1,[R0, #+0]
    359          		}
    360          
    361          		/* Write another value to the queue, again waking the highest priority
    362          		task that is blocked on the queue. */
    363          		ulValue = 0x01234567;
   \                     ??prvLowPriorityPeekTask_2:
   \   00000030   ....               LDR      R0,??DataTable5_3  ;; 0x1234567
   \   00000032   0090               STR      R0,[SP, #+0]
    364          		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
   \   00000034   0023               MOVS     R3,#+0
   \   00000036   0022               MOVS     R2,#+0
   \   00000038   6946               MOV      R1,SP
   \   0000003A   2000               MOVS     R0,R4
   \   0000003C   ........           BL       xQueueGenericSend
   \   00000040   0128               CMP      R0,#+1
   \   00000042   02D0               BEQ      ??prvLowPriorityPeekTask_3
    365          		{
    366          			/* We were expecting the queue to be empty so we should not of
    367          			had a problem writing to the queue. */
    368          			xErrorDetected = pdTRUE;
   \   00000044   ....               LDR      R0,??DataTable5_1
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   0160               STR      R1,[R0, #+0]
    369          		}
    370          
    371          		/* All the other tasks should now have successfully peeked the data.
    372          		The data is still in the queue so we should be able to receive it. */
    373          		ulValue = 0;
   \                     ??prvLowPriorityPeekTask_3:
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   0090               STR      R0,[SP, #+0]
    374          		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
   \   0000004E   0023               MOVS     R3,#+0
   \   00000050   0022               MOVS     R2,#+0
   \   00000052   6946               MOV      R1,SP
   \   00000054   2000               MOVS     R0,R4
   \   00000056   ........           BL       xQueueGenericReceive
   \   0000005A   0128               CMP      R0,#+1
   \   0000005C   02D0               BEQ      ??prvLowPriorityPeekTask_4
    375          		{
    376          			/* We expected to receive the data. */
    377          			xErrorDetected = pdTRUE;
   \   0000005E   ....               LDR      R0,??DataTable5_1
   \   00000060   0121               MOVS     R1,#+1
   \   00000062   0160               STR      R1,[R0, #+0]
    378          		}
    379          
    380          		if( ulValue != 0x01234567 )
    381          		{
    382          			/* We did not receive the expected value. */
    383          		}
    384          		
    385          		/* Lets just delay a while as this is an intensive test as we don't
    386          		want to starve other tests of processing time. */
    387          		vTaskDelay( qpeekSHORT_DELAY );
   \                     ??prvLowPriorityPeekTask_4:
   \   00000064   0A20               MOVS     R0,#+10
   \   00000066   ........           BL       vTaskDelay
    388          
    389          		/* Unsuspend the other tasks so we can repeat the test - this time
    390          		however not all the other tasks will peek the data as the high
    391          		priority task is actually going to remove it from the queue.  Send
    392          		to front is used just to be different.  As the queue is empty it
    393          		makes no difference to the result. */
    394          		vTaskResume( xMediumPriorityTask );
   \   0000006A   ....               LDR      R0,??DataTable5_6
   \   0000006C   0068               LDR      R0,[R0, #+0]
   \   0000006E   ........           BL       vTaskResume
    395          		vTaskResume( xHighPriorityTask );
   \   00000072   ....               LDR      R0,??DataTable4
   \   00000074   0068               LDR      R0,[R0, #+0]
   \   00000076   ........           BL       vTaskResume
    396          		vTaskResume( xHighestPriorityTask );
   \   0000007A   ....               LDR      R0,??DataTable4_3
   \   0000007C   0068               LDR      R0,[R0, #+0]
   \   0000007E   ........           BL       vTaskResume
    397          
    398          		ulValue = 0xaabbaabb;
   \   00000082   ....               LDR      R0,??DataTable5_4  ;; 0xaabbaabb
   \   00000084   0090               STR      R0,[SP, #+0]
    399          		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
   \   00000086   0123               MOVS     R3,#+1
   \   00000088   0022               MOVS     R2,#+0
   \   0000008A   6946               MOV      R1,SP
   \   0000008C   2000               MOVS     R0,R4
   \   0000008E   ........           BL       xQueueGenericSend
   \   00000092   0128               CMP      R0,#+1
   \   00000094   02D0               BEQ      ??prvLowPriorityPeekTask_5
    400          		{
    401          			/* We were expecting the queue to be empty so we should not of
    402          			had a problem writing to the queue. */
    403          			xErrorDetected = pdTRUE;
   \   00000096   ....               LDR      R0,??DataTable5_1
   \   00000098   0121               MOVS     R1,#+1
   \   0000009A   0160               STR      R1,[R0, #+0]
    404          		}
    405          
    406          		/* This time we should find that the queue is empty.  The high priority
    407          		task actually removed the data rather than just peeking it. */
    408          		if( xQueuePeek( xQueue, &ulValue, qpeekNO_BLOCK ) != errQUEUE_EMPTY )
   \                     ??prvLowPriorityPeekTask_5:
   \   0000009C   0123               MOVS     R3,#+1
   \   0000009E   0022               MOVS     R2,#+0
   \   000000A0   6946               MOV      R1,SP
   \   000000A2   2000               MOVS     R0,R4
   \   000000A4   ........           BL       xQueueGenericReceive
   \   000000A8   0028               CMP      R0,#+0
   \   000000AA   02D0               BEQ      ??prvLowPriorityPeekTask_6
    409          		{
    410          			/* We expected to receive the data. */
    411          			xErrorDetected = pdTRUE;
   \   000000AC   ....               LDR      R0,??DataTable5_1
   \   000000AE   0121               MOVS     R1,#+1
   \   000000B0   0160               STR      R1,[R0, #+0]
    412          		}
    413          
    414          		/* Unsuspend the highest and high priority tasks so we can go back
    415          		and repeat the whole thing.  The medium priority task should not be
    416          		suspended as it was not able to peek the data in this last case. */
    417          		vTaskResume( xHighPriorityTask );
   \                     ??prvLowPriorityPeekTask_6:
   \   000000B2   ....               LDR      R0,??DataTable4
   \   000000B4   0068               LDR      R0,[R0, #+0]
   \   000000B6   ........           BL       vTaskResume
    418          		vTaskResume( xHighestPriorityTask );		
   \   000000BA   ....               LDR      R0,??DataTable4_3
   \   000000BC   0068               LDR      R0,[R0, #+0]
   \   000000BE   ........           BL       vTaskResume
    419          
    420          		/* Lets just delay a while as this is an intensive test as we don't
    421          		want to starve other tests of processing time. */
    422          		vTaskDelay( qpeekSHORT_DELAY );
   \   000000C2   0A20               MOVS     R0,#+10
   \   000000C4   ........           BL       vTaskDelay
   \   000000C8   9DE7               B        ??prvLowPriorityPeekTask_0
    423          	}
    424          }
    425          /*-----------------------------------------------------------*/
    426          
    427          /* This is called to check that all the created tasks are still running. */

   \                                 In section .text, align 2, keep-with-next
    428          portBASE_TYPE xAreQueuePeekTasksStillRunning( void )
    429          {
   \                     xAreQueuePeekTasksStillRunning:
   \   00000000   00B5               PUSH     {LR}
    430          static unsigned portLONG ulLastLoopCounter = 0;
    431          
    432          	/* If the demo task is still running then we expect the loopcounter to
    433          	have incremented since this function was last called. */
    434          	if( ulLastLoopCounter == ulLoopCounter )
   \   00000002   ....               LDR      R0,??DataTable5_7
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   ....               LDR      R1,??DataTable5_5
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   8842               CMP      R0,R1
   \   0000000C   02D1               BNE      ??xAreQueuePeekTasksStillRunning_0
    435          	{
    436          		xErrorDetected = pdTRUE;
   \   0000000E   ....               LDR      R0,??DataTable5_1
   \   00000010   0121               MOVS     R1,#+1
   \   00000012   0160               STR      R1,[R0, #+0]
    437          	}
    438          
    439          	ulLastLoopCounter = ulLoopCounter;
   \                     ??xAreQueuePeekTasksStillRunning_0:
   \   00000014   ....               LDR      R0,??DataTable5_7
   \   00000016   ....               LDR      R1,??DataTable5_5
   \   00000018   0968               LDR      R1,[R1, #+0]
   \   0000001A   0160               STR      R1,[R0, #+0]
    440          
    441          	/* Errors detected in the task itself will have latched xErrorDetected
    442          	to true. */
    443          
    444          	return !xErrorDetected;
   \   0000001C   ....               LDR      R0,??DataTable5_1
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   01D1               BNE      ??xAreQueuePeekTasksStillRunning_1
   \   00000024   0120               MOVS     R0,#+1
   \   00000026   00E0               B        ??xAreQueuePeekTasksStillRunning_2
   \                     ??xAreQueuePeekTasksStillRunning_1:
   \   00000028   0020               MOVS     R0,#+0
   \                     ??xAreQueuePeekTasksStillRunning_2:
   \   0000002A   C0B2               UXTB     R0,R0
   \   0000002C   00BD               POP      {PC}             ;; return
    445          }

   \                                 In section .bss, align 4
   \                     ??ulLastLoopCounter:
   \   00000000                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     `?<Constant "PeekL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     prvLowPriorityPeekTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     xMediumPriorityTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     `?<Constant "PeekM">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     prvMediumPriorityPeekTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     xHighPriorityTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     `?<Constant "PeekH1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     prvHighPriorityPeekTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   ........           DC32     xHighestPriorityTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     `?<Constant "PeekH2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     prvHighestPriorityPeekTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   ........           DC32     xErrorDetected

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   44332211           DC32     0x11223344

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   67452301           DC32     0x1234567

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   BBAABBAA           DC32     0xaabbaabb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   ........           DC32     ulLoopCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   ........           DC32     xMediumPriorityTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   ........           DC32     ??ulLastLoopCounter

   \                                 In section .rodata, align 4
   \                     `?<Constant "PeekL">`:
   \   00000000   5065656B4C00       DC8 "PeekL"
   \   00000006   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "PeekM">`:
   \   00000000   5065656B4D00       DC8 "PeekM"
   \   00000006   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "PeekH1">`:
   \   00000000   5065656B4831       DC8 "PeekH1"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "PeekH2">`:
   \   00000000   5065656B4832       DC8 "PeekH2"
   \              00          
   \   00000007   00                 DC8 0
    446          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     prvHighPriorityPeekTask            16
     prvHighestPriorityPeekTask         16
     prvLowPriorityPeekTask             16
     prvMediumPriorityPeekTask          16
     vStartQueuePeekTasks               24
     xAreQueuePeekTasksStillRunning      4


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     xErrorDetected                    4
     ulLoopCounter                     4
     xMediumPriorityTask               4
     xHighPriorityTask                 4
     xHighestPriorityTask              4
     vStartQueuePeekTasks            126
     prvHighestPriorityPeekTask      206
     prvHighPriorityPeekTask         112
     prvMediumPriorityPeekTask        78
     prvLowPriorityPeekTask          202
     xAreQueuePeekTasksStillRunning   46
     ulLastLoopCounter                 4
     ??DataTable3                      4
     ??DataTable3_1                    4
     ??DataTable3_2                    4
     ??DataTable3_3                    4
     ??DataTable3_4                    4
     ??DataTable4                      4
     ??DataTable4_1                    4
     ??DataTable4_2                    4
     ??DataTable4_3                    4
     ??DataTable4_4                    4
     ??DataTable5                      4
     ??DataTable5_1                    4
     ??DataTable5_2                    4
     ??DataTable5_3                    4
     ??DataTable5_4                    4
     ??DataTable5_5                    4
     ??DataTable5_6                    4
     ??DataTable5_7                    4
     ?<Constant "PeekL">               8
     ?<Constant "PeekM">               8
     ?<Constant "PeekH1">              8
     ?<Constant "PeekH2">              8

 
  24 bytes in section .bss
  32 bytes in section .rodata
 842 bytes in section .text
 
 842 bytes of CODE  memory
  32 bytes of CONST memory
  24 bytes of DATA  memory

Errors: none
Warnings: none
