###############################################################################
#                                                                             #
#                                                       06/Jul/2010  14:34:58 #
# IAR ANSI C/C++ Compiler V5.50.0.21878/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Source\tasks.c             #
#    Command line =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Source\tasks.c -D          #
#                    IAR_ARM_CM0 -lCN E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORT #
#                    EX_NUC1xx_Keil_IAR\Debug\List\ --diag_suppress           #
#                    Pe550,Pa082,Pa039 -o E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\ #
#                    CORTEX_NUC1xx_Keil_IAR\Debug\Obj\ --no_cse --no_unroll   #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M0  #
#                    -e --fpu=None --dlib_config "D:\Program                  #
#                    Files\ARM\INC\DLib_Config_Full.h" -I                     #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\..\common\include\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\De #
#                    mo\CORTEX_NUC1xx_Keil_IAR\..\..\source\include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_K #
#                    eil_IAR\NUC1xxBSP\NuvotonPlatform_Keil\Include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\NuvotonPlatform_Keil\Include\Driver\ -I      #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\CMSIS\CM0\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\ #
#                    Demo\CORTEX_NUC1xx_Keil_IAR\User_Demo\include\ -I        #
#                    "D:\Program Files\ARM\INC\" -Ol                          #
#    List file    =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\List\tasks.lst                                   #
#    Object file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\Obj\tasks.o                                      #
#                                                                             #
#                                                                             #
###############################################################################

E:\FreeRTOS_Keil_IAR\FreeRTOS\Source\tasks.c
      1          /*
      2              FreeRTOS V6.0.5 - Copyright (C) 2010 Real Time Engineers Ltd.
      3          
      4              ***************************************************************************
      5              *                                                                         *
      6              * If you are:                                                             *
      7              *                                                                         *
      8              *    + New to FreeRTOS,                                                   *
      9              *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
     10              *    + Looking for basic training,                                        *
     11              *    + Wanting to improve your FreeRTOS skills and productivity           *
     12              *                                                                         *
     13              * then take a look at the FreeRTOS eBook                                  *
     14              *                                                                         *
     15              *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
     16              *                  http://www.FreeRTOS.org/Documentation                  *
     17              *                                                                         *
     18              * A pdf reference manual is also available.  Both are usually delivered   *
     19              * to your inbox within 20 minutes to two hours when purchased between 8am *
     20              * and 8pm GMT (although please allow up to 24 hours in case of            *
     21              * exceptional circumstances).  Thank you for your support!                *
     22              *                                                                         *
     23              ***************************************************************************
     24          
     25              This file is part of the FreeRTOS distribution.
     26          
     27              FreeRTOS is free software; you can redistribute it and/or modify it under
     28              the terms of the GNU General Public License (version 2) as published by the
     29              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     30              ***NOTE*** The exception to the GPL is included to allow you to distribute
     31              a combined work that includes FreeRTOS without being obliged to provide the
     32              source code for proprietary components outside of the FreeRTOS kernel.
     33              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
     34              ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     35              FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     36              more details. You should have received a copy of the GNU General Public 
     37              License and the FreeRTOS license exception along with FreeRTOS; if not it 
     38              can be viewed here: http://www.freertos.org/a00114.html and also obtained 
     39              by writing to Richard Barry, contact details for whom are available on the
     40              FreeRTOS WEB site.
     41          
     42              1 tab == 4 spaces!
     43          
     44              http://www.FreeRTOS.org - Documentation, latest information, license and
     45              contact details.
     46          
     47              http://www.SafeRTOS.com - A version that is certified for use in safety
     48              critical systems.
     49          
     50              http://www.OpenRTOS.com - Commercial support, development, porting,
     51              licensing and training services.
     52          */
     53          
     54          
     55          #include <stdio.h>
     56          #include <stdlib.h>
     57          #include <string.h>

   \                                 In section .text, align 2
   \   __??Code16?? __intrinsic __code __interwork void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1000               MOVS     R0,R2
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       __aeabi_memset
   \   00000010   2000               MOVS     R0,R4
   \   00000012   10BD               POP      {R4,PC}          ;; return
     58          
     59          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     60          all the API functions to use the MPU wrappers.  That should only be done when
     61          task.h is included from an application file. */
     62          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     63          
     64          #include "FreeRTOS.h"
     65          #include "task.h"
     66          #include "StackMacros.h"
     67          
     68          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     69          
     70          /*
     71           * Macro to define the amount of stack available to the idle task.
     72           */
     73          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
     74          
     75          /*
     76           * Task control block.  A task control block (TCB) is allocated to each task,
     77           * and stores the context of the task.
     78           */
     79          typedef struct tskTaskControlBlock
     80          {
     81          	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE STRUCT. */
     82          
     83          	#if ( portUSING_MPU_WRAPPERS == 1 )
     84          		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE STRUCT. */
     85          	#endif	
     86          	
     87          	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
     88          	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
     89          	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. */
     90          	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
     91          	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */
     92          
     93          	#if ( portSTACK_GROWTH > 0 )
     94          		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the stack grows up from low memory. */
     95          	#endif
     96          
     97          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
     98          		unsigned portBASE_TYPE uxCriticalNesting;
     99          	#endif
    100          
    101          	#if ( configUSE_TRACE_FACILITY == 1 )
    102          		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debugging easier only. */
    103          	#endif
    104          
    105          	#if ( configUSE_MUTEXES == 1 )
    106          		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    107          	#endif
    108          
    109          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    110          		pdTASK_HOOK_CODE pxTaskTag;
    111          	#endif
    112          
    113          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    114          		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilising. */
    115          	#endif
    116          
    117          } tskTCB;
    118          
    119          
    120          /*
    121           * Some kernel aware debuggers require data to be viewed to be global, rather
    122           * than file scope.
    123           */
    124          #ifdef portREMOVE_STATIC_QUALIFIER
    125          	#define static
    126          #endif
    127          
    128          /*lint -e956 */

   \                                 In section .bss, align 4
    129          PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
   \                     pxCurrentTCB:
   \   00000000                      DS8 4
    130          
    131          /* Lists for ready and blocked tasks. --------------------*/
    132          

   \                                 In section .bss, align 4
    133          PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks. */
   \                     pxReadyTasksLists:
   \   00000000                      DS8 120

   \                                 In section .bss, align 4
    134          PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
   \                     xDelayedTaskList1:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
    135          PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
   \                     xDelayedTaskList2:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
    136          PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list currently being used. */
   \                     pxDelayedTaskList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    137          PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
   \                     pxOverflowDelayedTaskList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    138          PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready queue when the scheduler is resumed. */
   \                     xPendingReadyList:
   \   00000000                      DS8 20
    139          
    140          #if ( INCLUDE_vTaskDelete == 1 )
    141          

   \                                 In section .bss, align 4
    142          	PRIVILEGED_DATA static volatile xList xTasksWaitingTermination;		/*< Tasks that have been deleted - but the their memory not yet freed. */
   \                     xTasksWaitingTermination:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
    143          	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE ) 0;
   \                     uxTasksDeleted:
   \   00000000                      DS8 4
    144          
    145          #endif
    146          
    147          #if ( INCLUDE_vTaskSuspend == 1 )
    148          

   \                                 In section .bss, align 4
    149          	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
   \                     xSuspendedTaskList:
   \   00000000                      DS8 20
    150          
    151          #endif
    152          
    153          /* File private variables. --------------------------------*/

   \                                 In section .bss, align 4
    154          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBASE_TYPE ) 0;
   \                     uxCurrentNumberOfTasks:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    155          PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0;
   \                     xTickCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    156          PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
   \                     uxTopUsedPriority:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    157          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
   \                     uxTopReadyPriority:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    158          PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
   \                     xSchedulerRunning:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    159          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE_TYPE ) pdFALSE;
   \                     uxSchedulerSuspended:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    160          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE ) 0;
   \                     uxMissedTicks:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    161          PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
   \                     xMissedYield:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    162          PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
   \                     xNumOfOverflows:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    163          PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0;
   \                     uxTaskNumber:
   \   00000000                      DS8 4
    164          
    165          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    166          
    167          	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
    168          	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    169          	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime ) PRIVILEGED_FUNCTION;
    170          
    171          #endif
    172          
    173          /* Debugging and trace facilities private variables and macros. ------------*/
    174          
    175          /*
    176           * The value used to fill the stack of a task when the task is created.  This
    177           * is used purely for checking the high water mark for tasks.
    178           */
    179          #define tskSTACK_FILL_BYTE	( 0xa5 )
    180          
    181          /*
    182           * Macros used by vListTask to indicate which state a task is in.
    183           */
    184          #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
    185          #define tskREADY_CHAR		( ( signed char ) 'R' )
    186          #define tskDELETED_CHAR		( ( signed char ) 'D' )
    187          #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
    188          
    189          /*
    190           * Macros and private variables used by the trace facility.
    191           */
    192          #if ( configUSE_TRACE_FACILITY == 1 )
    193          
    194          	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsigned long ) ) )
    195          	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
    196          	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
    197          	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
    198          	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
    199          	static unsigned portBASE_TYPE uxPreviousTask = 255;
    200          	PRIVILEGED_DATA static char pcStatusString[ 50 ];
    201          
    202          #endif
    203          
    204          /*-----------------------------------------------------------*/
    205          
    206          /*
    207           * Macro that writes a trace of scheduler activity to a buffer.  This trace
    208           * shows which task is running when and is very useful as a debugging tool.
    209           * As this macro is called each context switch it is a good idea to undefine
    210           * it if not using the facility.
    211           */
    212          #if ( configUSE_TRACE_FACILITY == 1 )
    213          
    214          	#define vWriteTraceToBuffer()																	\
    215          	{																								\
    216          		if( xTracing )																				\
    217          		{																							\
    218          			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
    219          			{																						\
    220          				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
    221          				{																					\
    222          					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
    223          					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;		\
    224          					pcTraceBuffer += sizeof( unsigned long );									\
    225          					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;	\
    226          					pcTraceBuffer += sizeof( unsigned long );									\
    227          				}																					\
    228          				else																				\
    229          				{																					\
    230          					xTracing = pdFALSE;																\
    231          				}																					\
    232          			}																						\
    233          		}																							\
    234          	}
    235          
    236          #else
    237          
    238          	#define vWriteTraceToBuffer()
    239          
    240          #endif
    241          /*-----------------------------------------------------------*/
    242          
    243          /*
    244           * Place the task represented by pxTCB into the appropriate ready queue for
    245           * the task.  It is inserted at the end of the list.  One quirk of this is
    246           * that if the task being inserted is at the same priority as the currently
    247           * executing task, then it will only be rescheduled after the currently
    248           * executing task has been rescheduled.
    249           */
    250          #define prvAddTaskToReadyQueue( pxTCB )																			\
    251          {																												\
    252          	if( pxTCB->uxPriority > uxTopReadyPriority )																\
    253          	{																											\
    254          		uxTopReadyPriority = pxTCB->uxPriority;																	\
    255          	}																											\
    256          	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) );	\
    257          }
    258          /*-----------------------------------------------------------*/
    259          
    260          /*
    261           * Macro that looks at the list of tasks that are currently delayed to see if
    262           * any require waking.
    263           *
    264           * Tasks are stored in the queue in the order of their wake time - meaning
    265           * once one tasks has been found whose timer has not expired we need not look
    266           * any further down the list.
    267           */
    268          #define prvCheckDelayedTasks()																						\
    269          {																													\
    270          register tskTCB *pxTCB;																								\
    271          																													\
    272          	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )						\
    273          	{																												\
    274          		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )									\
    275          		{																											\
    276          			break;																									\
    277          		}																											\
    278          		vListRemove( &( pxTCB->xGenericListItem ) );																\
    279          		/* Is the task waiting on an event also? */																	\
    280          		if( pxTCB->xEventListItem.pvContainer )																		\
    281          		{																											\
    282          			vListRemove( &( pxTCB->xEventListItem ) );																\
    283          		}																											\
    284          		prvAddTaskToReadyQueue( pxTCB );																			\
    285          	}																												\
    286          }
    287          /*-----------------------------------------------------------*/
    288          
    289          /*
    290           * Several functions take an xTaskHandle parameter that can optionally be NULL,
    291           * where NULL is used to indicate that the handle of the currently executing
    292           * task should be used in place of the parameter.  This macro simply checks to
    293           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    294           */
    295          #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskTCB * ) pxHandle )
    296          
    297          
    298          /* File private functions. --------------------------------*/
    299          
    300          /*
    301           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    302           * into the TCB structure.
    303           */
    304          static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth ) PRIVILEGED_FUNCTION;
    305          
    306          /*
    307           * Utility to ready all the lists used by the scheduler.  This is called
    308           * automatically upon the creation of the first task.
    309           */
    310          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    311          
    312          /*
    313           * The idle task, which as all tasks is implemented as a never ending loop.
    314           * The idle task is automatically created and added to the ready lists upon
    315           * creation of the first user task.
    316           *
    317           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    318           * language extensions.  The equivalent prototype for this function is:
    319           *
    320           * void prvIdleTask( void *pvParameters );
    321           *
    322           */
    323          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    324          
    325          /*
    326           * Utility to free all memory allocated by the scheduler to hold a TCB,
    327           * including the stack pointed to by the TCB.
    328           *
    329           * This does not free memory allocated by the task itself (i.e. memory
    330           * allocated by calls to pvPortMalloc from within the tasks application code).
    331           */
    332          #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
    333          
    334          	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
    335          
    336          #endif
    337          
    338          /*
    339           * Used only by the idle task.  This checks to see if anything has been placed
    340           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    341           * and its TCB deleted.
    342           */
    343          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    344          
    345          /*
    346           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    347           * allocation was successful.
    348           */
    349          static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer ) PRIVILEGED_FUNCTION;
    350          
    351          /*
    352           * Called from vTaskList.  vListTasks details all the tasks currently under
    353           * control of the scheduler.  The tasks may be in one of a number of lists.
    354           * prvListTaskWithinSingleList accepts a list and details the tasks from
    355           * within just that list.
    356           *
    357           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    358           * NORMAL APPLICATION CODE.
    359           */
    360          #if ( configUSE_TRACE_FACILITY == 1 )
    361          
    362          	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus ) PRIVILEGED_FUNCTION;
    363          
    364          #endif
    365          
    366          /*
    367           * When a task is created, the stack of the task is filled with a known value.
    368           * This function determines the 'high water mark' of the task stack by
    369           * determining how much of the stack remains at the original preset value.
    370           */
    371          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    372          
    373          	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_FUNCTION;
    374          
    375          #endif
    376          
    377          
    378          /*lint +e956 */
    379          
    380          
    381          
    382          /*-----------------------------------------------------------
    383           * TASK CREATION API documented in task.h
    384           *----------------------------------------------------------*/
    385          

   \                                 In section .text, align 2, keep-with-next
    386          signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
    387          {
   \                     xTaskGenericCreate:
   \   00000000   FBB5               PUSH     {R0,R1,R3-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   1700               MOVS     R7,R2
   \   00000006   0B9E               LDR      R6,[SP, #+44]
   \   00000008   0C99               LDR      R1,[SP, #+48]
    388          signed portBASE_TYPE xReturn;
    389          tskTCB * pxNewTCB;
    390          
    391          	/* Allocate the memory required by the TCB and stack for the new task,
    392          	checking that the allocation was successful. */
    393          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   \   0000000A   3800               MOVS     R0,R7
   \   0000000C   80B2               UXTH     R0,R0
   \   0000000E   ........           BL       prvAllocateTCBAndStack
   \   00000012   0400               MOVS     R4,R0
    394          
    395          	if( pxNewTCB != NULL )
   \   00000014   002C               CMP      R4,#+0
   \   00000016   53D0               BEQ      ??xTaskGenericCreate_0
    396          	{
    397          		portSTACK_TYPE *pxTopOfStack;
    398          
    399          		#if( portUSING_MPU_WRAPPERS == 1 )
    400          			/* Should the task be created in privileged mode? */
    401          			portBASE_TYPE xRunPrivileged;
    402          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )
    403          			{
    404          				xRunPrivileged = pdTRUE;
    405          			}
    406          			else
    407          			{
    408          				xRunPrivileged = pdFALSE;
    409          			}
    410          			uxPriority &= ~portPRIVILEGE_BIT;
    411          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    412          
    413          		/* Calculate the top of stack address.  This depends on whether the
    414          		stack grows from high memory to low (as per the 80x86) or visa versa.
    415          		portSTACK_GROWTH is used to make the result positive or negative as
    416          		required by the port. */
    417          		#if( portSTACK_GROWTH < 0 )
    418          		{
    419          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
   \   00000018   BFB2               UXTH     R7,R7
   \   0000001A   0420               MOVS     R0,#+4
   \   0000001C   7843               MULS     R0,R7,R0
   \   0000001E   216B               LDR      R1,[R4, #+48]
   \   00000020   0D18               ADDS     R5,R1,R0
   \   00000022   2D1F               SUBS     R5,R5,#+4
    420          			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
   \   00000024   0720               MOVS     R0,#+7
   \   00000026   8543               BICS     R5,R5,R0
    421          		}
    422          		#else
    423          		{
    424          			pxTopOfStack = pxNewTCB->pxStack;
    425          
    426          			/* If we want to use stack checking on architectures that use
    427          			a positive stack growth direction then we also need to store the
    428          			other extreme of the stack space. */
    429          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    430          		}
    431          		#endif
    432          
    433          		/* Setup the newly allocated TCB with the initial state of the task. */
    434          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   \   00000028   BFB2               UXTH     R7,R7
   \   0000002A   0097               STR      R7,[SP, #+0]
   \   0000002C   0D9B               LDR      R3,[SP, #+52]
   \   0000002E   0A9A               LDR      R2,[SP, #+40]
   \   00000030   0399               LDR      R1,[SP, #+12]
   \   00000032   2000               MOVS     R0,R4
   \   00000034   ........           BL       prvInitialiseTCBVariables
    435          
    436          		/* Initialize the TCB stack to look as if the task was already running,
    437          		but had been interrupted by the scheduler.  The return address is set
    438          		to the start of the task function. Once the stack has been initialised
    439          		the	top of stack variable is updated. */
    440          		#if( portUSING_MPU_WRAPPERS == 1 )
    441          		{
    442          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    443          		}
    444          		#else
    445          		{
    446          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   \   00000038   049A               LDR      R2,[SP, #+16]
   \   0000003A   0299               LDR      R1,[SP, #+8]
   \   0000003C   2800               MOVS     R0,R5
   \   0000003E   ........           BL       pxPortInitialiseStack
   \   00000042   2060               STR      R0,[R4, #+0]
    447          		}
    448          		#endif
    449          
    450          		/* We are going to manipulate the task queues to add this task to a
    451          		ready list, so must make sure no interrupts occur. */
    452          		portENTER_CRITICAL();
   \   00000044   ........           BL       vPortEnterCritical
    453          		{
    454          			uxCurrentNumberOfTasks++;
   \   00000048   ....               LDR      R0,??DataTable4
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   401C               ADDS     R0,R0,#+1
   \   0000004E   ....               LDR      R1,??DataTable4
   \   00000050   0860               STR      R0,[R1, #+0]
    455          			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
   \   00000052   ....               LDR      R0,??DataTable4
   \   00000054   0068               LDR      R0,[R0, #+0]
   \   00000056   0128               CMP      R0,#+1
   \   00000058   04D1               BNE      ??xTaskGenericCreate_1
    456          			{
    457          				/* As this is the first task it must also be the current task. */
    458          				pxCurrentTCB =  pxNewTCB;
   \   0000005A   ....               LDR      R0,??DataTable6
   \   0000005C   0460               STR      R4,[R0, #+0]
    459          
    460          				/* This is the first task to be created so do the preliminary
    461          				initialisation required.  We will not recover if this call
    462          				fails, but we will report the failure. */
    463          				prvInitialiseTaskLists();
   \   0000005E   ........           BL       prvInitialiseTaskLists
   \   00000062   0BE0               B        ??xTaskGenericCreate_2
    464          			}
    465          			else
    466          			{
    467          				/* If the scheduler is not already running, make this task the
    468          				current task if it is the highest priority task to be created
    469          				so far. */
    470          				if( xSchedulerRunning == pdFALSE )
   \                     ??xTaskGenericCreate_1:
   \   00000064   ....               LDR      R0,??DataTable5
   \   00000066   0068               LDR      R0,[R0, #+0]
   \   00000068   0028               CMP      R0,#+0
   \   0000006A   07D1               BNE      ??xTaskGenericCreate_2
    471          				{
    472          					if( pxCurrentTCB->uxPriority <= uxPriority )
   \   0000006C   0A98               LDR      R0,[SP, #+40]
   \   0000006E   ....               LDR      R1,??DataTable6
   \   00000070   0968               LDR      R1,[R1, #+0]
   \   00000072   C96A               LDR      R1,[R1, #+44]
   \   00000074   8842               CMP      R0,R1
   \   00000076   01D3               BCC      ??xTaskGenericCreate_2
    473          					{
    474          						pxCurrentTCB = pxNewTCB;
   \   00000078   ....               LDR      R0,??DataTable6
   \   0000007A   0460               STR      R4,[R0, #+0]
    475          					}
    476          				}
    477          			}
    478          
    479          			/* Remember the top priority to make context switching faster.  Use
    480          			the priority in pxNewTCB as this has been capped to a valid value. */
    481          			if( pxNewTCB->uxPriority > uxTopUsedPriority )
   \                     ??xTaskGenericCreate_2:
   \   0000007C   ....               LDR      R0,??DataTable5_1
   \   0000007E   0068               LDR      R0,[R0, #+0]
   \   00000080   E16A               LDR      R1,[R4, #+44]
   \   00000082   8842               CMP      R0,R1
   \   00000084   02D2               BCS      ??xTaskGenericCreate_3
    482          			{
    483          				uxTopUsedPriority = pxNewTCB->uxPriority;
   \   00000086   E06A               LDR      R0,[R4, #+44]
   \   00000088   ....               LDR      R1,??DataTable5_1
   \   0000008A   0860               STR      R0,[R1, #+0]
    484          			}
    485          
    486          			#if ( configUSE_TRACE_FACILITY == 1 )
    487          			{
    488          				/* Add a counter into the TCB for tracing only. */
    489          				pxNewTCB->uxTCBNumber = uxTaskNumber;
    490          			}
    491          			#endif
    492          			uxTaskNumber++;
   \                     ??xTaskGenericCreate_3:
   \   0000008C   ....               LDR      R0,??DataTable5_2
   \   0000008E   0068               LDR      R0,[R0, #+0]
   \   00000090   401C               ADDS     R0,R0,#+1
   \   00000092   ....               LDR      R1,??DataTable5_2
   \   00000094   0860               STR      R0,[R1, #+0]
    493          
    494          			prvAddTaskToReadyQueue( pxNewTCB );
   \   00000096   ....               LDR      R0,??DataTable5_3
   \   00000098   0068               LDR      R0,[R0, #+0]
   \   0000009A   E16A               LDR      R1,[R4, #+44]
   \   0000009C   8842               CMP      R0,R1
   \   0000009E   02D2               BCS      ??xTaskGenericCreate_4
   \   000000A0   E06A               LDR      R0,[R4, #+44]
   \   000000A2   ....               LDR      R1,??DataTable5_3
   \   000000A4   0860               STR      R0,[R1, #+0]
   \                     ??xTaskGenericCreate_4:
   \   000000A6   2100               MOVS     R1,R4
   \   000000A8   091D               ADDS     R1,R1,#+4
   \   000000AA   E06A               LDR      R0,[R4, #+44]
   \   000000AC   1422               MOVS     R2,#+20
   \   000000AE   5043               MULS     R0,R2,R0
   \   000000B0   ....               LDR      R2,??DataTable5_4
   \   000000B2   1018               ADDS     R0,R2,R0
   \   000000B4   ........           BL       vListInsertEnd
    495          
    496          			xReturn = pdPASS;
   \   000000B8   0125               MOVS     R5,#+1
    497          			traceTASK_CREATE( pxNewTCB );
    498          		}
    499          		portEXIT_CRITICAL();
   \   000000BA   ........           BL       vPortExitCritical
   \   000000BE   01E0               B        ??xTaskGenericCreate_5
    500          	}
    501          	else
    502          	{
    503          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   \                     ??xTaskGenericCreate_0:
   \   000000C0   0025               MOVS     R5,#+0
   \   000000C2   ED43               MVNS     R5,R5            ;; #-1
    504          		traceTASK_CREATE_FAILED( pxNewTCB );
    505          	}
    506          
    507          	if( xReturn == pdPASS )
   \                     ??xTaskGenericCreate_5:
   \   000000C4   012D               CMP      R5,#+1
   \   000000C6   0ED1               BNE      ??xTaskGenericCreate_6
    508          	{
    509          		if( ( void * ) pxCreatedTask != NULL )
   \   000000C8   002E               CMP      R6,#+0
   \   000000CA   00D0               BEQ      ??xTaskGenericCreate_7
    510          		{
    511          			/* Pass the TCB out - in an anonymous way.  The calling function/
    512          			task can use this as a handle to delete the task later if
    513          			required.*/
    514          			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
   \   000000CC   3460               STR      R4,[R6, #+0]
    515          		}
    516          
    517          		if( xSchedulerRunning != pdFALSE )
   \                     ??xTaskGenericCreate_7:
   \   000000CE   ....               LDR      R0,??DataTable5
   \   000000D0   0068               LDR      R0,[R0, #+0]
   \   000000D2   0028               CMP      R0,#+0
   \   000000D4   07D0               BEQ      ??xTaskGenericCreate_6
    518          		{
    519          			/* If the created task is of a higher priority than the current task
    520          			then it should run now. */
    521          			if( pxCurrentTCB->uxPriority < uxPriority )
   \   000000D6   ....               LDR      R0,??DataTable6
   \   000000D8   0068               LDR      R0,[R0, #+0]
   \   000000DA   C06A               LDR      R0,[R0, #+44]
   \   000000DC   0A99               LDR      R1,[SP, #+40]
   \   000000DE   8842               CMP      R0,R1
   \   000000E0   01D2               BCS      ??xTaskGenericCreate_6
    522          			{
    523          				portYIELD_WITHIN_API();
   \   000000E2   ........           BL       vPortYieldFromISR
    524          			}
    525          		}
    526          	}
    527          
    528          	return xReturn;
   \                     ??xTaskGenericCreate_6:
   \   000000E6   2800               MOVS     R0,R5
   \   000000E8   05B0               ADD      SP,SP,#+20
   \   000000EA   F0BD               POP      {R4-R7,PC}       ;; return
    529          }
    530          /*-----------------------------------------------------------*/
    531          
    532          #if ( INCLUDE_vTaskDelete == 1 )
    533          

   \                                 In section .text, align 2, keep-with-next
    534          	void vTaskDelete( xTaskHandle pxTaskToDelete )
    535          	{
   \                     vTaskDelete:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
    536          	tskTCB *pxTCB;
    537          
    538          		portENTER_CRITICAL();
   \   00000004   ........           BL       vPortEnterCritical
    539          		{
    540          			/* Ensure a yield is performed if the current task is being
    541          			deleted. */
    542          			if( pxTaskToDelete == pxCurrentTCB )
   \   00000008   ....               LDR      R0,??DataTable6
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   8542               CMP      R5,R0
   \   0000000E   00D1               BNE      ??vTaskDelete_0
    543          			{
    544          				pxTaskToDelete = NULL;
   \   00000010   0025               MOVS     R5,#+0
    545          			}
    546          
    547          			/* If null is passed in here then we are deleting ourselves. */
    548          			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
   \                     ??vTaskDelete_0:
   \   00000012   002D               CMP      R5,#+0
   \   00000014   02D1               BNE      ??vTaskDelete_1
   \   00000016   ....               LDR      R0,??DataTable6
   \   00000018   0468               LDR      R4,[R0, #+0]
   \   0000001A   00E0               B        ??vTaskDelete_2
   \                     ??vTaskDelete_1:
   \   0000001C   2C00               MOVS     R4,R5
    549          
    550          			/* Remove task from the ready list and place in the	termination list.
    551          			This will stop the task from be scheduled.  The idle task will check
    552          			the termination list and free up any memory allocated by the
    553          			scheduler for the TCB and stack. */
    554          			vListRemove( &( pxTCB->xGenericListItem ) );
   \                     ??vTaskDelete_2:
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   001D               ADDS     R0,R0,#+4
   \   00000022   ........           BL       vListRemove
    555          
    556          			/* Is the task waiting on an event also? */
    557          			if( pxTCB->xEventListItem.pvContainer )
   \   00000026   A06A               LDR      R0,[R4, #+40]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   03D0               BEQ      ??vTaskDelete_3
    558          			{
    559          				vListRemove( &( pxTCB->xEventListItem ) );
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   1830               ADDS     R0,R0,#+24
   \   00000030   ........           BL       vListRemove
    560          			}
    561          
    562          			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
   \                     ??vTaskDelete_3:
   \   00000034   241D               ADDS     R4,R4,#+4
   \   00000036   2100               MOVS     R1,R4
   \   00000038   ....               LDR      R0,??DataTable7
   \   0000003A   ........           BL       vListInsertEnd
    563          
    564          			/* Increment the ucTasksDeleted variable so the idle task knows
    565          			there is a task that has been deleted and that it should therefore
    566          			check the xTasksWaitingTermination list. */
    567          			++uxTasksDeleted;
   \   0000003E   ....               LDR      R0,??DataTable7_1
   \   00000040   0068               LDR      R0,[R0, #+0]
   \   00000042   401C               ADDS     R0,R0,#+1
   \   00000044   ....               LDR      R1,??DataTable7_1
   \   00000046   0860               STR      R0,[R1, #+0]
    568          
    569          			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
    570          			can detect that the task lists need re-generating. */
    571          			uxTaskNumber++;
   \   00000048   ....               LDR      R0,??DataTable5_2
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   401C               ADDS     R0,R0,#+1
   \   0000004E   ....               LDR      R1,??DataTable5_2
   \   00000050   0860               STR      R0,[R1, #+0]
    572          
    573          			traceTASK_DELETE( pxTCB );
    574          		}
    575          		portEXIT_CRITICAL();
   \   00000052   ........           BL       vPortExitCritical
    576          
    577          		/* Force a reschedule if we have just deleted the current task. */
    578          		if( xSchedulerRunning != pdFALSE )
   \   00000056   ....               LDR      R0,??DataTable5
   \   00000058   0068               LDR      R0,[R0, #+0]
   \   0000005A   0028               CMP      R0,#+0
   \   0000005C   03D0               BEQ      ??vTaskDelete_4
    579          		{
    580          			if( ( void * ) pxTaskToDelete == NULL )
   \   0000005E   002D               CMP      R5,#+0
   \   00000060   01D1               BNE      ??vTaskDelete_4
    581          			{
    582          				portYIELD_WITHIN_API();
   \   00000062   ........           BL       vPortYieldFromISR
    583          			}
    584          		}
    585          	}
   \                     ??vTaskDelete_4:
   \   00000066   31BD               POP      {R0,R4,R5,PC}    ;; return
    586          
    587          #endif
    588          
    589          
    590          
    591          
    592          
    593          
    594          /*-----------------------------------------------------------
    595           * TASK CONTROL API documented in task.h
    596           *----------------------------------------------------------*/
    597          
    598          #if ( INCLUDE_vTaskDelayUntil == 1 )
    599          

   \                                 In section .text, align 2, keep-with-next
    600          	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
    601          	{
   \                     vTaskDelayUntil:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    602          	portTickType xTimeToWake;
    603          	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
   \   00000006   0026               MOVS     R6,#+0
    604          
    605          		vTaskSuspendAll();
   \   00000008   ........           BL       vTaskSuspendAll
    606          		{
    607          			/* Generate the tick time at which the task wants to wake. */
    608          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   \   0000000C   2868               LDR      R0,[R5, #+0]
   \   0000000E   0419               ADDS     R4,R0,R4
    609          
    610          			if( xTickCount < *pxPreviousWakeTime )
   \   00000010   ....               LDR      R0,??DataTable8
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   2968               LDR      R1,[R5, #+0]
   \   00000016   8842               CMP      R0,R1
   \   00000018   08D2               BCS      ??vTaskDelayUntil_0
    611          			{
    612          				/* The tick count has overflowed since this function was
    613          				lasted called.  In this case the only time we should ever
    614          				actually delay is if the wake time has also	overflowed,
    615          				and the wake time is greater than the tick time.  When this
    616          				is the case it is as if neither time had overflowed. */
    617          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
   \   0000001A   2868               LDR      R0,[R5, #+0]
   \   0000001C   8442               CMP      R4,R0
   \   0000001E   0DD2               BCS      ??vTaskDelayUntil_1
   \   00000020   ....               LDR      R0,??DataTable8
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   A042               CMP      R0,R4
   \   00000026   09D2               BCS      ??vTaskDelayUntil_1
    618          				{
    619          					xShouldDelay = pdTRUE;
   \   00000028   0126               MOVS     R6,#+1
   \   0000002A   07E0               B        ??vTaskDelayUntil_1
    620          				}
    621          			}
    622          			else
    623          			{
    624          				/* The tick time has not overflowed.  In this case we will
    625          				delay if either the wake time has overflowed, and/or the
    626          				tick time is less than the wake time. */
    627          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
   \                     ??vTaskDelayUntil_0:
   \   0000002C   2868               LDR      R0,[R5, #+0]
   \   0000002E   8442               CMP      R4,R0
   \   00000030   03D3               BCC      ??vTaskDelayUntil_2
   \   00000032   ....               LDR      R0,??DataTable8
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   A042               CMP      R0,R4
   \   00000038   00D2               BCS      ??vTaskDelayUntil_1
    628          				{
    629          					xShouldDelay = pdTRUE;
   \                     ??vTaskDelayUntil_2:
   \   0000003A   0126               MOVS     R6,#+1
    630          				}
    631          			}
    632          
    633          			/* Update the wake time ready for the next call. */
    634          			*pxPreviousWakeTime = xTimeToWake;
   \                     ??vTaskDelayUntil_1:
   \   0000003C   2C60               STR      R4,[R5, #+0]
    635          
    636          			if( xShouldDelay )
   \   0000003E   002E               CMP      R6,#+0
   \   00000040   1AD0               BEQ      ??vTaskDelayUntil_3
    637          			{
    638          				traceTASK_DELAY_UNTIL();
    639          
    640          				/* We must remove ourselves from the ready list before adding
    641          				ourselves to the blocked list as the same list item is used for
    642          				both lists. */
    643          				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   00000042   ....               LDR      R0,??DataTable6
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   001D               ADDS     R0,R0,#+4
   \   00000048   ........           BL       vListRemove
    644          
    645          				/* The list item will be inserted in wake time order. */
    646          				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   \   0000004C   ....               LDR      R0,??DataTable6
   \   0000004E   0068               LDR      R0,[R0, #+0]
   \   00000050   4460               STR      R4,[R0, #+4]
    647          
    648          				if( xTimeToWake < xTickCount )
   \   00000052   ....               LDR      R0,??DataTable8
   \   00000054   0068               LDR      R0,[R0, #+0]
   \   00000056   8442               CMP      R4,R0
   \   00000058   07D2               BCS      ??vTaskDelayUntil_4
    649          				{
    650          					/* Wake time has overflowed.  Place this item in the
    651          					overflow list. */
    652          					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   0000005A   ....               LDR      R0,??DataTable6
   \   0000005C   0168               LDR      R1,[R0, #+0]
   \   0000005E   091D               ADDS     R1,R1,#+4
   \   00000060   ....               LDR      R0,??DataTable9
   \   00000062   0068               LDR      R0,[R0, #+0]
   \   00000064   ........           BL       vListInsert
   \   00000068   06E0               B        ??vTaskDelayUntil_3
    653          				}
    654          				else
    655          				{
    656          					/* The wake time has not overflowed, so we can use the
    657          					current block list. */
    658          					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \                     ??vTaskDelayUntil_4:
   \   0000006A   ....               LDR      R0,??DataTable6
   \   0000006C   0168               LDR      R1,[R0, #+0]
   \   0000006E   091D               ADDS     R1,R1,#+4
   \   00000070   ....               LDR      R0,??DataTable12
   \   00000072   0068               LDR      R0,[R0, #+0]
   \   00000074   ........           BL       vListInsert
    659          				}
    660          			}
    661          		}
    662          		xAlreadyYielded = xTaskResumeAll();
   \                     ??vTaskDelayUntil_3:
   \   00000078   ........           BL       xTaskResumeAll
    663          
    664          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    665          		have put ourselves to sleep. */
    666          		if( !xAlreadyYielded )
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   01D1               BNE      ??vTaskDelayUntil_5
    667          		{
    668          			portYIELD_WITHIN_API();
   \   00000080   ........           BL       vPortYieldFromISR
    669          		}
    670          	}
   \                     ??vTaskDelayUntil_5:
   \   00000084   70BD               POP      {R4-R6,PC}       ;; return
    671          
    672          #endif
    673          /*-----------------------------------------------------------*/
    674          
    675          #if ( INCLUDE_vTaskDelay == 1 )
    676          

   \                                 In section .text, align 2, keep-with-next
    677          	void vTaskDelay( portTickType xTicksToDelay )
    678          	{
   \                     vTaskDelay:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    679          	portTickType xTimeToWake;
    680          	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   \   00000004   0020               MOVS     R0,#+0
    681          
    682          		/* A delay time of zero just forces a reschedule. */
    683          		if( xTicksToDelay > ( portTickType ) 0 )
   \   00000006   002C               CMP      R4,#+0
   \   00000008   21D0               BEQ      ??vTaskDelay_0
    684          		{
    685          			vTaskSuspendAll();
   \   0000000A   ........           BL       vTaskSuspendAll
    686          			{
    687          				traceTASK_DELAY();
    688          
    689          				/* A task that is removed from the event list while the
    690          				scheduler is suspended will not get placed in the ready
    691          				list or removed from the blocked list until the scheduler
    692          				is resumed.
    693          
    694          				This task cannot be in an event list as it is the currently
    695          				executing task. */
    696          
    697          				/* Calculate the time to wake - this may overflow but this is
    698          				not a problem. */
    699          				xTimeToWake = xTickCount + xTicksToDelay;
   \   0000000E   ....               LDR      R0,??DataTable8
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   0419               ADDS     R4,R0,R4
    700          
    701          				/* We must remove ourselves from the ready list before adding
    702          				ourselves to the blocked list as the same list item is used for
    703          				both lists. */
    704          				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   00000014   ....               LDR      R0,??DataTable6
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   001D               ADDS     R0,R0,#+4
   \   0000001A   ........           BL       vListRemove
    705          
    706          				/* The list item will be inserted in wake time order. */
    707          				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   \   0000001E   ....               LDR      R0,??DataTable6
   \   00000020   0068               LDR      R0,[R0, #+0]
   \   00000022   4460               STR      R4,[R0, #+4]
    708          
    709          				if( xTimeToWake < xTickCount )
   \   00000024   ....               LDR      R0,??DataTable8
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   8442               CMP      R4,R0
   \   0000002A   07D2               BCS      ??vTaskDelay_1
    710          				{
    711          					/* Wake time has overflowed.  Place this item in the
    712          					overflow list. */
    713          					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   0000002C   ....               LDR      R0,??DataTable6
   \   0000002E   0168               LDR      R1,[R0, #+0]
   \   00000030   091D               ADDS     R1,R1,#+4
   \   00000032   ....               LDR      R0,??DataTable9
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   ........           BL       vListInsert
   \   0000003A   06E0               B        ??vTaskDelay_2
    714          				}
    715          				else
    716          				{
    717          					/* The wake time has not overflowed, so we can use the
    718          					current block list. */
    719          					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \                     ??vTaskDelay_1:
   \   0000003C   ....               LDR      R0,??DataTable6
   \   0000003E   0168               LDR      R1,[R0, #+0]
   \   00000040   091D               ADDS     R1,R1,#+4
   \   00000042   ....               LDR      R0,??DataTable12
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   ........           BL       vListInsert
    720          				}
    721          			}
    722          			xAlreadyYielded = xTaskResumeAll();
   \                     ??vTaskDelay_2:
   \   0000004A   ........           BL       xTaskResumeAll
    723          		}
    724          
    725          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    726          		have put ourselves to sleep. */
    727          		if( !xAlreadyYielded )
   \                     ??vTaskDelay_0:
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   01D1               BNE      ??vTaskDelay_3
    728          		{
    729          			portYIELD_WITHIN_API();
   \   00000052   ........           BL       vPortYieldFromISR
    730          		}
    731          	}
   \                     ??vTaskDelay_3:
   \   00000056   10BD               POP      {R4,PC}          ;; return
    732          
    733          #endif
    734          /*-----------------------------------------------------------*/
    735          
    736          #if ( INCLUDE_uxTaskPriorityGet == 1 )
    737          

   \                                 In section .text, align 2, keep-with-next
    738          	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
    739          	{
   \                     uxTaskPriorityGet:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    740          	tskTCB *pxTCB;
    741          	unsigned portBASE_TYPE uxReturn;
    742          
    743          		portENTER_CRITICAL();
   \   00000004   ........           BL       vPortEnterCritical
    744          		{
    745          			/* If null is passed in here then we are changing the
    746          			priority of the calling function. */
    747          			pxTCB = prvGetTCBFromHandle( pxTask );
   \   00000008   002C               CMP      R4,#+0
   \   0000000A   02D1               BNE      ??uxTaskPriorityGet_0
   \   0000000C   ....               LDR      R0,??DataTable7_2
   \   0000000E   0468               LDR      R4,[R0, #+0]
   \   00000010   FFE7               B        ??uxTaskPriorityGet_1
    748          			uxReturn = pxTCB->uxPriority;
   \                     ??uxTaskPriorityGet_0:
   \                     ??uxTaskPriorityGet_1:
   \   00000012   E46A               LDR      R4,[R4, #+44]
    749          		}
    750          		portEXIT_CRITICAL();
   \   00000014   ........           BL       vPortExitCritical
    751          
    752          		return uxReturn;
   \   00000018   2000               MOVS     R0,R4
   \   0000001A   10BD               POP      {R4,PC}          ;; return
    753          	}
    754          
    755          #endif
    756          /*-----------------------------------------------------------*/
    757          
    758          #if ( INCLUDE_vTaskPrioritySet == 1 )
    759          

   \                                 In section .text, align 2, keep-with-next
    760          	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
    761          	{
   \                     vTaskPrioritySet:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0F00               MOVS     R7,R1
    762          	tskTCB *pxTCB;
    763          	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
   \   00000006   0026               MOVS     R6,#+0
    764          
    765          		/* Ensure the new priority is valid. */
    766          		if( uxNewPriority >= configMAX_PRIORITIES )
   \   00000008   062F               CMP      R7,#+6
   \   0000000A   00D3               BCC      ??vTaskPrioritySet_0
    767          		{
    768          			uxNewPriority = configMAX_PRIORITIES - 1;
   \   0000000C   0527               MOVS     R7,#+5
    769          		}
    770          
    771          		portENTER_CRITICAL();
   \                     ??vTaskPrioritySet_0:
   \   0000000E   ........           BL       vPortEnterCritical
    772          		{
    773          			if( pxTask == pxCurrentTCB )
   \   00000012   ....               LDR      R0,??DataTable6
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   8442               CMP      R4,R0
   \   00000018   00D1               BNE      ??vTaskPrioritySet_1
    774          			{
    775          				pxTask = NULL;
   \   0000001A   0024               MOVS     R4,#+0
    776          			}
    777          
    778          			/* If null is passed in here then we are changing the
    779          			priority of the calling function. */
    780          			pxTCB = prvGetTCBFromHandle( pxTask );
   \                     ??vTaskPrioritySet_1:
   \   0000001C   002C               CMP      R4,#+0
   \   0000001E   02D1               BNE      ??vTaskPrioritySet_2
   \   00000020   ....               LDR      R0,??DataTable6
   \   00000022   0568               LDR      R5,[R0, #+0]
   \   00000024   00E0               B        ??vTaskPrioritySet_3
   \                     ??vTaskPrioritySet_2:
   \   00000026   2500               MOVS     R5,R4
    781          
    782          			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
    783          
    784          			#if ( configUSE_MUTEXES == 1 )
    785          			{
    786          				uxCurrentPriority = pxTCB->uxBasePriority;
   \                     ??vTaskPrioritySet_3:
   \   00000028   686C               LDR      R0,[R5, #+68]
    787          			}
    788          			#else
    789          			{
    790          				uxCurrentPriority = pxTCB->uxPriority;
    791          			}
    792          			#endif
    793          
    794          			if( uxCurrentPriority != uxNewPriority )
   \   0000002A   B842               CMP      R0,R7
   \   0000002C   31D0               BEQ      ??vTaskPrioritySet_4
    795          			{
    796          				/* The priority change may have readied a task of higher
    797          				priority than the calling task. */
    798          				if( uxNewPriority > uxCurrentPriority )
   \   0000002E   B842               CMP      R0,R7
   \   00000030   03D2               BCS      ??vTaskPrioritySet_5
    799          				{
    800          					if( pxTask != NULL )
   \   00000032   002C               CMP      R4,#+0
   \   00000034   04D0               BEQ      ??vTaskPrioritySet_6
    801          					{
    802          						/* The priority of another task is being raised.  If we
    803          						were raising the priority of the currently running task
    804          						there would be no need to switch as it must have already
    805          						been the highest priority task. */
    806          						xYieldRequired = pdTRUE;
   \   00000036   0126               MOVS     R6,#+1
   \   00000038   02E0               B        ??vTaskPrioritySet_6
    807          					}
    808          				}
    809          				else if( pxTask == NULL )
   \                     ??vTaskPrioritySet_5:
   \   0000003A   002C               CMP      R4,#+0
   \   0000003C   00D1               BNE      ??vTaskPrioritySet_6
    810          				{
    811          					/* Setting our own priority down means there may now be another
    812          					task of higher priority that is ready to execute. */
    813          					xYieldRequired = pdTRUE;
   \   0000003E   0126               MOVS     R6,#+1
    814          				}
    815          
    816          
    817          
    818          				#if ( configUSE_MUTEXES == 1 )
    819          				{
    820          					/* Only change the priority being used if the task is not
    821          					currently using an inherited priority. */
    822          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   \                     ??vTaskPrioritySet_6:
   \   00000040   696C               LDR      R1,[R5, #+68]
   \   00000042   EA6A               LDR      R2,[R5, #+44]
   \   00000044   9142               CMP      R1,R2
   \   00000046   00D1               BNE      ??vTaskPrioritySet_7
    823          					{
    824          						pxTCB->uxPriority = uxNewPriority;
   \   00000048   EF62               STR      R7,[R5, #+44]
    825          					}
    826          
    827          					/* The base priority gets set whatever. */
    828          					pxTCB->uxBasePriority = uxNewPriority;
   \                     ??vTaskPrioritySet_7:
   \   0000004A   6F64               STR      R7,[R5, #+68]
    829          				}
    830          				#else
    831          				{
    832          					pxTCB->uxPriority = uxNewPriority;
    833          				}
    834          				#endif
    835          
    836          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
   \   0000004C   0621               MOVS     R1,#+6
   \   0000004E   C91B               SUBS     R1,R1,R7
   \   00000050   A961               STR      R1,[R5, #+24]
    837          
    838          				/* If the task is in the blocked or suspended list we need do
    839          				nothing more than change it's priority variable. However, if
    840          				the task is in a ready list it needs to be removed and placed
    841          				in the queue appropriate to its new priority. */
    842          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
   \   00000052   6969               LDR      R1,[R5, #+20]
   \   00000054   1422               MOVS     R2,#+20
   \   00000056   5043               MULS     R0,R2,R0
   \   00000058   ....               LDR      R2,??DataTable5_4
   \   0000005A   1018               ADDS     R0,R2,R0
   \   0000005C   8142               CMP      R1,R0
   \   0000005E   14D1               BNE      ??vTaskPrioritySet_8
    843          				{
    844          					/* The task is currently in its ready list - remove before adding
    845          					it to it's new ready list.  As we are in a critical section we
    846          					can do this even if the scheduler is suspended. */
    847          					vListRemove( &( pxTCB->xGenericListItem ) );
   \   00000060   2800               MOVS     R0,R5
   \   00000062   001D               ADDS     R0,R0,#+4
   \   00000064   ........           BL       vListRemove
    848          					prvAddTaskToReadyQueue( pxTCB );
   \   00000068   ....               LDR      R0,??DataTable5_3
   \   0000006A   0068               LDR      R0,[R0, #+0]
   \   0000006C   E96A               LDR      R1,[R5, #+44]
   \   0000006E   8842               CMP      R0,R1
   \   00000070   02D2               BCS      ??vTaskPrioritySet_9
   \   00000072   E86A               LDR      R0,[R5, #+44]
   \   00000074   ....               LDR      R1,??DataTable5_3
   \   00000076   0860               STR      R0,[R1, #+0]
   \                     ??vTaskPrioritySet_9:
   \   00000078   2900               MOVS     R1,R5
   \   0000007A   091D               ADDS     R1,R1,#+4
   \   0000007C   E86A               LDR      R0,[R5, #+44]
   \   0000007E   1422               MOVS     R2,#+20
   \   00000080   5043               MULS     R0,R2,R0
   \   00000082   ....               LDR      R2,??DataTable5_4
   \   00000084   1018               ADDS     R0,R2,R0
   \   00000086   ........           BL       vListInsertEnd
    849          				}
    850          
    851          				if( xYieldRequired == pdTRUE )
   \                     ??vTaskPrioritySet_8:
   \   0000008A   012E               CMP      R6,#+1
   \   0000008C   01D1               BNE      ??vTaskPrioritySet_4
    852          				{
    853          					portYIELD_WITHIN_API();
   \   0000008E   ........           BL       vPortYieldFromISR
    854          				}
    855          			}
    856          		}
    857          		portEXIT_CRITICAL();
   \                     ??vTaskPrioritySet_4:
   \   00000092   ........           BL       vPortExitCritical
    858          	}
   \   00000096   F1BD               POP      {R0,R4-R7,PC}    ;; return
    859          
    860          #endif
    861          /*-----------------------------------------------------------*/
    862          
    863          #if ( INCLUDE_vTaskSuspend == 1 )
    864          

   \                                 In section .text, align 2, keep-with-next
    865          	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
    866          	{
   \                     vTaskSuspend:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
    867          	tskTCB *pxTCB;
    868          
    869          		portENTER_CRITICAL();
   \   00000004   ........           BL       vPortEnterCritical
    870          		{
    871          			/* Ensure a yield is performed if the current task is being
    872          			suspended. */
    873          			if( pxTaskToSuspend == pxCurrentTCB )
   \   00000008   ....               LDR      R0,??DataTable6
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   8542               CMP      R5,R0
   \   0000000E   00D1               BNE      ??vTaskSuspend_0
    874          			{
    875          				pxTaskToSuspend = NULL;
   \   00000010   0025               MOVS     R5,#+0
    876          			}
    877          
    878          			/* If null is passed in here then we are suspending ourselves. */
    879          			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
   \                     ??vTaskSuspend_0:
   \   00000012   002D               CMP      R5,#+0
   \   00000014   02D1               BNE      ??vTaskSuspend_1
   \   00000016   ....               LDR      R0,??DataTable6
   \   00000018   0468               LDR      R4,[R0, #+0]
   \   0000001A   00E0               B        ??vTaskSuspend_2
   \                     ??vTaskSuspend_1:
   \   0000001C   2C00               MOVS     R4,R5
    880          
    881          			traceTASK_SUSPEND( pxTCB );
    882          
    883          			/* Remove task from the ready/delayed list and place in the	suspended list. */
    884          			vListRemove( &( pxTCB->xGenericListItem ) );
   \                     ??vTaskSuspend_2:
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   001D               ADDS     R0,R0,#+4
   \   00000022   ........           BL       vListRemove
    885          
    886          			/* Is the task waiting on an event also? */
    887          			if( pxTCB->xEventListItem.pvContainer )
   \   00000026   A06A               LDR      R0,[R4, #+40]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   03D0               BEQ      ??vTaskSuspend_3
    888          			{
    889          				vListRemove( &( pxTCB->xEventListItem ) );
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   1830               ADDS     R0,R0,#+24
   \   00000030   ........           BL       vListRemove
    890          			}
    891          
    892          			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   \                     ??vTaskSuspend_3:
   \   00000034   241D               ADDS     R4,R4,#+4
   \   00000036   2100               MOVS     R1,R4
   \   00000038   ....               LDR      R0,??DataTable15
   \   0000003A   ........           BL       vListInsertEnd
    893          		}
    894          		portEXIT_CRITICAL();
   \   0000003E   ........           BL       vPortExitCritical
    895          
    896          		/* We may have just suspended the current task. */
    897          		if( ( void * ) pxTaskToSuspend == NULL )
   \   00000042   002D               CMP      R5,#+0
   \   00000044   01D1               BNE      ??vTaskSuspend_4
    898          		{
    899          			portYIELD_WITHIN_API();
   \   00000046   ........           BL       vPortYieldFromISR
    900          		}
    901          	}
   \                     ??vTaskSuspend_4:
   \   0000004A   31BD               POP      {R0,R4,R5,PC}    ;; return
    902          
    903          #endif
    904          /*-----------------------------------------------------------*/
    905          
    906          #if ( INCLUDE_vTaskSuspend == 1 )
    907          

   \                                 In section .text, align 2, keep-with-next
    908          	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
    909          	{
   \                     xTaskIsTaskSuspended:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0100               MOVS     R1,R0
    910          	portBASE_TYPE xReturn = pdFALSE;
   \   00000004   0020               MOVS     R0,#+0
    911          	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    912          
    913          		/* Is the task we are attempting to resume actually in the
    914          		suspended list? */
    915          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   \   00000006   4A69               LDR      R2,[R1, #+20]
   \   00000008   ....               LDR      R3,??DataTable15
   \   0000000A   9A42               CMP      R2,R3
   \   0000000C   07D1               BNE      ??xTaskIsTaskSuspended_0
    916          		{
    917          			/* Has the task already been resumed from within an ISR? */
    918          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
   \   0000000E   8A6A               LDR      R2,[R1, #+40]
   \   00000010   ....               LDR      R3,??DataTable16
   \   00000012   9A42               CMP      R2,R3
   \   00000014   03D0               BEQ      ??xTaskIsTaskSuspended_0
    919          			{
    920          				/* Is it in the suspended list because it is in the
    921          				Suspended state?  It is possible to be in the suspended
    922          				list because it is blocked on a task with no timeout
    923          				specified. */
    924          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
   \   00000016   896A               LDR      R1,[R1, #+40]
   \   00000018   0029               CMP      R1,#+0
   \   0000001A   00D1               BNE      ??xTaskIsTaskSuspended_0
    925          				{
    926          					xReturn = pdTRUE;
   \   0000001C   0120               MOVS     R0,#+1
    927          				}
    928          			}
    929          		}
    930          
    931          		return xReturn;
   \                     ??xTaskIsTaskSuspended_0:
   \   0000001E   00BD               POP      {PC}             ;; return
    932          	}
    933          
    934          #endif
    935          /*-----------------------------------------------------------*/
    936          
    937          #if ( INCLUDE_vTaskSuspend == 1 )
    938          

   \                                 In section .text, align 2, keep-with-next
    939          	void vTaskResume( xTaskHandle pxTaskToResume )
    940          	{
   \                     vTaskResume:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    941          	tskTCB *pxTCB;
    942          
    943          		/* Remove the task from whichever list it is currently in, and place
    944          		it in the ready list. */
    945          		pxTCB = ( tskTCB * ) pxTaskToResume;
    946          
    947          		/* The parameter cannot be NULL as it is impossible to resume the
    948          		currently executing task. */
    949          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   \   00000004   002C               CMP      R4,#+0
   \   00000006   29D0               BEQ      ??vTaskResume_0
   \   00000008   ....               LDR      R0,??DataTable17
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   8442               CMP      R4,R0
   \   0000000E   25D0               BEQ      ??vTaskResume_0
    950          		{
    951          			portENTER_CRITICAL();
   \   00000010   ........           BL       vPortEnterCritical
    952          			{
    953          				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   \   00000014   2000               MOVS     R0,R4
   \   00000016   ........           BL       xTaskIsTaskSuspended
   \   0000001A   0128               CMP      R0,#+1
   \   0000001C   1CD1               BNE      ??vTaskResume_1
    954          				{
    955          					traceTASK_RESUME( pxTCB );
    956          
    957          					/* As we are in a critical section we can access the ready
    958          					lists even if the scheduler is suspended. */
    959          					vListRemove(  &( pxTCB->xGenericListItem ) );
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   001D               ADDS     R0,R0,#+4
   \   00000022   ........           BL       vListRemove
    960          					prvAddTaskToReadyQueue( pxTCB );
   \   00000026   ....               LDR      R0,??DataTable16_1
   \   00000028   0068               LDR      R0,[R0, #+0]
   \   0000002A   E16A               LDR      R1,[R4, #+44]
   \   0000002C   8842               CMP      R0,R1
   \   0000002E   02D2               BCS      ??vTaskResume_2
   \   00000030   E06A               LDR      R0,[R4, #+44]
   \   00000032   ....               LDR      R1,??DataTable16_1
   \   00000034   0860               STR      R0,[R1, #+0]
   \                     ??vTaskResume_2:
   \   00000036   2100               MOVS     R1,R4
   \   00000038   091D               ADDS     R1,R1,#+4
   \   0000003A   E06A               LDR      R0,[R4, #+44]
   \   0000003C   1422               MOVS     R2,#+20
   \   0000003E   5043               MULS     R0,R2,R0
   \   00000040   ....               LDR      R2,??DataTable16_2
   \   00000042   1018               ADDS     R0,R2,R0
   \   00000044   ........           BL       vListInsertEnd
    961          
    962          					/* We may have just resumed a higher priority task. */
    963          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   00000048   E06A               LDR      R0,[R4, #+44]
   \   0000004A   ....               LDR      R1,??DataTable17
   \   0000004C   0968               LDR      R1,[R1, #+0]
   \   0000004E   C96A               LDR      R1,[R1, #+44]
   \   00000050   8842               CMP      R0,R1
   \   00000052   01D3               BCC      ??vTaskResume_1
    964          					{
    965          						/* This yield may not cause the task just resumed to run, but
    966          						will leave the lists in the correct state for the next yield. */
    967          						portYIELD_WITHIN_API();
   \   00000054   ........           BL       vPortYieldFromISR
    968          					}
    969          				}
    970          			}
    971          			portEXIT_CRITICAL();
   \                     ??vTaskResume_1:
   \   00000058   ........           BL       vPortExitCritical
    972          		}
    973          	}
   \                     ??vTaskResume_0:
   \   0000005C   10BD               POP      {R4,PC}          ;; return
    974          
    975          #endif
    976          
    977          /*-----------------------------------------------------------*/
    978          
    979          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
    980          

   \                                 In section .text, align 2, keep-with-next
    981          	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
    982          	{
   \                     xTaskResumeFromISR:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    983          	portBASE_TYPE xYieldRequired = pdFALSE;
   \   00000002   0025               MOVS     R5,#+0
    984          	tskTCB *pxTCB;
    985          
    986          		pxTCB = ( tskTCB * ) pxTaskToResume;
   \   00000004   0400               MOVS     R4,R0
    987          
    988          		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       xTaskIsTaskSuspended
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   28D1               BNE      ??xTaskResumeFromISR_0
    989          		{
    990          			traceTASK_RESUME_FROM_ISR( pxTCB );
    991          
    992          			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000010   ....               LDR      R0,??DataTable16_3
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   1FD1               BNE      ??xTaskResumeFromISR_1
    993          			{
    994          				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
   \   00000018   E06A               LDR      R0,[R4, #+44]
   \   0000001A   ....               LDR      R1,??DataTable17
   \   0000001C   0968               LDR      R1,[R1, #+0]
   \   0000001E   C96A               LDR      R1,[R1, #+44]
   \   00000020   8842               CMP      R0,R1
   \   00000022   01D3               BCC      ??xTaskResumeFromISR_2
   \   00000024   0125               MOVS     R5,#+1
   \   00000026   00E0               B        ??xTaskResumeFromISR_3
   \                     ??xTaskResumeFromISR_2:
   \   00000028   0025               MOVS     R5,#+0
   \                     ??xTaskResumeFromISR_3:
   \   0000002A   EDB2               UXTB     R5,R5
    995          				vListRemove(  &( pxTCB->xGenericListItem ) );
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   001D               ADDS     R0,R0,#+4
   \   00000030   ........           BL       vListRemove
    996          				prvAddTaskToReadyQueue( pxTCB );
   \   00000034   ....               LDR      R0,??DataTable16_1
   \   00000036   0068               LDR      R0,[R0, #+0]
   \   00000038   E16A               LDR      R1,[R4, #+44]
   \   0000003A   8842               CMP      R0,R1
   \   0000003C   02D2               BCS      ??xTaskResumeFromISR_4
   \   0000003E   E06A               LDR      R0,[R4, #+44]
   \   00000040   ....               LDR      R1,??DataTable16_1
   \   00000042   0860               STR      R0,[R1, #+0]
   \                     ??xTaskResumeFromISR_4:
   \   00000044   2100               MOVS     R1,R4
   \   00000046   091D               ADDS     R1,R1,#+4
   \   00000048   E06A               LDR      R0,[R4, #+44]
   \   0000004A   1422               MOVS     R2,#+20
   \   0000004C   5043               MULS     R0,R2,R0
   \   0000004E   ....               LDR      R2,??DataTable16_2
   \   00000050   1018               ADDS     R0,R2,R0
   \   00000052   ........           BL       vListInsertEnd
   \   00000056   04E0               B        ??xTaskResumeFromISR_0
    997          			}
    998          			else
    999          			{
   1000          				/* We cannot access the delayed or ready lists, so will hold this
   1001          				task pending until the scheduler is resumed, at which point a
   1002          				yield will be performed if necessary. */
   1003          				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskResumeFromISR_1:
   \   00000058   1834               ADDS     R4,R4,#+24
   \   0000005A   2100               MOVS     R1,R4
   \   0000005C   ....               LDR      R0,??DataTable16
   \   0000005E   ........           BL       vListInsertEnd
   1004          			}
   1005          		}
   1006          
   1007          		return xYieldRequired;
   \                     ??xTaskResumeFromISR_0:
   \   00000062   2800               MOVS     R0,R5
   \   00000064   32BD               POP      {R1,R4,R5,PC}    ;; return
   1008          	}
   1009          
   1010          #endif
   1011          
   1012          
   1013          
   1014          
   1015          /*-----------------------------------------------------------
   1016           * PUBLIC SCHEDULER CONTROL documented in task.h
   1017           *----------------------------------------------------------*/
   1018          
   1019          

   \                                 In section .text, align 2, keep-with-next
   1020          void vTaskStartScheduler( void )
   1021          {
   \                     vTaskStartScheduler:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   1022          portBASE_TYPE xReturn;
   1023          
   1024          	/* Add the idle task at the lowest priority. */
   1025          	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0390               STR      R0,[SP, #+12]
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0290               STR      R0,[SP, #+8]
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   0190               STR      R0,[SP, #+4]
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   0090               STR      R0,[SP, #+0]
   \   00000014   0023               MOVS     R3,#+0
   \   00000016   8022               MOVS     R2,#+128
   \   00000018   ....               LDR      R1,??DataTable18
   \   0000001A   ....               LDR      R0,??DataTable18_1
   \   0000001C   ........           BL       xTaskGenericCreate
   1026          
   1027          	if( xReturn == pdPASS )
   \   00000020   0128               CMP      R0,#+1
   \   00000022   09D1               BNE      ??vTaskStartScheduler_0
   1028          	{
   1029          		/* Interrupts are turned off here, to ensure a tick does not occur
   1030          		before or during the call to xPortStartScheduler().  The stacks of
   1031          		the created tasks contain a status word with interrupts switched on
   1032          		so interrupts will automatically get re-enabled when the first task
   1033          		starts to run.
   1034          
   1035          		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
   1036          		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
   1037          		portDISABLE_INTERRUPTS();
   \   00000024   ........           BL       vPortSetInterruptMask
   1038          
   1039          		xSchedulerRunning = pdTRUE;
   \   00000028   ....               LDR      R0,??DataTable18_2
   \   0000002A   0121               MOVS     R1,#+1
   \   0000002C   0160               STR      R1,[R0, #+0]
   1040          		xTickCount = ( portTickType ) 0;
   \   0000002E   ....               LDR      R0,??DataTable20
   \   00000030   0021               MOVS     R1,#+0
   \   00000032   0160               STR      R1,[R0, #+0]
   1041          
   1042          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1043          		macro must be defined to configure the timer/counter used to generate
   1044          		the run time counter time base. */
   1045          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1046          
   1047          		/* Setting up the timer tick is hardware specific and thus in the
   1048          		portable interface. */
   1049          		if( xPortStartScheduler() )
   \   00000034   ........           BL       xPortStartScheduler
   1050          		{
   1051          			/* Should not reach here as if the scheduler is running the
   1052          			function will not return. */
   1053          		}
   1054          		else
   1055          		{
   1056          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1057          		}
   1058          	}
   1059          }
   \                     ??vTaskStartScheduler_0:
   \   00000038   05B0               ADD      SP,SP,#+20
   \   0000003A   00BD               POP      {PC}             ;; return
   1060          /*-----------------------------------------------------------*/
   1061          

   \                                 In section .text, align 2, keep-with-next
   1062          void vTaskEndScheduler( void )
   1063          {
   \                     vTaskEndScheduler:
   \   00000000   80B5               PUSH     {R7,LR}
   1064          	/* Stop the scheduler interrupts and call the portable scheduler end
   1065          	routine so the original ISRs can be restored if necessary.  The port
   1066          	layer must ensure interrupts enable	bit is left in the correct state. */
   1067          	portDISABLE_INTERRUPTS();
   \   00000002   ........           BL       vPortSetInterruptMask
   1068          	xSchedulerRunning = pdFALSE;
   \   00000006   ....               LDR      R0,??DataTable18_2
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   0160               STR      R1,[R0, #+0]
   1069          	vPortEndScheduler();
   \   0000000C   ........           BL       vPortEndScheduler
   1070          }
   \   00000010   01BD               POP      {R0,PC}          ;; return
   1071          /*----------------------------------------------------------*/
   1072          

   \                                 In section .text, align 2, keep-with-next
   1073          void vTaskSuspendAll( void )
   1074          {
   1075          	/* A critical section is not required as the variable is of type
   1076          	portBASE_TYPE. */
   1077          	++uxSchedulerSuspended;
   \                     vTaskSuspendAll:
   \   00000000   ....               LDR      R0,??DataTable16_3
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   401C               ADDS     R0,R0,#+1
   \   00000006   ....               LDR      R1,??DataTable16_3
   \   00000008   0860               STR      R0,[R1, #+0]
   1078          }
   \   0000000A   7047               BX       LR               ;; return
   1079          /*----------------------------------------------------------*/
   1080          

   \                                 In section .text, align 2, keep-with-next
   1081          signed portBASE_TYPE xTaskResumeAll( void )
   1082          {
   \                     xTaskResumeAll:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   1083          register tskTCB *pxTCB;
   1084          signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   \   00000002   0026               MOVS     R6,#+0
   1085          
   1086          	/* It is possible that an ISR caused a task to be removed from an event
   1087          	list while the scheduler was suspended.  If this was the case then the
   1088          	removed task will have been added to the xPendingReadyList.  Once the
   1089          	scheduler has been resumed it is safe to move all the pending ready
   1090          	tasks from this list into their appropriate ready list. */
   1091          	portENTER_CRITICAL();
   \   00000004   ........           BL       vPortEnterCritical
   1092          	{
   1093          		--uxSchedulerSuspended;
   \   00000008   ....               LDR      R0,??DataTable16_3
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   401E               SUBS     R0,R0,#+1
   \   0000000E   ....               LDR      R1,??DataTable16_3
   \   00000010   0860               STR      R0,[R1, #+0]
   1094          
   1095          		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000012   ....               LDR      R0,??DataTable16_3
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   0028               CMP      R0,#+0
   \   00000018   4DD1               BNE      ??xTaskResumeAll_0
   1096          		{
   1097          			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
   \   0000001A   ....               LDR      R0,??DataTable18_3
   \   0000001C   0068               LDR      R0,[R0, #+0]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   49D0               BEQ      ??xTaskResumeAll_0
   1098          			{
   1099          				portBASE_TYPE xYieldRequired = pdFALSE;
   \   00000022   0024               MOVS     R4,#+0
   \   00000024   1FE0               B        ??xTaskResumeAll_1
   1100          
   1101          				/* Move any readied tasks from the pending list into the
   1102          				appropriate ready list. */
   1103          				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
   1104          				{
   1105          					vListRemove( &( pxTCB->xEventListItem ) );
   \                     ??xTaskResumeAll_2:
   \   00000026   2800               MOVS     R0,R5
   \   00000028   1830               ADDS     R0,R0,#+24
   \   0000002A   ........           BL       vListRemove
   1106          					vListRemove( &( pxTCB->xGenericListItem ) );
   \   0000002E   2800               MOVS     R0,R5
   \   00000030   001D               ADDS     R0,R0,#+4
   \   00000032   ........           BL       vListRemove
   1107          					prvAddTaskToReadyQueue( pxTCB );
   \   00000036   ....               LDR      R0,??DataTable16_1
   \   00000038   0068               LDR      R0,[R0, #+0]
   \   0000003A   E96A               LDR      R1,[R5, #+44]
   \   0000003C   8842               CMP      R0,R1
   \   0000003E   02D2               BCS      ??xTaskResumeAll_3
   \   00000040   E86A               LDR      R0,[R5, #+44]
   \   00000042   ....               LDR      R1,??DataTable16_1
   \   00000044   0860               STR      R0,[R1, #+0]
   \                     ??xTaskResumeAll_3:
   \   00000046   2900               MOVS     R1,R5
   \   00000048   091D               ADDS     R1,R1,#+4
   \   0000004A   E86A               LDR      R0,[R5, #+44]
   \   0000004C   1422               MOVS     R2,#+20
   \   0000004E   5043               MULS     R0,R2,R0
   \   00000050   ....               LDR      R2,??DataTable16_2
   \   00000052   1018               ADDS     R0,R2,R0
   \   00000054   ........           BL       vListInsertEnd
   1108          
   1109          					/* If we have moved a task that has a priority higher than
   1110          					the current task then we should yield. */
   1111          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   00000058   E86A               LDR      R0,[R5, #+44]
   \   0000005A   ....               LDR      R1,??DataTable17
   \   0000005C   0968               LDR      R1,[R1, #+0]
   \   0000005E   C96A               LDR      R1,[R1, #+44]
   \   00000060   8842               CMP      R0,R1
   \   00000062   00D3               BCC      ??xTaskResumeAll_1
   1112          					{
   1113          						xYieldRequired = pdTRUE;
   \   00000064   0124               MOVS     R4,#+1
   1114          					}
   1115          				}
   \                     ??xTaskResumeAll_1:
   \   00000066   ....               LDR      R0,??DataTable16
   \   00000068   0068               LDR      R0,[R0, #+0]
   \   0000006A   0028               CMP      R0,#+0
   \   0000006C   03D0               BEQ      ??xTaskResumeAll_4
   \   0000006E   ....               LDR      R0,??DataTable16
   \   00000070   C068               LDR      R0,[R0, #+12]
   \   00000072   C568               LDR      R5,[R0, #+12]
   \   00000074   00E0               B        ??xTaskResumeAll_5
   \                     ??xTaskResumeAll_4:
   \   00000076   0025               MOVS     R5,#+0
   \                     ??xTaskResumeAll_5:
   \   00000078   002D               CMP      R5,#+0
   \   0000007A   D4D1               BNE      ??xTaskResumeAll_2
   1116          
   1117          				/* If any ticks occurred while the scheduler was suspended then
   1118          				they should be processed now.  This ensures the tick count does not
   1119          				slip, and that any delayed tasks are resumed at the correct time. */
   1120          				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
   \   0000007C   ....               LDR      R0,??DataTable23
   \   0000007E   0068               LDR      R0,[R0, #+0]
   \   00000080   0028               CMP      R0,#+0
   \   00000082   07D1               BNE      ??xTaskResumeAll_6
   \   00000084   0BE0               B        ??xTaskResumeAll_7
   1121          				{
   1122          					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
   1123          					{
   1124          						vTaskIncrementTick();
   \                     ??xTaskResumeAll_8:
   \   00000086   ........           BL       vTaskIncrementTick
   1125          						--uxMissedTicks;
   \   0000008A   ....               LDR      R0,??DataTable23
   \   0000008C   0068               LDR      R0,[R0, #+0]
   \   0000008E   401E               SUBS     R0,R0,#+1
   \   00000090   ....               LDR      R1,??DataTable23
   \   00000092   0860               STR      R0,[R1, #+0]
   1126          					}
   \                     ??xTaskResumeAll_6:
   \   00000094   ....               LDR      R0,??DataTable23
   \   00000096   0068               LDR      R0,[R0, #+0]
   \   00000098   0028               CMP      R0,#+0
   \   0000009A   F4D1               BNE      ??xTaskResumeAll_8
   1127          
   1128          					/* As we have processed some ticks it is appropriate to yield
   1129          					to ensure the highest priority task that is ready to run is
   1130          					the task actually running. */
   1131          					#if configUSE_PREEMPTION == 1
   1132          					{
   1133          						xYieldRequired = pdTRUE;
   \   0000009C   0124               MOVS     R4,#+1
   1134          					}
   1135          					#endif
   1136          				}
   1137          
   1138          				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
   \                     ??xTaskResumeAll_7:
   \   0000009E   012C               CMP      R4,#+1
   \   000000A0   03D0               BEQ      ??xTaskResumeAll_9
   \   000000A2   ....               LDR      R0,??DataTable23_1
   \   000000A4   0068               LDR      R0,[R0, #+0]
   \   000000A6   0128               CMP      R0,#+1
   \   000000A8   05D1               BNE      ??xTaskResumeAll_0
   1139          				{
   1140          					xAlreadyYielded = pdTRUE;
   \                     ??xTaskResumeAll_9:
   \   000000AA   0126               MOVS     R6,#+1
   1141          					xMissedYield = pdFALSE;
   \   000000AC   ....               LDR      R0,??DataTable23_1
   \   000000AE   0021               MOVS     R1,#+0
   \   000000B0   0160               STR      R1,[R0, #+0]
   1142          					portYIELD_WITHIN_API();
   \   000000B2   ........           BL       vPortYieldFromISR
   1143          				}
   1144          			}
   1145          		}
   1146          	}
   1147          	portEXIT_CRITICAL();
   \                     ??xTaskResumeAll_0:
   \   000000B6   ........           BL       vPortExitCritical
   1148          
   1149          	return xAlreadyYielded;
   \   000000BA   3000               MOVS     R0,R6
   \   000000BC   70BD               POP      {R4-R6,PC}       ;; return
   1150          }
   1151          
   1152          
   1153          
   1154          
   1155          
   1156          
   1157          /*-----------------------------------------------------------
   1158           * PUBLIC TASK UTILITIES documented in task.h
   1159           *----------------------------------------------------------*/
   1160          
   1161          
   1162          

   \                                 In section .text, align 2, keep-with-next
   1163          portTickType xTaskGetTickCount( void )
   1164          {
   \                     xTaskGetTickCount:
   \   00000000   10B5               PUSH     {R4,LR}
   1165          portTickType xTicks;
   1166          
   1167          	/* Critical section required if running on a 16 bit processor. */
   1168          	portENTER_CRITICAL();
   \   00000002   ........           BL       vPortEnterCritical
   1169          	{
   1170          		xTicks = xTickCount;
   \   00000006   ....               LDR      R0,??DataTable23_2
   \   00000008   0468               LDR      R4,[R0, #+0]
   1171          	}
   1172          	portEXIT_CRITICAL();
   \   0000000A   ........           BL       vPortExitCritical
   1173          
   1174          	return xTicks;
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   10BD               POP      {R4,PC}          ;; return
   1175          }
   1176          /*-----------------------------------------------------------*/
   1177          

   \                                 In section .text, align 2, keep-with-next
   1178          unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
   1179          {
   1180          	/* A critical section is not required because the variables are of type
   1181          	portBASE_TYPE. */
   1182          	return uxCurrentNumberOfTasks;
   \                     uxTaskGetNumberOfTasks:
   \   00000000   ....               LDR      R0,??DataTable18_3
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
   1183          }
   1184          /*-----------------------------------------------------------*/
   1185          
   1186          #if ( configUSE_TRACE_FACILITY == 1 )
   1187          
   1188          	void vTaskList( signed char *pcWriteBuffer )
   1189          	{
   1190          	unsigned portBASE_TYPE uxQueue;
   1191          
   1192          		/* This is a VERY costly function that should be used for debug only.
   1193          		It leaves interrupts disabled for a LONG time. */
   1194          
   1195          		vTaskSuspendAll();
   1196          		{
   1197          			/* Run through all the lists that could potentially contain a TCB and
   1198          			report the task name, state and stack high water mark. */
   1199          
   1200          			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
   1201          			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   1202          
   1203          			uxQueue = uxTopUsedPriority + 1;
   1204          
   1205          			do
   1206          			{
   1207          				uxQueue--;
   1208          
   1209          				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
   1210          				{
   1211          					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
   1212          				}
   1213          			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   1214          
   1215          			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
   1216          			{
   1217          				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
   1218          			}
   1219          
   1220          			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
   1221          			{
   1222          				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
   1223          			}
   1224          
   1225          			#if( INCLUDE_vTaskDelete == 1 )
   1226          			{
   1227          				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
   1228          				{
   1229          					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_CHAR );
   1230          				}
   1231          			}
   1232          			#endif
   1233          
   1234          			#if ( INCLUDE_vTaskSuspend == 1 )
   1235          			{
   1236          				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
   1237          				{
   1238          					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
   1239          				}
   1240          			}
   1241          			#endif
   1242          		}
   1243          		xTaskResumeAll();
   1244          	}
   1245          
   1246          #endif
   1247          /*----------------------------------------------------------*/
   1248          
   1249          #if ( configGENERATE_RUN_TIME_STATS == 1 )
   1250          
   1251          	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
   1252          	{
   1253          	unsigned portBASE_TYPE uxQueue;
   1254          	unsigned long ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1255          
   1256          		/* This is a VERY costly function that should be used for debug only.
   1257          		It leaves interrupts disabled for a LONG time. */
   1258          
   1259          		vTaskSuspendAll();
   1260          		{
   1261          			/* Run through all the lists that could potentially contain a TCB,
   1262          			generating a table of run timer percentages in the provided
   1263          			buffer. */
   1264          
   1265          			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
   1266          			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   1267          
   1268          			uxQueue = uxTopUsedPriority + 1;
   1269          
   1270          			do
   1271          			{
   1272          				uxQueue--;
   1273          
   1274          				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
   1275          				{
   1276          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
   1277          				}
   1278          			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   1279          
   1280          			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
   1281          			{
   1282          				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRunTime );
   1283          			}
   1284          
   1285          			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
   1286          			{
   1287          				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ulTotalRunTime );
   1288          			}
   1289          
   1290          			#if ( INCLUDE_vTaskDelete == 1 )
   1291          			{
   1292          				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
   1293          				{
   1294          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, ulTotalRunTime );
   1295          				}
   1296          			}
   1297          			#endif
   1298          
   1299          			#if ( INCLUDE_vTaskSuspend == 1 )
   1300          			{
   1301          				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
   1302          				{
   1303          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, ulTotalRunTime );
   1304          				}
   1305          			}
   1306          			#endif
   1307          		}
   1308          		xTaskResumeAll();
   1309          	}
   1310          
   1311          #endif
   1312          /*----------------------------------------------------------*/
   1313          
   1314          #if ( configUSE_TRACE_FACILITY == 1 )
   1315          
   1316          	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
   1317          	{
   1318          		portENTER_CRITICAL();
   1319          		{
   1320          			pcTraceBuffer = ( signed char * )pcBuffer;
   1321          			pcTraceBufferStart = pcBuffer;
   1322          			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
   1323          			xTracing = pdTRUE;
   1324          		}
   1325          		portEXIT_CRITICAL();
   1326          	}
   1327          
   1328          #endif
   1329          /*----------------------------------------------------------*/
   1330          
   1331          #if ( configUSE_TRACE_FACILITY == 1 )
   1332          
   1333          	unsigned long ulTaskEndTrace( void )
   1334          	{
   1335          	unsigned long ulBufferLength;
   1336          
   1337          		portENTER_CRITICAL();
   1338          			xTracing = pdFALSE;
   1339          		portEXIT_CRITICAL();
   1340          
   1341          		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
   1342          
   1343          		return ulBufferLength;
   1344          	}
   1345          
   1346          #endif
   1347          
   1348          
   1349          
   1350          /*-----------------------------------------------------------
   1351           * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
   1352           * documented in task.h
   1353           *----------------------------------------------------------*/
   1354          
   1355          

   \                                 In section .text, align 2, keep-with-next
   1356          void vTaskIncrementTick( void )
   1357          {
   \                     vTaskIncrementTick:
   \   00000000   10B5               PUSH     {R4,LR}
   1358          	/* Called by the portable layer each time a tick interrupt occurs.
   1359          	Increments the tick then checks to see if the new tick value will cause any
   1360          	tasks to be unblocked. */
   1361          	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000002   ....               LDR      R0,??DataTable16_3
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   45D1               BNE      ??vTaskIncrementTick_0
   1362          	{
   1363          		++xTickCount;
   \   0000000A   ....               LDR      R0,??DataTable20
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   401C               ADDS     R0,R0,#+1
   \   00000010   ....               LDR      R1,??DataTable20
   \   00000012   0860               STR      R0,[R1, #+0]
   1364          		if( xTickCount == ( portTickType ) 0 )
   \   00000014   ....               LDR      R0,??DataTable20
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   0CD1               BNE      ??vTaskIncrementTick_1
   1365          		{
   1366          			xList *pxTemp;
   1367          
   1368          			/* Tick count has overflowed so we need to swap the delay lists.
   1369          			If there are any items in pxDelayedTaskList here then there is
   1370          			an error! */
   1371          			pxTemp = pxDelayedTaskList;
   \   0000001C   ....               LDR      R0,??DataTable23_3
   \   0000001E   0068               LDR      R0,[R0, #+0]
   1372          			pxDelayedTaskList = pxOverflowDelayedTaskList;
   \   00000020   ....               LDR      R1,??DataTable23_3
   \   00000022   ....               LDR      R2,??DataTable23_4
   \   00000024   1268               LDR      R2,[R2, #+0]
   \   00000026   0A60               STR      R2,[R1, #+0]
   1373          			pxOverflowDelayedTaskList = pxTemp;
   \   00000028   ....               LDR      R1,??DataTable23_4
   \   0000002A   0860               STR      R0,[R1, #+0]
   1374          			xNumOfOverflows++;
   \   0000002C   ....               LDR      R0,??DataTable23_5
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   401C               ADDS     R0,R0,#+1
   \   00000032   ....               LDR      R1,??DataTable23_5
   \   00000034   0860               STR      R0,[R1, #+0]
   \                     ??vTaskIncrementTick_1:
   \   00000036   1BE0               B        ??vTaskIncrementTick_2
   1375          		}
   1376          
   1377          		/* See if this tick has made a timeout expire. */
   1378          		prvCheckDelayedTasks();
   \                     ??vTaskIncrementTick_3:
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   001D               ADDS     R0,R0,#+4
   \   0000003C   ........           BL       vListRemove
   \   00000040   A06A               LDR      R0,[R4, #+40]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   03D0               BEQ      ??vTaskIncrementTick_4
   \   00000046   2000               MOVS     R0,R4
   \   00000048   1830               ADDS     R0,R0,#+24
   \   0000004A   ........           BL       vListRemove
   \                     ??vTaskIncrementTick_4:
   \   0000004E   ....               LDR      R0,??DataTable16_1
   \   00000050   0068               LDR      R0,[R0, #+0]
   \   00000052   E16A               LDR      R1,[R4, #+44]
   \   00000054   8842               CMP      R0,R1
   \   00000056   02D2               BCS      ??vTaskIncrementTick_5
   \   00000058   E06A               LDR      R0,[R4, #+44]
   \   0000005A   ....               LDR      R1,??DataTable16_1
   \   0000005C   0860               STR      R0,[R1, #+0]
   \                     ??vTaskIncrementTick_5:
   \   0000005E   2100               MOVS     R1,R4
   \   00000060   091D               ADDS     R1,R1,#+4
   \   00000062   E06A               LDR      R0,[R4, #+44]
   \   00000064   1422               MOVS     R2,#+20
   \   00000066   5043               MULS     R0,R2,R0
   \   00000068   ....               LDR      R2,??DataTable16_2
   \   0000006A   1018               ADDS     R0,R2,R0
   \   0000006C   ........           BL       vListInsertEnd
   \                     ??vTaskIncrementTick_2:
   \   00000070   ....               LDR      R0,??DataTable23_3
   \   00000072   0068               LDR      R0,[R0, #+0]
   \   00000074   0068               LDR      R0,[R0, #+0]
   \   00000076   0028               CMP      R0,#+0
   \   00000078   04D0               BEQ      ??vTaskIncrementTick_6
   \   0000007A   ....               LDR      R0,??DataTable23_3
   \   0000007C   0068               LDR      R0,[R0, #+0]
   \   0000007E   C068               LDR      R0,[R0, #+12]
   \   00000080   C468               LDR      R4,[R0, #+12]
   \   00000082   00E0               B        ??vTaskIncrementTick_7
   \                     ??vTaskIncrementTick_6:
   \   00000084   0024               MOVS     R4,#+0
   \                     ??vTaskIncrementTick_7:
   \   00000086   002C               CMP      R4,#+0
   \   00000088   0AD0               BEQ      ??vTaskIncrementTick_8
   \   0000008A   ....               LDR      R0,??DataTable20
   \   0000008C   0068               LDR      R0,[R0, #+0]
   \   0000008E   6168               LDR      R1,[R4, #+4]
   \   00000090   8842               CMP      R0,R1
   \   00000092   D1D2               BCS      ??vTaskIncrementTick_3
   \   00000094   04E0               B        ??vTaskIncrementTick_8
   1379          	}
   1380          	else
   1381          	{
   1382          		++uxMissedTicks;
   \                     ??vTaskIncrementTick_0:
   \   00000096   ....               LDR      R0,??DataTable23
   \   00000098   0068               LDR      R0,[R0, #+0]
   \   0000009A   401C               ADDS     R0,R0,#+1
   \   0000009C   ....               LDR      R1,??DataTable23
   \   0000009E   0860               STR      R0,[R1, #+0]
   1383          
   1384          		/* The tick hook gets called at regular intervals, even if the
   1385          		scheduler is locked. */
   1386          		#if ( configUSE_TICK_HOOK == 1 )
   1387          		{
   1388          			extern void vApplicationTickHook( void );
   1389          
   1390          			vApplicationTickHook();
   1391          		}
   1392          		#endif
   1393          	}
   1394          
   1395          	#if ( configUSE_TICK_HOOK == 1 )
   1396          	{
   1397          		extern void vApplicationTickHook( void );
   1398          
   1399          		/* Guard against the tick hook being called when the missed tick
   1400          		count is being unwound (when the scheduler is being unlocked. */
   1401          		if( uxMissedTicks == 0 )
   1402          		{
   1403          			vApplicationTickHook();
   1404          		}
   1405          	}
   1406          	#endif
   1407          
   1408          	traceTASK_INCREMENT_TICK( xTickCount );
   1409          }
   \                     ??vTaskIncrementTick_8:
   \   000000A0   10BD               POP      {R4,PC}          ;; return
   1410          /*-----------------------------------------------------------*/
   1411          
   1412          #if ( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1413          
   1414          	void vTaskCleanUpResources( void )
   1415          	{
   1416          	unsigned short usQueue;
   1417          	volatile tskTCB *pxTCB;
   1418          
   1419          		usQueue = ( unsigned short ) uxTopUsedPriority + ( unsigned short ) 1;
   1420          
   1421          		/* Remove any TCB's from the ready queues. */
   1422          		do
   1423          		{
   1424          			usQueue--;
   1425          
   1426          			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
   1427          			{
   1428          				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) );
   1429          				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
   1430          
   1431          				prvDeleteTCB( ( tskTCB * ) pxTCB );
   1432          			}
   1433          		}while( usQueue > ( unsigned short ) tskIDLE_PRIORITY );
   1434          
   1435          		/* Remove any TCB's from the delayed queue. */
   1436          		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
   1437          		{
   1438          			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
   1439          			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
   1440          
   1441          			prvDeleteTCB( ( tskTCB * ) pxTCB );
   1442          		}
   1443          
   1444          		/* Remove any TCB's from the overflow delayed queue. */
   1445          		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
   1446          		{
   1447          			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
   1448          			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
   1449          
   1450          			prvDeleteTCB( ( tskTCB * ) pxTCB );
   1451          		}
   1452          
   1453          		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
   1454          		{
   1455          			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
   1456          			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
   1457          
   1458          			prvDeleteTCB( ( tskTCB * ) pxTCB );
   1459          		}
   1460          	}
   1461          
   1462          #endif
   1463          /*-----------------------------------------------------------*/
   1464          
   1465          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1466          
   1467          	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxTagValue )
   1468          	{
   1469          	tskTCB *xTCB;
   1470          
   1471          		/* If xTask is NULL then we are setting our own task hook. */
   1472          		if( xTask == NULL )
   1473          		{
   1474          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1475          		}
   1476          		else
   1477          		{
   1478          			xTCB = ( tskTCB * ) xTask;
   1479          		}
   1480          
   1481          		/* Save the hook function in the TCB.  A critical section is required as
   1482          		the value can be accessed from an interrupt. */
   1483          		portENTER_CRITICAL();
   1484          			xTCB->pxTaskTag = pxTagValue;
   1485          		portEXIT_CRITICAL();
   1486          	}
   1487          
   1488          #endif
   1489          /*-----------------------------------------------------------*/
   1490          
   1491          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1492          
   1493          	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
   1494          	{
   1495          	tskTCB *xTCB;
   1496          	pdTASK_HOOK_CODE xReturn;
   1497          
   1498          		/* If xTask is NULL then we are setting our own task hook. */
   1499          		if( xTask == NULL )
   1500          		{
   1501          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1502          		}
   1503          		else
   1504          		{
   1505          			xTCB = ( tskTCB * ) xTask;
   1506          		}
   1507          
   1508          		/* Save the hook function in the TCB.  A critical section is required as
   1509          		the value can be accessed from an interrupt. */
   1510          		portENTER_CRITICAL();
   1511          			xReturn = xTCB->pxTaskTag;
   1512          		portEXIT_CRITICAL();
   1513          
   1514          		return xReturn;
   1515          	}
   1516          
   1517          #endif
   1518          /*-----------------------------------------------------------*/
   1519          
   1520          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1521          
   1522          	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
   1523          	{
   1524          	tskTCB *xTCB;
   1525          	portBASE_TYPE xReturn;
   1526          
   1527          		/* If xTask is NULL then we are calling our own task hook. */
   1528          		if( xTask == NULL )
   1529          		{
   1530          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1531          		}
   1532          		else
   1533          		{
   1534          			xTCB = ( tskTCB * ) xTask;
   1535          		}
   1536          
   1537          		if( xTCB->pxTaskTag != NULL )
   1538          		{
   1539          			xReturn = xTCB->pxTaskTag( pvParameter );
   1540          		}
   1541          		else
   1542          		{
   1543          			xReturn = pdFAIL;
   1544          		}
   1545          
   1546          		return xReturn;
   1547          	}
   1548          
   1549          #endif
   1550          /*-----------------------------------------------------------*/
   1551          

   \                                 In section .text, align 2, keep-with-next
   1552          void vTaskSwitchContext( void )
   1553          {
   \                     vTaskSwitchContext:
   \   00000000   00B5               PUSH     {LR}
   1554          	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000002   ....               LDR      R0,??DataTable24
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   08D0               BEQ      ??vTaskSwitchContext_0
   1555          	{
   1556          		/* The scheduler is currently suspended - do not allow a context
   1557          		switch. */
   1558          		xMissedYield = pdTRUE;
   \   0000000A   ....               LDR      R0,??DataTable23_1
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   0160               STR      R1,[R0, #+0]
   1559          		return;
   \   00000010   21E0               B        ??vTaskSwitchContext_1
   1560          	}
   1561          
   1562          	traceTASK_SWITCHED_OUT();
   1563          
   1564          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   1565          	{
   1566          		unsigned long ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
   1567          
   1568          			/* Add the amount of time the task has been running to the accumulated
   1569          			time so far.  The time the task started running was stored in
   1570          			ulTaskSwitchedInTime.  Note that there is no overflow protection here
   1571          			so count values are only valid until the timer overflows.  Generally
   1572          			this will be about 1 hour assuming a 1uS timer increment. */
   1573          			pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
   1574          			ulTaskSwitchedInTime = ulTempCounter;
   1575          	}
   1576          	#endif
   1577          
   1578          	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   1579          	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   1580          
   1581          	/* Find the highest priority queue that contains ready tasks. */
   1582          	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
   1583          	{
   1584          		--uxTopReadyPriority;
   \                     ??vTaskSwitchContext_2:
   \   00000012   ....               LDR      R0,??DataTable24_1
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   401E               SUBS     R0,R0,#+1
   \   00000018   ....               LDR      R1,??DataTable24_1
   \   0000001A   0860               STR      R0,[R1, #+0]
   1585          	}
   \                     ??vTaskSwitchContext_0:
   \   0000001C   ....               LDR      R0,??DataTable24_1
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   1421               MOVS     R1,#+20
   \   00000022   4843               MULS     R0,R1,R0
   \   00000024   ....               LDR      R1,??DataTable24_2
   \   00000026   0858               LDR      R0,[R1, R0]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   F2D0               BEQ      ??vTaskSwitchContext_2
   1586          
   1587          	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
   1588          	same priority get an equal share of the processor time. */
   1589          	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
   \   0000002C   ....               LDR      R0,??DataTable24_1
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   1421               MOVS     R1,#+20
   \   00000032   4843               MULS     R0,R1,R0
   \   00000034   ....               LDR      R1,??DataTable24_2
   \   00000036   0818               ADDS     R0,R1,R0
   \   00000038   4168               LDR      R1,[R0, #+4]
   \   0000003A   4968               LDR      R1,[R1, #+4]
   \   0000003C   4160               STR      R1,[R0, #+4]
   \   0000003E   4168               LDR      R1,[R0, #+4]
   \   00000040   0200               MOVS     R2,R0
   \   00000042   0832               ADDS     R2,R2,#+8
   \   00000044   9142               CMP      R1,R2
   \   00000046   02D1               BNE      ??vTaskSwitchContext_3
   \   00000048   4168               LDR      R1,[R0, #+4]
   \   0000004A   4968               LDR      R1,[R1, #+4]
   \   0000004C   4160               STR      R1,[R0, #+4]
   \                     ??vTaskSwitchContext_3:
   \   0000004E   4068               LDR      R0,[R0, #+4]
   \   00000050   C068               LDR      R0,[R0, #+12]
   \   00000052   ....               LDR      R1,??DataTable25
   \   00000054   0860               STR      R0,[R1, #+0]
   1590          
   1591          	traceTASK_SWITCHED_IN();
   1592          	vWriteTraceToBuffer();
   1593          }
   \                     ??vTaskSwitchContext_1:
   \   00000056   00BD               POP      {PC}             ;; return
   1594          /*-----------------------------------------------------------*/
   1595          

   \                                 In section .text, align 2, keep-with-next
   1596          void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
   1597          {
   \                     vTaskPlaceOnEventList:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
   1598          portTickType xTimeToWake;
   1599          
   1600          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   1601          	SCHEDULER SUSPENDED. */
   1602          
   1603          	/* Place the event list item of the TCB in the appropriate event list.
   1604          	This is placed in the list in priority order so the highest priority task
   1605          	is the first to be woken by the event. */
   1606          	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   \   00000004   ....               LDR      R1,??DataTable25
   \   00000006   0968               LDR      R1,[R1, #+0]
   \   00000008   1831               ADDS     R1,R1,#+24
   \   0000000A   ........           BL       vListInsert
   1607          
   1608          	/* We must remove ourselves from the ready list before adding ourselves
   1609          	to the blocked list as the same list item is used for both lists.  We have
   1610          	exclusive access to the ready lists as the scheduler is locked. */
   1611          	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   0000000E   ....               LDR      R0,??DataTable25
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   001D               ADDS     R0,R0,#+4
   \   00000014   ........           BL       vListRemove
   1612          
   1613          
   1614          	#if ( INCLUDE_vTaskSuspend == 1 )
   1615          	{
   1616          		if( xTicksToWait == portMAX_DELAY )
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   C043               MVNS     R0,R0            ;; #-1
   \   0000001C   8442               CMP      R4,R0
   \   0000001E   06D1               BNE      ??vTaskPlaceOnEventList_0
   1617          		{
   1618          			/* Add ourselves to the suspended task list instead of a delayed task
   1619          			list to ensure we are not woken by a timing event.  We will block
   1620          			indefinitely. */
   1621          			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   00000020   ....               LDR      R0,??DataTable25
   \   00000022   0168               LDR      R1,[R0, #+0]
   \   00000024   091D               ADDS     R1,R1,#+4
   \   00000026   ....               LDR      R0,??DataTable25_1
   \   00000028   ........           BL       vListInsertEnd
   \   0000002C   18E0               B        ??vTaskPlaceOnEventList_1
   1622          		}
   1623          		else
   1624          		{
   1625          			/* Calculate the time at which the task should be woken if the event does
   1626          			not occur.  This may overflow but this doesn't matter. */
   1627          			xTimeToWake = xTickCount + xTicksToWait;
   \                     ??vTaskPlaceOnEventList_0:
   \   0000002E   ....               LDR      R0,??DataTable20
   \   00000030   0068               LDR      R0,[R0, #+0]
   \   00000032   0019               ADDS     R0,R0,R4
   1628          
   1629          			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   \   00000034   ....               LDR      R1,??DataTable25
   \   00000036   0968               LDR      R1,[R1, #+0]
   \   00000038   4860               STR      R0,[R1, #+4]
   1630          
   1631          			if( xTimeToWake < xTickCount )
   \   0000003A   ....               LDR      R1,??DataTable20
   \   0000003C   0968               LDR      R1,[R1, #+0]
   \   0000003E   8842               CMP      R0,R1
   \   00000040   07D2               BCS      ??vTaskPlaceOnEventList_2
   1632          			{
   1633          				/* Wake time has overflowed.  Place this item in the overflow list. */
   1634          				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   00000042   ....               LDR      R0,??DataTable25
   \   00000044   0168               LDR      R1,[R0, #+0]
   \   00000046   091D               ADDS     R1,R1,#+4
   \   00000048   ....               LDR      R0,??DataTable23_4
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   ........           BL       vListInsert
   \   00000050   06E0               B        ??vTaskPlaceOnEventList_1
   1635          			}
   1636          			else
   1637          			{
   1638          				/* The wake time has not overflowed, so we can use the current block list. */
   1639          				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \                     ??vTaskPlaceOnEventList_2:
   \   00000052   ....               LDR      R0,??DataTable25
   \   00000054   0168               LDR      R1,[R0, #+0]
   \   00000056   091D               ADDS     R1,R1,#+4
   \   00000058   ....               LDR      R0,??DataTable23_3
   \   0000005A   0068               LDR      R0,[R0, #+0]
   \   0000005C   ........           BL       vListInsert
   1640          			}
   1641          		}
   1642          	}
   1643          	#else
   1644          	{
   1645          			/* Calculate the time at which the task should be woken if the event does
   1646          			not occur.  This may overflow but this doesn't matter. */
   1647          			xTimeToWake = xTickCount + xTicksToWait;
   1648          
   1649          			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   1650          
   1651          			if( xTimeToWake < xTickCount )
   1652          			{
   1653          				/* Wake time has overflowed.  Place this item in the overflow list. */
   1654          				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   1655          			}
   1656          			else
   1657          			{
   1658          				/* The wake time has not overflowed, so we can use the current block list. */
   1659          				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   1660          			}
   1661          	}
   1662          	#endif
   1663          }
   \                     ??vTaskPlaceOnEventList_1:
   \   00000060   10BD               POP      {R4,PC}          ;; return
   1664          /*-----------------------------------------------------------*/
   1665          

   \                                 In section .text, align 2, keep-with-next
   1666          signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
   1667          {
   \                     xTaskRemoveFromEventList:
   \   00000000   10B5               PUSH     {R4,LR}
   1668          tskTCB *pxUnblockedTCB;
   1669          portBASE_TYPE xReturn;
   1670          
   1671          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   1672          	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
   1673          
   1674          	/* The event list is sorted in priority order, so we can remove the
   1675          	first in the list, remove the TCB from the delayed list, and add
   1676          	it to the ready list.
   1677          
   1678          	If an event is for a queue that is locked then this function will never
   1679          	get called - the lock count on the queue will get modified instead.  This
   1680          	means we can always expect exclusive access to the event list here. */
   1681          	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   0029               CMP      R1,#+0
   \   00000006   02D0               BEQ      ??xTaskRemoveFromEventList_0
   \   00000008   C068               LDR      R0,[R0, #+12]
   \   0000000A   C468               LDR      R4,[R0, #+12]
   \   0000000C   00E0               B        ??xTaskRemoveFromEventList_1
   \                     ??xTaskRemoveFromEventList_0:
   \   0000000E   0024               MOVS     R4,#+0
   1682          	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_1:
   \   00000010   2000               MOVS     R0,R4
   \   00000012   1830               ADDS     R0,R0,#+24
   \   00000014   ........           BL       vListRemove
   1683          
   1684          	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000018   ....               LDR      R0,??DataTable24
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   15D1               BNE      ??xTaskRemoveFromEventList_2
   1685          	{
   1686          		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   \   00000020   2000               MOVS     R0,R4
   \   00000022   001D               ADDS     R0,R0,#+4
   \   00000024   ........           BL       vListRemove
   1687          		prvAddTaskToReadyQueue( pxUnblockedTCB );
   \   00000028   ....               LDR      R0,??DataTable24_1
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   E16A               LDR      R1,[R4, #+44]
   \   0000002E   8842               CMP      R0,R1
   \   00000030   02D2               BCS      ??xTaskRemoveFromEventList_3
   \   00000032   E06A               LDR      R0,[R4, #+44]
   \   00000034   ....               LDR      R1,??DataTable24_1
   \   00000036   0860               STR      R0,[R1, #+0]
   \                     ??xTaskRemoveFromEventList_3:
   \   00000038   2100               MOVS     R1,R4
   \   0000003A   091D               ADDS     R1,R1,#+4
   \   0000003C   E06A               LDR      R0,[R4, #+44]
   \   0000003E   1422               MOVS     R2,#+20
   \   00000040   5043               MULS     R0,R2,R0
   \   00000042   ....               LDR      R2,??DataTable24_2
   \   00000044   1018               ADDS     R0,R2,R0
   \   00000046   ........           BL       vListInsertEnd
   \   0000004A   04E0               B        ??xTaskRemoveFromEventList_4
   1688          	}
   1689          	else
   1690          	{
   1691          		/* We cannot access the delayed or ready lists, so will hold this
   1692          		task pending until the scheduler is resumed. */
   1693          		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_2:
   \   0000004C   2100               MOVS     R1,R4
   \   0000004E   1831               ADDS     R1,R1,#+24
   \   00000050   ....               LDR      R0,??DataTable20_1
   \   00000052   ........           BL       vListInsertEnd
   1694          	}
   1695          
   1696          	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \                     ??xTaskRemoveFromEventList_4:
   \   00000056   E06A               LDR      R0,[R4, #+44]
   \   00000058   ....               LDR      R1,??DataTable25
   \   0000005A   0968               LDR      R1,[R1, #+0]
   \   0000005C   C96A               LDR      R1,[R1, #+44]
   \   0000005E   8842               CMP      R0,R1
   \   00000060   01D3               BCC      ??xTaskRemoveFromEventList_5
   1697          	{
   1698          		/* Return true if the task removed from the event list has
   1699          		a higher priority than the calling task.  This allows
   1700          		the calling task to know if it should force a context
   1701          		switch now. */
   1702          		xReturn = pdTRUE;
   \   00000062   0120               MOVS     R0,#+1
   \   00000064   00E0               B        ??xTaskRemoveFromEventList_6
   1703          	}
   1704          	else
   1705          	{
   1706          		xReturn = pdFALSE;
   \                     ??xTaskRemoveFromEventList_5:
   \   00000066   0020               MOVS     R0,#+0
   1707          	}
   1708          
   1709          	return xReturn;
   \                     ??xTaskRemoveFromEventList_6:
   \   00000068   10BD               POP      {R4,PC}          ;; return
   1710          }
   1711          /*-----------------------------------------------------------*/
   1712          

   \                                 In section .text, align 2, keep-with-next
   1713          void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
   1714          {
   1715          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   \                     vTaskSetTimeOutState:
   \   00000000   ....               LDR      R1,??DataTable23_5
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   0160               STR      R1,[R0, #+0]
   1716          	pxTimeOut->xTimeOnEntering = xTickCount;
   \   00000006   ....               LDR      R1,??DataTable23_2
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   4160               STR      R1,[R0, #+4]
   1717          }
   \   0000000C   7047               BX       LR               ;; return
   1718          /*-----------------------------------------------------------*/
   1719          

   \                                 In section .text, align 2, keep-with-next
   1720          portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
   1721          {
   \                     xTaskCheckForTimeOut:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
   1722          portBASE_TYPE xReturn;
   1723          
   1724          	portENTER_CRITICAL();
   \   00000006   ........           BL       vPortEnterCritical
   1725          	{
   1726          		#if ( INCLUDE_vTaskSuspend == 1 )
   1727          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   1728          			the maximum block time then the task should block indefinitely, and
   1729          			therefore never time out. */
   1730          			if( *pxTicksToWait == portMAX_DELAY )
   \   0000000A   2068               LDR      R0,[R4, #+0]
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C943               MVNS     R1,R1            ;; #-1
   \   00000010   8842               CMP      R0,R1
   \   00000012   01D1               BNE      ??xTaskCheckForTimeOut_0
   1731          			{
   1732          				xReturn = pdFALSE;
   \   00000014   0024               MOVS     R4,#+0
   \   00000016   1FE0               B        ??xTaskCheckForTimeOut_1
   1733          			}
   1734          			else /* We are not blocking indefinitely, perform the checks below. */
   1735          		#endif
   1736          
   1737          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
   \                     ??xTaskCheckForTimeOut_0:
   \   00000018   ....               LDR      R0,??DataTable23_5
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   2968               LDR      R1,[R5, #+0]
   \   0000001E   8842               CMP      R0,R1
   \   00000020   06D0               BEQ      ??xTaskCheckForTimeOut_2
   \   00000022   ....               LDR      R0,??DataTable23_2
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   6968               LDR      R1,[R5, #+4]
   \   00000028   8842               CMP      R0,R1
   \   0000002A   01D3               BCC      ??xTaskCheckForTimeOut_2
   1738          		{
   1739          			/* The tick count is greater than the time at which vTaskSetTimeout()
   1740          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   1741          			It must have wrapped all the way around and gone past us again. This
   1742          			passed since vTaskSetTimeout() was called. */
   1743          			xReturn = pdTRUE;
   \   0000002C   0124               MOVS     R4,#+1
   \   0000002E   13E0               B        ??xTaskCheckForTimeOut_1
   1744          		}
   1745          		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
   \                     ??xTaskCheckForTimeOut_2:
   \   00000030   ....               LDR      R0,??DataTable23_2
   \   00000032   0068               LDR      R0,[R0, #+0]
   \   00000034   6968               LDR      R1,[R5, #+4]
   \   00000036   401A               SUBS     R0,R0,R1
   \   00000038   2168               LDR      R1,[R4, #+0]
   \   0000003A   8842               CMP      R0,R1
   \   0000003C   0BD2               BCS      ??xTaskCheckForTimeOut_3
   1746          		{
   1747          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   1748          			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
   \   0000003E   2068               LDR      R0,[R4, #+0]
   \   00000040   ....               LDR      R1,??DataTable23_2
   \   00000042   0968               LDR      R1,[R1, #+0]
   \   00000044   401A               SUBS     R0,R0,R1
   \   00000046   6968               LDR      R1,[R5, #+4]
   \   00000048   4018               ADDS     R0,R0,R1
   \   0000004A   2060               STR      R0,[R4, #+0]
   1749          			vTaskSetTimeOutState( pxTimeOut );
   \   0000004C   2800               MOVS     R0,R5
   \   0000004E   ........           BL       vTaskSetTimeOutState
   1750          			xReturn = pdFALSE;
   \   00000052   0024               MOVS     R4,#+0
   \   00000054   00E0               B        ??xTaskCheckForTimeOut_1
   1751          		}
   1752          		else
   1753          		{
   1754          			xReturn = pdTRUE;
   \                     ??xTaskCheckForTimeOut_3:
   \   00000056   0124               MOVS     R4,#+1
   1755          		}
   1756          	}
   1757          	portEXIT_CRITICAL();
   \                     ??xTaskCheckForTimeOut_1:
   \   00000058   ........           BL       vPortExitCritical
   1758          
   1759          	return xReturn;
   \   0000005C   2000               MOVS     R0,R4
   \   0000005E   32BD               POP      {R1,R4,R5,PC}    ;; return
   1760          }
   1761          /*-----------------------------------------------------------*/
   1762          

   \                                 In section .text, align 2, keep-with-next
   1763          void vTaskMissedYield( void )
   1764          {
   1765          	xMissedYield = pdTRUE;
   \                     vTaskMissedYield:
   \   00000000   ....               LDR      R0,??DataTable24_3
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0160               STR      R1,[R0, #+0]
   1766          }
   \   00000006   7047               BX       LR               ;; return
   1767          
   1768          /*
   1769           * -----------------------------------------------------------
   1770           * The Idle task.
   1771           * ----------------------------------------------------------
   1772           *
   1773           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   1774           * language extensions.  The equivalent prototype for this function is:
   1775           *
   1776           * void prvIdleTask( void *pvParameters );
   1777           *
   1778           */

   \                                 In section .text, align 2, keep-with-next
   1779          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   1780          {
   \                     prvIdleTask:
   \   00000000   80B5               PUSH     {R7,LR}
   1781          	/* Stop warnings. */
   1782          	( void ) pvParameters;
   1783          
   1784          	for( ;; )
   1785          	{
   1786          		/* See if any tasks have been deleted. */
   1787          		prvCheckTasksWaitingTermination();
   \                     ??prvIdleTask_0:
   \   00000002   ........           BL       prvCheckTasksWaitingTermination
   1788          
   1789          		#if ( configUSE_PREEMPTION == 0 )
   1790          		{
   1791          			/* If we are not using preemption we keep forcing a task switch to
   1792          			see if any other task has become available.  If we are using
   1793          			preemption we don't need to do this as any task becoming available
   1794          			will automatically get the processor anyway. */
   1795          			taskYIELD();
   1796          		}
   1797          		#endif
   1798          
   1799          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   1800          		{
   1801          			/* When using preemption tasks of equal priority will be
   1802          			timesliced.  If a task that is sharing the idle priority is ready
   1803          			to run then the idle task should yield before the end of the
   1804          			timeslice.
   1805          
   1806          			A critical region is not required here as we are just reading from
   1807          			the list, and an occasional incorrect value will not matter.  If
   1808          			the ready list at the idle priority contains more than one task
   1809          			then a task other than the idle task is ready to execute. */
   1810          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   \   00000006   ....               LDR      R0,??DataTable28
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   0228               CMP      R0,#+2
   \   0000000C   F9D3               BCC      ??prvIdleTask_0
   1811          			{
   1812          				taskYIELD();
   \   0000000E   ........           BL       vPortYieldFromISR
   \   00000012   F6E7               B        ??prvIdleTask_0
   1813          			}
   1814          		}
   1815          		#endif
   1816          
   1817          		#if ( configUSE_IDLE_HOOK == 1 )
   1818          		{
   1819          			extern void vApplicationIdleHook( void );
   1820          
   1821          			/* Call the user defined function from within the idle task.  This
   1822          			allows the application designer to add background functionality
   1823          			without the overhead of a separate task.
   1824          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   1825          			CALL A FUNCTION THAT MIGHT BLOCK. */
   1826          			vApplicationIdleHook();
   1827          		}
   1828          		#endif
   1829          	}
   1830          } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
   1831          
   1832          
   1833          
   1834          
   1835          
   1836          
   1837          
   1838          /*-----------------------------------------------------------
   1839           * File private functions documented at the top of the file.
   1840           *----------------------------------------------------------*/
   1841          
   1842          
   1843          

   \                                 In section .text, align 2, keep-with-next
   1844          static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
   1845          {
   \                     prvInitialiseTCBVariables:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1500               MOVS     R5,R2
   1846          	/* Store the function name in the TCB. */
   1847          	#if configMAX_TASK_NAME_LEN > 1
   1848          	{
   1849          		/* Don't bring strncpy into the build unnecessarily. */
   1850          		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
   \   00000006   1022               MOVS     R2,#+16
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   3430               ADDS     R0,R0,#+52
   \   0000000C   ........           BL       strncpy
   1851          	}
   1852          	#endif
   1853          	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
   \   00000010   4320               MOVS     R0,#+67
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   2154               STRB     R1,[R4, R0]
   1854          
   1855          	/* This is used as an array index so must ensure it's not too large.  First
   1856          	remove the privilege bit if one is present. */
   1857          	if( uxPriority >= configMAX_PRIORITIES )
   \   00000016   062D               CMP      R5,#+6
   \   00000018   00D3               BCC      ??prvInitialiseTCBVariables_0
   1858          	{
   1859          		uxPriority = configMAX_PRIORITIES - 1;
   \   0000001A   0525               MOVS     R5,#+5
   1860          	}
   1861          
   1862          	pxTCB->uxPriority = uxPriority;
   \                     ??prvInitialiseTCBVariables_0:
   \   0000001C   E562               STR      R5,[R4, #+44]
   1863          	#if ( configUSE_MUTEXES == 1 )
   1864          	{
   1865          		pxTCB->uxBasePriority = uxPriority;
   \   0000001E   6564               STR      R5,[R4, #+68]
   1866          	}
   1867          	#endif
   1868          
   1869          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   \   00000020   2000               MOVS     R0,R4
   \   00000022   001D               ADDS     R0,R0,#+4
   \   00000024   ........           BL       vListInitialiseItem
   1870          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   1830               ADDS     R0,R0,#+24
   \   0000002C   ........           BL       vListInitialiseItem
   1871          
   1872          	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
   1873          	back to	the containing TCB from a generic item in a list. */
   1874          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   \   00000030   2461               STR      R4,[R4, #+16]
   1875          
   1876          	/* Event lists are always in priority order. */
   1877          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   \   00000032   0620               MOVS     R0,#+6
   \   00000034   401B               SUBS     R0,R0,R5
   \   00000036   A061               STR      R0,[R4, #+24]
   1878          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   \   00000038   6462               STR      R4,[R4, #+36]
   1879          
   1880          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   1881          	{
   1882          		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;
   1883          	}
   1884          	#endif
   1885          
   1886          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1887          	{
   1888          		pxTCB->pxTaskTag = NULL;
   1889          	}
   1890          	#endif
   1891          
   1892          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   1893          	{
   1894          		pxTCB->ulRunTimeCounter = 0UL;
   1895          	}
   1896          	#endif
   1897          
   1898          	#if ( portUSING_MPU_WRAPPERS == 1 )
   1899          	{
   1900          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   1901          	}
   1902          	#else
   1903          	{
   1904          		( void ) xRegions;
   1905          		( void ) usStackDepth;
   1906          	}
   1907          	#endif
   1908          }
   \   0000003A   31BD               POP      {R0,R4,R5,PC}    ;; return
   1909          /*-----------------------------------------------------------*/
   1910          
   1911          #if ( portUSING_MPU_WRAPPERS == 1 )
   1912          
   1913          	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
   1914          	{
   1915          	tskTCB *pxTCB;
   1916          	
   1917          		if( xTaskToModify == pxCurrentTCB )
   1918          		{
   1919          			xTaskToModify = NULL;
   1920          		}
   1921          
   1922          		/* If null is passed in here then we are deleting ourselves. */
   1923          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   1924          
   1925                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   1926          	}
   1927          	/*-----------------------------------------------------------*/
   1928          #endif
   1929          

   \                                 In section .text, align 2, keep-with-next
   1930          static void prvInitialiseTaskLists( void )
   1931          {
   \                     prvInitialiseTaskLists:
   \   00000000   10B5               PUSH     {R4,LR}
   1932          unsigned portBASE_TYPE uxPriority;
   1933          
   1934          	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   06E0               B        ??prvInitialiseTaskLists_0
   1935          	{
   1936          		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
   \                     ??prvInitialiseTaskLists_1:
   \   00000006   1420               MOVS     R0,#+20
   \   00000008   6043               MULS     R0,R4,R0
   \   0000000A   ....               LDR      R1,??DataTable24_2
   \   0000000C   0818               ADDS     R0,R1,R0
   \   0000000E   ........           BL       vListInitialise
   1937          	}
   \   00000012   641C               ADDS     R4,R4,#+1
   \                     ??prvInitialiseTaskLists_0:
   \   00000014   062C               CMP      R4,#+6
   \   00000016   F6D3               BCC      ??prvInitialiseTaskLists_1
   1938          
   1939          	vListInitialise( ( xList * ) &xDelayedTaskList1 );
   \   00000018   ....               LDR      R0,??DataTable28_1
   \   0000001A   ........           BL       vListInitialise
   1940          	vListInitialise( ( xList * ) &xDelayedTaskList2 );
   \   0000001E   ....               LDR      R0,??DataTable28_2
   \   00000020   ........           BL       vListInitialise
   1941          	vListInitialise( ( xList * ) &xPendingReadyList );
   \   00000024   ....               LDR      R0,??DataTable28_3
   \   00000026   ........           BL       vListInitialise
   1942          
   1943          	#if ( INCLUDE_vTaskDelete == 1 )
   1944          	{
   1945          		vListInitialise( ( xList * ) &xTasksWaitingTermination );
   \   0000002A   ....               LDR      R0,??DataTable28_4
   \   0000002C   ........           BL       vListInitialise
   1946          	}
   1947          	#endif
   1948          
   1949          	#if ( INCLUDE_vTaskSuspend == 1 )
   1950          	{
   1951          		vListInitialise( ( xList * ) &xSuspendedTaskList );
   \   00000030   ....               LDR      R0,??DataTable25_1
   \   00000032   ........           BL       vListInitialise
   1952          	}
   1953          	#endif
   1954          
   1955          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   1956          	using list2. */
   1957          	pxDelayedTaskList = &xDelayedTaskList1;
   \   00000036   ....               LDR      R0,??DataTable28_5
   \   00000038   ....               LDR      R1,??DataTable28_1
   \   0000003A   0160               STR      R1,[R0, #+0]
   1958          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   \   0000003C   ....               LDR      R0,??DataTable28_6
   \   0000003E   ....               LDR      R1,??DataTable28_2
   \   00000040   0160               STR      R1,[R0, #+0]
   1959          }
   \   00000042   10BD               POP      {R4,PC}          ;; return
   1960          /*-----------------------------------------------------------*/
   1961          

   \                                 In section .text, align 2, keep-with-next
   1962          static void prvCheckTasksWaitingTermination( void )
   1963          {
   \                     prvCheckTasksWaitingTermination:
   \   00000000   10B5               PUSH     {R4,LR}
   1964          	#if ( INCLUDE_vTaskDelete == 1 )
   1965          	{
   1966          		portBASE_TYPE xListIsEmpty;
   1967          
   1968          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   1969          		too often in the idle task. */
   1970          		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
   \   00000002   ....               LDR      R0,??DataTable28_7
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   2BD0               BEQ      ??prvCheckTasksWaitingTermination_0
   1971          		{
   1972          			vTaskSuspendAll();
   \   0000000A   ........           BL       vTaskSuspendAll
   1973          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   \   0000000E   ....               LDR      R0,??DataTable28_4
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   01D1               BNE      ??prvCheckTasksWaitingTermination_1
   \   00000016   0124               MOVS     R4,#+1
   \   00000018   00E0               B        ??prvCheckTasksWaitingTermination_2
   \                     ??prvCheckTasksWaitingTermination_1:
   \   0000001A   0024               MOVS     R4,#+0
   \                     ??prvCheckTasksWaitingTermination_2:
   \   0000001C   E4B2               UXTB     R4,R4
   1974          			xTaskResumeAll();
   \   0000001E   ........           BL       xTaskResumeAll
   1975          
   1976          			if( !xListIsEmpty )
   \   00000022   002C               CMP      R4,#+0
   \   00000024   1DD1               BNE      ??prvCheckTasksWaitingTermination_0
   1977          			{
   1978          				tskTCB *pxTCB;
   1979          
   1980          				portENTER_CRITICAL();
   \   00000026   ........           BL       vPortEnterCritical
   1981          				{
   1982          					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
   \   0000002A   ....               LDR      R0,??DataTable28_4
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   03D0               BEQ      ??prvCheckTasksWaitingTermination_3
   \   00000032   ....               LDR      R0,??DataTable28_4
   \   00000034   C068               LDR      R0,[R0, #+12]
   \   00000036   C468               LDR      R4,[R0, #+12]
   \   00000038   00E0               B        ??prvCheckTasksWaitingTermination_4
   \                     ??prvCheckTasksWaitingTermination_3:
   \   0000003A   0024               MOVS     R4,#+0
   1983          					vListRemove( &( pxTCB->xGenericListItem ) );
   \                     ??prvCheckTasksWaitingTermination_4:
   \   0000003C   2000               MOVS     R0,R4
   \   0000003E   001D               ADDS     R0,R0,#+4
   \   00000040   ........           BL       vListRemove
   1984          					--uxCurrentNumberOfTasks;
   \   00000044   ....               LDR      R0,??DataTable28_8
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   401E               SUBS     R0,R0,#+1
   \   0000004A   ....               LDR      R1,??DataTable28_8
   \   0000004C   0860               STR      R0,[R1, #+0]
   1985          					--uxTasksDeleted;
   \   0000004E   ....               LDR      R0,??DataTable28_7
   \   00000050   0068               LDR      R0,[R0, #+0]
   \   00000052   401E               SUBS     R0,R0,#+1
   \   00000054   ....               LDR      R1,??DataTable28_7
   \   00000056   0860               STR      R0,[R1, #+0]
   1986          				}
   1987          				portEXIT_CRITICAL();
   \   00000058   ........           BL       vPortExitCritical
   1988          
   1989          				prvDeleteTCB( pxTCB );
   \   0000005C   2000               MOVS     R0,R4
   \   0000005E   ........           BL       prvDeleteTCB
   1990          			}
   1991          		}
   1992          	}
   1993          	#endif
   1994          }
   \                     ??prvCheckTasksWaitingTermination_0:
   \   00000062   10BD               POP      {R4,PC}          ;; return
   1995          /*-----------------------------------------------------------*/
   1996          

   \                                 In section .text, align 2, keep-with-next
   1997          static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
   1998          {
   \                     prvAllocateTCBAndStack:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0E00               MOVS     R6,R1
   1999          tskTCB *pxNewTCB;
   2000          
   2001          	/* Allocate space for the TCB.  Where the memory comes from depends on
   2002          	the implementation of the port malloc function. */
   2003          	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   \   00000006   4820               MOVS     R0,#+72
   \   00000008   ........           BL       pvPortMalloc
   \   0000000C   0400               MOVS     R4,R0
   2004          
   2005          	if( pxNewTCB != NULL )
   \   0000000E   002C               CMP      R4,#+0
   \   00000010   19D0               BEQ      ??prvAllocateTCBAndStack_0
   2006          	{
   2007          		/* Allocate space for the stack used by the task being created.
   2008          		The base of the stack memory stored in the TCB so the task can
   2009          		be deleted later if required. */
   2010          		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   \   00000012   002E               CMP      R6,#+0
   \   00000014   06D1               BNE      ??prvAllocateTCBAndStack_1
   \   00000016   ADB2               UXTH     R5,R5
   \   00000018   0420               MOVS     R0,#+4
   \   0000001A   6843               MULS     R0,R5,R0
   \   0000001C   ........           BL       pvPortMalloc
   \   00000020   0600               MOVS     R6,R0
   \   00000022   FFE7               B        ??prvAllocateTCBAndStack_2
   \                     ??prvAllocateTCBAndStack_1:
   \                     ??prvAllocateTCBAndStack_2:
   \   00000024   2663               STR      R6,[R4, #+48]
   2011          
   2012          		if( pxNewTCB->pxStack == NULL )
   \   00000026   206B               LDR      R0,[R4, #+48]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   04D1               BNE      ??prvAllocateTCBAndStack_3
   2013          		{
   2014          			/* Could not allocate the stack.  Delete the allocated TCB. */
   2015          			vPortFree( pxNewTCB );
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       vPortFree
   2016          			pxNewTCB = NULL;
   \   00000032   0024               MOVS     R4,#+0
   \   00000034   07E0               B        ??prvAllocateTCBAndStack_0
   2017          		}
   2018          		else
   2019          		{
   2020          			/* Just to help debugging. */
   2021          			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
   \                     ??prvAllocateTCBAndStack_3:
   \   00000036   ADB2               UXTH     R5,R5
   \   00000038   0420               MOVS     R0,#+4
   \   0000003A   4543               MULS     R5,R0,R5
   \   0000003C   2A00               MOVS     R2,R5
   \   0000003E   A521               MOVS     R1,#+165
   \   00000040   206B               LDR      R0,[R4, #+48]
   \   00000042   ........           BL       memset
   2022          		}
   2023          	}
   2024          
   2025          	return pxNewTCB;
   \                     ??prvAllocateTCBAndStack_0:
   \   00000046   2000               MOVS     R0,R4
   \   00000048   70BD               POP      {R4-R6,PC}       ;; return
   2026          }
   2027          /*-----------------------------------------------------------*/
   2028          
   2029          #if ( configUSE_TRACE_FACILITY == 1 )
   2030          
   2031          	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
   2032          	{
   2033          	volatile tskTCB *pxNextTCB, *pxFirstTCB;
   2034          	unsigned short usStackRemaining;
   2035          
   2036          		/* Write the details of all the TCB's in pxList into the buffer. */
   2037          		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2038          		do
   2039          		{
   2040          			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2041          			#if ( portSTACK_GROWTH > 0 )
   2042          			{
   2043          				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
   2044          			}
   2045          			#else
   2046          			{
   2047          				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
   2048          			}
   2049          			#endif			
   2050          			
   2051          			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
   2052          			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
   2053          
   2054          		} while( pxNextTCB != pxFirstTCB );
   2055          	}
   2056          
   2057          #endif
   2058          /*-----------------------------------------------------------*/
   2059          
   2060          #if ( configGENERATE_RUN_TIME_STATS == 1 )
   2061          
   2062          	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime )
   2063          	{
   2064          	volatile tskTCB *pxNextTCB, *pxFirstTCB;
   2065          	unsigned long ulStatsAsPercentage;
   2066          
   2067          		/* Write the run time stats of all the TCB's in pxList into the buffer. */
   2068          		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2069          		do
   2070          		{
   2071          			/* Get next TCB in from the list. */
   2072          			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2073          
   2074          			/* Divide by zero check. */
   2075          			if( ulTotalRunTime > 0UL )
   2076          			{
   2077          				/* Has the task run at all? */
   2078          				if( pxNextTCB->ulRunTimeCounter == 0 )
   2079          				{
   2080          					/* The task has used no CPU time at all. */
   2081          					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
   2082          				}
   2083          				else
   2084          				{
   2085          					/* What percentage of the total run time as the task used?
   2086          					This will always be rounded down to the nearest integer. */
   2087          					ulStatsAsPercentage = ( 100UL * pxNextTCB->ulRunTimeCounter ) / ulTotalRunTime;
   2088          
   2089          					if( ulStatsAsPercentage > 0UL )
   2090          					{
   2091          						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   2092          					}
   2093          					else
   2094          					{
   2095          						/* If the percentage is zero here then the task has
   2096          						consumed less than 1% of the total run time. */
   2097          						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter );
   2098          					}
   2099          				}
   2100          
   2101          				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
   2102          			}
   2103          
   2104          		} while( pxNextTCB != pxFirstTCB );
   2105          	}
   2106          
   2107          #endif
   2108          /*-----------------------------------------------------------*/
   2109          
   2110          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   2111          
   2112          	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
   2113          	{
   2114          	register unsigned short usCount = 0;
   2115          
   2116          		while( *pucStackByte == tskSTACK_FILL_BYTE )
   2117          		{
   2118          			pucStackByte -= portSTACK_GROWTH;
   2119          			usCount++;
   2120          		}
   2121          
   2122          		usCount /= sizeof( portSTACK_TYPE );
   2123          
   2124          		return usCount;
   2125          	}
   2126          
   2127          #endif
   2128          /*-----------------------------------------------------------*/
   2129          
   2130          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   2131          
   2132          	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
   2133          	{
   2134          	tskTCB *pxTCB;
   2135          	unsigned char *pcEndOfStack;
   2136          	unsigned portBASE_TYPE uxReturn;
   2137          
   2138          		pxTCB = prvGetTCBFromHandle( xTask );
   2139          
   2140          		#if portSTACK_GROWTH < 0
   2141          		{
   2142          			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
   2143          		}
   2144          		#else
   2145          		{
   2146          			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
   2147          		}
   2148          		#endif
   2149          
   2150          		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
   2151          
   2152          		return uxReturn;
   2153          	}
   2154          
   2155          #endif
   2156          /*-----------------------------------------------------------*/
   2157          
   2158          #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
   2159          

   \                                 In section .text, align 2, keep-with-next
   2160          	static void prvDeleteTCB( tskTCB *pxTCB )
   2161          	{
   \                     prvDeleteTCB:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   2162          		/* Free up the memory allocated by the scheduler for the task.  It is up to
   2163          		the task to free any memory allocated at the application level. */
   2164          		vPortFreeAligned( pxTCB->pxStack );
   \   00000004   206B               LDR      R0,[R4, #+48]
   \   00000006   ........           BL       vPortFree
   2165          		vPortFree( pxTCB );
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       vPortFree
   2166          	}
   \   00000010   10BD               POP      {R4,PC}          ;; return
   2167          
   2168          #endif
   2169          
   2170          
   2171          /*-----------------------------------------------------------*/
   2172          
   2173          #if ( INCLUDE_xTaskGetCurrentTaskHandle == 1 )
   2174          

   \                                 In section .text, align 2, keep-with-next
   2175          	xTaskHandle xTaskGetCurrentTaskHandle( void )
   2176          	{
   2177          	xTaskHandle xReturn;
   2178          
   2179          		/* A critical section is not required as this is not called from
   2180          		an interrupt and the current TCB will always be the same for any
   2181          		individual execution thread. */
   2182          		xReturn = pxCurrentTCB;
   \                     xTaskGetCurrentTaskHandle:
   \   00000000   ....               LDR      R0,??DataTable28_9
   \   00000002   0068               LDR      R0,[R0, #+0]
   2183          
   2184          		return xReturn;
   \   00000004   7047               BX       LR               ;; return
   2185          	}
   2186          
   2187          #endif
   2188          
   2189          /*-----------------------------------------------------------*/
   2190          
   2191          #if ( INCLUDE_xTaskGetSchedulerState == 1 )
   2192          
   2193          	portBASE_TYPE xTaskGetSchedulerState( void )
   2194          	{
   2195          	portBASE_TYPE xReturn;
   2196          
   2197          		if( xSchedulerRunning == pdFALSE )
   2198          		{
   2199          			xReturn = taskSCHEDULER_NOT_STARTED;
   2200          		}
   2201          		else
   2202          		{
   2203          			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   2204          			{
   2205          				xReturn = taskSCHEDULER_RUNNING;
   2206          			}
   2207          			else
   2208          			{
   2209          				xReturn = taskSCHEDULER_SUSPENDED;
   2210          			}
   2211          		}
   2212          
   2213          		return xReturn;
   2214          	}
   2215          
   2216          #endif
   2217          /*-----------------------------------------------------------*/
   2218          
   2219          #if ( configUSE_MUTEXES == 1 )
   2220          

   \                                 In section .text, align 2, keep-with-next
   2221          	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
   2222          	{
   \                     vTaskPriorityInherit:
   \   00000000   10B5               PUSH     {R4,LR}
   2223          	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   \   00000002   0400               MOVS     R4,R0
   2224          
   2225          		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   \   00000004   E06A               LDR      R0,[R4, #+44]
   \   00000006   ....               LDR      R1,??DataTable28_9
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   C96A               LDR      R1,[R1, #+44]
   \   0000000C   8842               CMP      R0,R1
   \   0000000E   2BD2               BCS      ??vTaskPriorityInherit_0
   2226          		{
   2227          			/* Adjust the mutex holder state to account for its new priority. */
   2228          			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
   \   00000010   0620               MOVS     R0,#+6
   \   00000012   ....               LDR      R1,??DataTable28_9
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   C96A               LDR      R1,[R1, #+44]
   \   00000018   401A               SUBS     R0,R0,R1
   \   0000001A   A061               STR      R0,[R4, #+24]
   2229          
   2230          			/* If the task being modified is in the ready state it will need to
   2231          			be moved in to a new list. */
   2232          			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
   \   0000001C   6069               LDR      R0,[R4, #+20]
   \   0000001E   E16A               LDR      R1,[R4, #+44]
   \   00000020   1422               MOVS     R2,#+20
   \   00000022   5143               MULS     R1,R2,R1
   \   00000024   ....               LDR      R2,??DataTable28
   \   00000026   5118               ADDS     R1,R2,R1
   \   00000028   8842               CMP      R0,R1
   \   0000002A   19D1               BNE      ??vTaskPriorityInherit_1
   2233          			{
   2234          				vListRemove( &( pxTCB->xGenericListItem ) );
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   001D               ADDS     R0,R0,#+4
   \   00000030   ........           BL       vListRemove
   2235          
   2236          				/* Inherit the priority before being moved into the new list. */
   2237          				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   \   00000034   ....               LDR      R0,??DataTable28_9
   \   00000036   0068               LDR      R0,[R0, #+0]
   \   00000038   C06A               LDR      R0,[R0, #+44]
   \   0000003A   E062               STR      R0,[R4, #+44]
   2238          				prvAddTaskToReadyQueue( pxTCB );
   \   0000003C   ....               LDR      R0,??DataTable28_10
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   E16A               LDR      R1,[R4, #+44]
   \   00000042   8842               CMP      R0,R1
   \   00000044   02D2               BCS      ??vTaskPriorityInherit_2
   \   00000046   E06A               LDR      R0,[R4, #+44]
   \   00000048   ....               LDR      R1,??DataTable28_10
   \   0000004A   0860               STR      R0,[R1, #+0]
   \                     ??vTaskPriorityInherit_2:
   \   0000004C   2100               MOVS     R1,R4
   \   0000004E   091D               ADDS     R1,R1,#+4
   \   00000050   E06A               LDR      R0,[R4, #+44]
   \   00000052   1422               MOVS     R2,#+20
   \   00000054   5043               MULS     R0,R2,R0
   \   00000056   ....               LDR      R2,??DataTable28
   \   00000058   1018               ADDS     R0,R2,R0
   \   0000005A   ........           BL       vListInsertEnd
   \   0000005E   03E0               B        ??vTaskPriorityInherit_0
   2239          			}
   2240          			else
   2241          			{
   2242          				/* Just inherit the priority. */
   2243          				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   \                     ??vTaskPriorityInherit_1:
   \   00000060   ....               LDR      R0,??DataTable28_9
   \   00000062   0068               LDR      R0,[R0, #+0]
   \   00000064   C06A               LDR      R0,[R0, #+44]
   \   00000066   E062               STR      R0,[R4, #+44]
   2244          			}
   2245          		}
   2246          	}
   \                     ??vTaskPriorityInherit_0:
   \   00000068   10BD               POP      {R4,PC}          ;; return
   2247          
   2248          #endif
   2249          /*-----------------------------------------------------------*/
   2250          
   2251          #if ( configUSE_MUTEXES == 1 )
   2252          

   \                                 In section .text, align 2, keep-with-next
   2253          	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
   2254          	{
   \                     vTaskPriorityDisinherit:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   2255          	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   2256          
   2257          		if( pxMutexHolder != NULL )
   \   00000004   002C               CMP      R4,#+0
   \   00000006   1ED0               BEQ      ??vTaskPriorityDisinherit_0
   2258          		{
   2259          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   \   00000008   E06A               LDR      R0,[R4, #+44]
   \   0000000A   616C               LDR      R1,[R4, #+68]
   \   0000000C   8842               CMP      R0,R1
   \   0000000E   1AD0               BEQ      ??vTaskPriorityDisinherit_0
   2260          			{
   2261          				/* We must be the running task to be able to give the mutex back.
   2262          				Remove ourselves from the ready list we currently appear in. */
   2263          				vListRemove( &( pxTCB->xGenericListItem ) );
   \   00000010   2000               MOVS     R0,R4
   \   00000012   001D               ADDS     R0,R0,#+4
   \   00000014   ........           BL       vListRemove
   2264          
   2265          				/* Disinherit the priority before adding ourselves into the new
   2266          				ready list. */
   2267          				pxTCB->uxPriority = pxTCB->uxBasePriority;
   \   00000018   606C               LDR      R0,[R4, #+68]
   \   0000001A   E062               STR      R0,[R4, #+44]
   2268          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
   \   0000001C   0620               MOVS     R0,#+6
   \   0000001E   E16A               LDR      R1,[R4, #+44]
   \   00000020   401A               SUBS     R0,R0,R1
   \   00000022   A061               STR      R0,[R4, #+24]
   2269          				prvAddTaskToReadyQueue( pxTCB );
   \   00000024   ....               LDR      R0,??DataTable28_10
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   E16A               LDR      R1,[R4, #+44]
   \   0000002A   8842               CMP      R0,R1
   \   0000002C   02D2               BCS      ??vTaskPriorityDisinherit_1
   \   0000002E   E06A               LDR      R0,[R4, #+44]
   \   00000030   ....               LDR      R1,??DataTable28_10
   \   00000032   0860               STR      R0,[R1, #+0]
   \                     ??vTaskPriorityDisinherit_1:
   \   00000034   2100               MOVS     R1,R4
   \   00000036   091D               ADDS     R1,R1,#+4
   \   00000038   E06A               LDR      R0,[R4, #+44]
   \   0000003A   1422               MOVS     R2,#+20
   \   0000003C   5043               MULS     R0,R2,R0
   \   0000003E   ....               LDR      R2,??DataTable28
   \   00000040   1018               ADDS     R0,R2,R0
   \   00000042   ........           BL       vListInsertEnd
   2270          			}
   2271          		}
   2272          	}
   \                     ??vTaskPriorityDisinherit_0:
   \   00000046   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     uxCurrentNumberOfTasks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     xSchedulerRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   ........           DC32     uxTopUsedPriority

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   ........           DC32     uxTaskNumber

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   ........           DC32     uxTopReadyPriority

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   ........           DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     xTasksWaitingTermination

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   ........           DC32     uxTasksDeleted

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   ........           DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     xTickCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     pxOverflowDelayedTaskList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     pxDelayedTaskList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     xSuspendedTaskList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     uxTopReadyPriority

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     uxSchedulerSuspended

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   ........           DC32     `?<Constant "IDLE">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   ........           DC32     prvIdleTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   ........           DC32     xSchedulerRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   ........           DC32     uxCurrentNumberOfTasks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   ........           DC32     xTickCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   ........           DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     uxMissedTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   ........           DC32     xMissedYield

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   ........           DC32     xTickCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   ........           DC32     pxDelayedTaskList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   ........           DC32     pxOverflowDelayedTaskList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   ........           DC32     xNumOfOverflows

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     uxSchedulerSuspended

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   ........           DC32     uxTopReadyPriority

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   ........           DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   ........           DC32     xMissedYield

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   ........           DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   ........           DC32     xSuspendedTaskList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   ........           DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   ........           DC32     xDelayedTaskList1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   ........           DC32     xDelayedTaskList2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   ........           DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   ........           DC32     xTasksWaitingTermination

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   ........           DC32     pxDelayedTaskList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   ........           DC32     pxOverflowDelayedTaskList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   ........           DC32     uxTasksDeleted

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   ........           DC32     uxCurrentNumberOfTasks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   ........           DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   ........           DC32     uxTopReadyPriority

   \                                 In section .rodata, align 4
   \                     `?<Constant "IDLE">`:
   \   00000000   49444C4500         DC8 "IDLE"
   \   00000005   000000             DC8 0, 0, 0
   2273          
   2274          #endif
   2275          /*-----------------------------------------------------------*/
   2276          
   2277          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2278          
   2279          	void vTaskEnterCritical( void )
   2280          	{
   2281          		portDISABLE_INTERRUPTS();
   2282          
   2283          		if( xSchedulerRunning != pdFALSE )
   2284          		{
   2285          			pxCurrentTCB->uxCriticalNesting++;
   2286          		}
   2287          	}
   2288          
   2289          #endif
   2290          /*-----------------------------------------------------------*/
   2291          
   2292          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2293          
   2294          void vTaskExitCritical( void )
   2295          {
   2296          	if( xSchedulerRunning != pdFALSE )
   2297          	{
   2298          		if( pxCurrentTCB->uxCriticalNesting > 0 )
   2299          		{
   2300          			pxCurrentTCB->uxCriticalNesting--;
   2301          
   2302          			if( pxCurrentTCB->uxCriticalNesting == 0 )
   2303          			{
   2304          				portENABLE_INTERRUPTS();
   2305          			}
   2306          		}
   2307          	}
   2308          }
   2309          
   2310          #endif
   2311          /*-----------------------------------------------------------*/
   2312          
   2313          
   2314          
   2315          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     memset                              8
     prvAllocateTCBAndStack             16
     prvCheckTasksWaitingTermination
                                         8
     prvDeleteTCB                        8
     prvIdleTask                         8
     prvInitialiseTCBVariables          16
     prvInitialiseTaskLists              8
     uxTaskGetNumberOfTasks              0
     uxTaskPriorityGet                   8
     vTaskDelay                          8
     vTaskDelayUntil                    16
     vTaskDelete                        16
     vTaskEndScheduler                   8
     vTaskIncrementTick                  8
     vTaskMissedYield                    0
     vTaskPlaceOnEventList               8
     vTaskPriorityDisinherit             8
     vTaskPriorityInherit                8
     vTaskPrioritySet                   24
     vTaskResume                         8
     vTaskSetTimeOutState                0
     vTaskStartScheduler                24
     vTaskSuspend                       16
     vTaskSuspendAll                     0
     vTaskSwitchContext                  4
     xTaskCheckForTimeOut               16
     xTaskGenericCreate                 40
     xTaskGetCurrentTaskHandle           0
     xTaskGetTickCount                   8
     xTaskIsTaskSuspended                4
     xTaskRemoveFromEventList            8
     xTaskResumeAll                     16
     xTaskResumeFromISR                 16


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     memset                           20
     pxCurrentTCB                      4
     pxReadyTasksLists               120
     xDelayedTaskList1                20
     xDelayedTaskList2                20
     pxDelayedTaskList                 4
     pxOverflowDelayedTaskList         4
     xPendingReadyList                20
     xTasksWaitingTermination         20
     uxTasksDeleted                    4
     xSuspendedTaskList               20
     uxCurrentNumberOfTasks            4
     xTickCount                        4
     uxTopUsedPriority                 4
     uxTopReadyPriority                4
     xSchedulerRunning                 4
     uxSchedulerSuspended              4
     uxMissedTicks                     4
     xMissedYield                      4
     xNumOfOverflows                   4
     uxTaskNumber                      4
     xTaskGenericCreate              236
     vTaskDelete                     104
     vTaskDelayUntil                 134
     vTaskDelay                       88
     uxTaskPriorityGet                28
     vTaskPrioritySet                152
     vTaskSuspend                     76
     xTaskIsTaskSuspended             32
     vTaskResume                      94
     xTaskResumeFromISR              102
     vTaskStartScheduler              60
     vTaskEndScheduler                18
     vTaskSuspendAll                  12
     xTaskResumeAll                  190
     xTaskGetTickCount                18
     uxTaskGetNumberOfTasks            6
     vTaskIncrementTick              162
     vTaskSwitchContext               88
     vTaskPlaceOnEventList            98
     xTaskRemoveFromEventList        106
     vTaskSetTimeOutState             14
     xTaskCheckForTimeOut             96
     vTaskMissedYield                  8
     prvIdleTask                      20
     prvInitialiseTCBVariables        60
     prvInitialiseTaskLists           68
     prvCheckTasksWaitingTermination
                                     100
     prvAllocateTCBAndStack           74
     prvDeleteTCB                     18
     xTaskGetCurrentTaskHandle         6
     vTaskPriorityInherit            106
     vTaskPriorityDisinherit          72
     ??DataTable4                      4
     ??DataTable5                      4
     ??DataTable5_1                    4
     ??DataTable5_2                    4
     ??DataTable5_3                    4
     ??DataTable5_4                    4
     ??DataTable6                      4
     ??DataTable7                      4
     ??DataTable7_1                    4
     ??DataTable7_2                    4
     ??DataTable8                      4
     ??DataTable9                      4
     ??DataTable12                     4
     ??DataTable15                     4
     ??DataTable16                     4
     ??DataTable16_1                   4
     ??DataTable16_2                   4
     ??DataTable16_3                   4
     ??DataTable17                     4
     ??DataTable18                     4
     ??DataTable18_1                   4
     ??DataTable18_2                   4
     ??DataTable18_3                   4
     ??DataTable20                     4
     ??DataTable20_1                   4
     ??DataTable23                     4
     ??DataTable23_1                   4
     ??DataTable23_2                   4
     ??DataTable23_3                   4
     ??DataTable23_4                   4
     ??DataTable23_5                   4
     ??DataTable24                     4
     ??DataTable24_1                   4
     ??DataTable24_2                   4
     ??DataTable24_3                   4
     ??DataTable25                     4
     ??DataTable25_1                   4
     ??DataTable28                     4
     ??DataTable28_1                   4
     ??DataTable28_2                   4
     ??DataTable28_3                   4
     ??DataTable28_4                   4
     ??DataTable28_5                   4
     ??DataTable28_6                   4
     ??DataTable28_7                   4
     ??DataTable28_8                   4
     ??DataTable28_9                   4
     ??DataTable28_10                  4
     ?<Constant "IDLE">                8

 
   276 bytes in section .bss
     8 bytes in section .rodata
 2 658 bytes in section .text
 
 2 638 bytes of CODE  memory (+ 20 bytes shared)
     8 bytes of CONST memory
   276 bytes of DATA  memory

Errors: none
Warnings: none
