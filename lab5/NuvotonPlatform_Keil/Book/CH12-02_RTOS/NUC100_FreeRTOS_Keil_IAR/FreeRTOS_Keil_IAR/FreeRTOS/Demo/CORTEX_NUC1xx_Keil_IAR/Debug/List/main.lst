###############################################################################
#                                                                             #
#                                                       06/Jul/2010  14:34:56 #
# IAR ANSI C/C++ Compiler V5.50.0.21878/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\main.c                                                 #
#    Command line =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\main.c -D IAR_ARM_CM0 -lCN                             #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\List\ --diag_suppress Pe550,Pa082,Pa039 -o       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\Obj\ --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M0  #
#                    -e --fpu=None --dlib_config "D:\Program                  #
#                    Files\ARM\INC\DLib_Config_Full.h" -I                     #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\..\common\include\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\De #
#                    mo\CORTEX_NUC1xx_Keil_IAR\..\..\source\include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_K #
#                    eil_IAR\NUC1xxBSP\NuvotonPlatform_Keil\Include\ -I       #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\NuvotonPlatform_Keil\Include\Driver\ -I      #
#                    E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\NUC1xxBSP\CMSIS\CM0\ -I E:\FreeRTOS_Keil_IAR\FreeRTOS\ #
#                    Demo\CORTEX_NUC1xx_Keil_IAR\User_Demo\include\ -I        #
#                    "D:\Program Files\ARM\INC\" -Ol                          #
#    List file    =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\List\main.lst                                    #
#    Object file  =  E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IA #
#                    R\Debug\Obj\main.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

E:\FreeRTOS_Keil_IAR\FreeRTOS\Demo\CORTEX_NUC1xx_Keil_IAR\main.c
      1          /*
      2              FreeRTOS V6.0.5 - Copyright (C) 2010 Real Time Engineers Ltd.
      3          
      4              ***************************************************************************
      5              *                                                                         *
      6              * If you are:                                                             *
      7              *                                                                         *
      8              *    + New to FreeRTOS,                                                   *
      9              *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
     10              *    + Looking for basic training,                                        *
     11              *    + Wanting to improve your FreeRTOS skills and productivity           *
     12              *                                                                         *
     13              * then take a look at the FreeRTOS eBook                                  *
     14              *                                                                         *
     15              *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
     16              *                  http://www.FreeRTOS.org/Documentation                  *
     17              *                                                                         *
     18              * A pdf reference manual is also available.  Both are usually delivered   *
     19              * to your inbox within 20 minutes to two hours when purchased between 8am *
     20              * and 8pm GMT (although please allow up to 24 hours in case of            *
     21              * exceptional circumstances).  Thank you for your support!                *
     22              *                                                                         *
     23              ***************************************************************************
     24          
     25              This file is part of the FreeRTOS distribution.
     26          
     27              FreeRTOS is free software; you can redistribute it and/or modify it under
     28              the terms of the GNU General Public License (version 2) as published by the
     29              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     30              ***NOTE*** The exception to the GPL is included to allow you to distribute
     31              a combined work that includes FreeRTOS without being obliged to provide the
     32              source code for proprietary components outside of the FreeRTOS kernel.
     33              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
     34              ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     35              FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     36              more details. You should have received a copy of the GNU General Public 
     37              License and the FreeRTOS license exception along with FreeRTOS; if not it 
     38              can be viewed here: http://www.freertos.org/a00114.html and also obtained 
     39              by writing to Richard Barry, contact details for whom are available on the
     40              FreeRTOS WEB site.
     41          
     42              1 tab == 4 spaces!
     43          
     44              http://www.FreeRTOS.org - Documentation, latest information, license and
     45              contact details.
     46          
     47              http://www.SafeRTOS.com - A version that is certified for use in safety
     48              critical systems.
     49          
     50              http://www.OpenRTOS.com - Commercial support, development, porting,
     51              licensing and training services.
     52          */
     53          
     54          /*
     55           * Creates all the demo application tasks, then starts the scheduler.  The WEB
     56           * documentation provides more details of the standard demo application tasks.
     57           * In addition to the standard demo tasks, the following tasks and tests are
     58           * defined and/or created within this file:
     59           *
     60           * "Check" task -  This only executes every five seconds but has the highest
     61           * priority so is guaranteed to get processor time.  Its main function is to
     62           * check that all the standard demo tasks are still operational.  Should any
     63           * unexpected behaviour within a demo task be discovered the 'check' task will
     64           * write an error to the Hyper-terminal.  If all the demo tasks are executing 
     65           * with their expected behaviour then the check task writes PASSto the 
     66           * Hyper-terminal, as described above.
     67           *
     68           */
     69          
     70          /* Standard includes. */
     71          #include <stdio.h>
     72          
     73          /* Scheduler includes. */
     74          #include "FreeRTOS.h"
     75          #include "task.h"
     76          #include "queue.h"
     77          
     78          /* NUC1xx driver includes. */
     79          #include "DrvUART.h"
     80          #include "DrvGPIO.h"
     81          #include "DrvSYS.h"
     82          
     83          /* Demo app includes. */
     84          #include "NUC1xx_Test.h"
     85          #include "App_Cfg.h"
     86          
     87          #if BLOCK_Q_TEST
     88          #include "BlockQ.h"
     89          #endif
     90          
     91          #if SUICID_TEST
     92          #include "death.h"
     93          #endif
     94          
     95          #if MATH_TEST
     96          #include "integer.h"
     97          #endif
     98          
     99          #if BLOCK_TM_TEST
    100          #include "blocktim.h"
    101          #endif
    102          
    103          #if SEM_TEST
    104          #include "semtest.h"
    105          #endif
    106          
    107          #if POLL_Q_TEST
    108          #include "PollQ.h"
    109          #endif
    110          
    111          #if LED_TEST
    112          #include "flash.h"
    113          #include "partest.h"
    114          #endif
    115          
    116          #if REMUTEX_TEST
    117          #include "recmutex.h"
    118          #endif
    119          
    120          #if COUNTSEM_TEST
    121          #include "countsem.h"
    122          #endif
    123          
    124          #if GENQ_TEST
    125          #include "GenQTest.h"
    126          #endif
    127          
    128          #if DYNAMIC_TEST
    129          #include "dynamic.h"
    130          #endif
    131          
    132          #if QPEEK_TEST
    133          #include "QPeek.h"
    134          #endif
    135          
    136          #if ALT_QUEUE_TEST
    137          #include "AltQTest.h"
    138          #endif
    139          
    140          #if ALT_BLOCKQ_TEST
    141          #include "AltBlckQ.h"
    142          #endif
    143          
    144          #if ALT_BLOCK_TEST
    145          #include "AltBlock.h"
    146          #endif
    147          
    148          #if ALT_POLLQ_TEST
    149          #include "AltPollQ.h"
    150          #endif
    151          
    152          #if MATH_F_TEST
    153          #include "flop.h"
    154          #endif
    155          
    156          #if INTQ_TEST
    157          #include "IntQueue.h"
    158          #endif
    159          
    160          /* Task priorities. */
    161          #define mainQUEUE_POLL_PRIORITY				( tskIDLE_PRIORITY + 2 )
    162          #define mainBLOCK_Q_PRIORITY				( tskIDLE_PRIORITY + 2 )
    163          #define mainSEM_TEST_PRIORITY				( tskIDLE_PRIORITY + 1 )
    164          #define mainINTEGER_TASK_PRIORITY           ( tskIDLE_PRIORITY )
    165          #define mainCHECK_TASK_PRIORITY				( tskIDLE_PRIORITY + 3 )
    166          #define mainCREATOR_TASK_PRIORITY           ( tskIDLE_PRIORITY + 3 )
    167          #define mainFLASH_TASK_PRIORITY				( tskIDLE_PRIORITY + 1 )
    168          #define mainUART_TASK_PRIORITY				( tskIDLE_PRIORITY + 1 )
    169          #define mainGENQ_TASK_PRIORITY				( tskIDLE_PRIORITY )
    170          
    171          #define mainCHECK_TASK_STACK_SIZE			( configMINIMAL_STACK_SIZE )
    172          
    173          /* The time between cycles of the 'check' task. */
    174          #define mainCHECK_DELAY						( ( portTickType ) 5000 / portTICK_RATE_MS )
    175          
    176          /*-----------------------------------------------------------*/
    177          
    178          /*
    179           * Configure the clocks, GPIO and other peripherals as required by the demo.
    180           */
    181          static void prvSetupHardware( void );
    182          
    183          static void NUC1xx_UART_Init(void);
    184          
    185          /*
    186           * Checks the status of all the demo tasks then prints a message to the
    187           * display.  The message will be either PASS - and include in brackets the
    188           * maximum measured jitter time (as described at the to of the file), or a
    189           * message that describes which of the standard demo tasks an error has been
    190           * discovered in.
    191           *
    192           * Messages are written directly to the terminal.
    193           */
    194          #if CHECK_TEST
    195          static void vCheckTask( void *pvParameters );
    196          #endif
    197          
    198          /*-----------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    199          int main( void )
    200          {
   \                     main:
   \   00000000   80B5               PUSH     {R7,LR}
    201          #ifdef DEBUG
    202            debug();
    203          #endif
    204          
    205          	/* Configure realitive hardware platform. */
    206          	prvSetupHardware();
   \   00000002   ........           BL       prvSetupHardware
    207          	
    208          	/* Start the standard demo tasks. */
    209          #if LED_TEST
    210          	vStartLEDFlashTasks( mainFLASH_TASK_PRIORITY );
    211          #endif
    212          #if POLL_Q_TEST
    213          	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
    214          #endif
    215          #if BLOCK_Q_TEST
    216          	vStartBlockingQueueTasks( mainBLOCK_Q_PRIORITY );
   \   00000006   0220               MOVS     R0,#+2
   \   00000008   ........           BL       vStartBlockingQueueTasks
    217          #endif
    218          #if SEM_TEST
    219          	vStartSemaphoreTasks( mainSEM_TEST_PRIORITY );
    220          #endif
    221          #if MATH_TEST
    222          	vStartIntegerMathTasks( mainINTEGER_TASK_PRIORITY );
    223          #endif
    224          #if BLOCK_TM_TEST
    225          	vCreateBlockTimeTasks();
    226          #endif
    227          #if REMUTEX_TEST
    228          	vStartRecursiveMutexTasks();
    229          #endif
    230          #if COUNTSEM_TEST
    231          	vStartCountingSemaphoreTasks();
    232          #endif
    233          #if GENQ_TEST
    234          	vStartGenericQueueTasks( mainGENQ_TASK_PRIORITY );
    235          #endif
    236          #if DYNAMIC_TEST
    237          	vStartDynamicPriorityTasks();
    238          #endif
    239          #if QPEEK_TEST
    240          	vStartQueuePeekTasks();
    241          #endif
    242          #if ALT_QUEUE_TEST
    243          	vStartAltGenericQueueTasks( tskIDLE_PRIORITY );
    244          #endif
    245          #if ALT_BLOCKQ_TEST
    246          	vStartAltBlockingQueueTasks( tskIDLE_PRIORITY + 2 );
    247          #endif
    248          #if ALT_BLOCK_TEST
    249          	vCreateAltBlockTimeTasks();
    250          #endif
    251          #if ALT_POLLQ_TEST
    252          	vStartAltPolledQueueTasks( tskIDLE_PRIORITY + 2 );
    253          #endif
    254          #if MATH_F_TEST
    255          	vStartMathTasks( tskIDLE_PRIORITY );
    256          #endif
    257          #if INTQ_TEST
    258          	vStartInterruptQueueTasks();
    259          #endif
    260          
    261          	/* Start user demo tasks. */
    262          #if UART_TEST
    263          	vStartUARTTasks( mainUART_TASK_PRIORITY );
    264          #endif
    265          #if THREAD_TEST
    266          	vStartThreadTasks();
   \   0000000C   ........           BL       vStartThreadTasks
    267          #endif
    268          #if QUEUE_TEST
    269          	vStartQueueTasks();
    270          #endif
    271          
    272          	/* Start the tasks defined within this file/specific to this demo. */
    273          #if CHECK_TEST
    274              xTaskCreate( vCheckTask, ( signed portCHAR * ) "Check", mainCHECK_TASK_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );	
    275          #endif
    276          
    277          	/* The suicide tasks must be created last as they need to know how many
    278          	tasks were running prior to their creation in order to ascertain whether
    279          	or not the correct/expected number of tasks are running at any given time. */
    280          #if SUICID_TEST
    281              vCreateSuicidalTasks( mainCREATOR_TASK_PRIORITY );
    282          #endif	
    283          	/* Start the scheduler. */
    284          	vTaskStartScheduler();
   \   00000010   ........           BL       vTaskStartScheduler
    285          
    286          	/* Will only get here if there was not enough heap space to create the
    287          	idle task. */
    288          	return 0;
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   02BD               POP      {R1,PC}          ;; return
    289          }
    290          /*-----------------------------------------------------------*/
    291          #if CHECK_TEST
    292          static void vCheckTask( void *pvParameters )
    293          {
    294          portTickType xLastExecutionTime;
    295          static unsigned portBASE_TYPE times = 0;
    296          
    297          	printf( "Check begin...\n" );
    298          
    299          	xLastExecutionTime = xTaskGetTickCount();
    300          
    301              for( ;; )
    302          	{
    303          		/* Perform this check every mainCHECK_DELAY milliseconds. */
    304          		vTaskDelayUntil( &xLastExecutionTime, mainCHECK_DELAY );
    305          
    306          		/* Has an error been found in any task? */
    307          	#if BLOCK_Q_TEST
    308                  if( xAreBlockingQueuesStillRunning() != pdTRUE )
    309          		{
    310          			printf( "ERROR IN BLOCK Q\n" );
    311          		}
    312          	#endif
    313          	#if BLOCK_TM_TEST
    314          		else if( xAreBlockTimeTestTasksStillRunning() != pdTRUE )
    315          		{
    316          			printf("ERROR IN BLOCK TIME\n");
    317          		}
    318              #endif
    319          	#if SEM_TEST
    320          		else if( xAreSemaphoreTasksStillRunning() != pdTRUE )
    321                  {
    322          			printf( "ERROR IN SEMAPHORE\n" );
    323                  }
    324          	#endif
    325          	#if POLL_Q_TEST
    326                  else if( xArePollingQueuesStillRunning() != pdTRUE )
    327                  {
    328          			printf( "ERROR IN POLL Q\n" );
    329                  }
    330          	#endif
    331          	#if SUICID_TEST
    332                  else if( xIsCreateTaskStillRunning() != pdTRUE )
    333                  {
    334          			printf( "ERROR IN CREATE\n" );
    335                  }
    336          	#endif
    337          	#if MATH_TEST
    338                  else if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
    339                  {
    340          			printf( "ERROR IN MATH\n" );
    341                  }
    342          	#endif
    343          	#if REMUTEX_TEST	
    344          		else if( xAreRecursiveMutexTasksStillRunning() != pdTRUE )
    345                  {
    346          			printf( "ERROR IN REMUTEX\n" );
    347                  }
    348          	#endif
    349          	#if COUNTSEM_TEST	
    350          		else if( xAreCountingSemaphoreTasksStillRunning() != pdTRUE )
    351          		{
    352          			printf( "ERROR IN COUNTSEM\n" );
    353          		}
    354          	#endif
    355          	#if GENQ_TEST	
    356          		else if( xAreGenericQueueTasksStillRunning() != pdTRUE )
    357          		{
    358          			printf( "ERROR IN GENQUEUE\n" );
    359          		}	
    360          	#endif
    361          	#if DYNAMIC_TEST	
    362          		else if( xAreDynamicPriorityTasksStillRunning() != pdTRUE )
    363          		{
    364          			printf( "ERROR IN DYNAMIC TEST\n" );
    365          		}	
    366          	#endif
    367          	#if QPEEK_TEST	
    368          		else if( xAreQueuePeekTasksStillRunning() != pdTRUE )
    369          		{
    370          			printf( "ERROR IN Q_PEEK\n" );
    371          		}	
    372          	#endif
    373          	#if ALT_QUEUE_TEST	
    374          		else if( xAreAltGenericQueueTasksStillRunning() != pdTRUE )
    375          		{
    376          			printf( "ERROR IN ALT_QUEUE\n" );
    377          		}	
    378          	#endif
    379          	#if ALT_BLOCKQ_TEST	
    380          		else if( xAreAltBlockingQueuesStillRunning() != pdTRUE )
    381          		{
    382          			printf( "ERROR IN ALT_BLOCKQ\n" );
    383          		}	
    384          	#endif
    385          	#if ALT_BLOCK_TEST	
    386          		else if( xAreAltBlockTimeTestTasksStillRunning() != pdTRUE )
    387          		{
    388          			printf( "ERROR IN ALT_BLOCK\n" );
    389          		}	
    390          	#endif
    391          	#if ALT_POLLQ_TEST	
    392          		else if( xAreAltPollingQueuesStillRunning() != pdTRUE )
    393          		{
    394          			printf( "ERROR IN ALT_POLLQ\n" );
    395          		}	
    396          	#endif
    397          	#if MATH_F_TEST	
    398          		else if( xAreMathsTaskStillRunning() != pdTRUE )
    399          		{
    400          			printf( "ERROR IN FLOP\n" );
    401          		}	
    402          	#endif
    403          	#if INTQ_TEST	
    404          		else if( xAreIntQueueTasksStillRunning() != pdTRUE )
    405          		{
    406          			printf( "ERROR IN INTQ\n" );
    407          		}	
    408          	#endif
    409          		else
    410          		{
    411          			printf( "ALL Test Pass %d times! \n",  ++times );
    412          		}
    413          	}
    414          }
    415          #endif
    416          /*-----------------------------------------------------------*/
    417          

   \                                 In section .text, align 2, keep-with-next
    418          static void prvSetupHardware( void )
    419          {
   \                     prvSetupHardware:
   \   00000000   80B5               PUSH     {R7,LR}
    420          	UNLOCKREG();
   \   00000002   ....               LDR      R0,??DataTable1  ;; 0x50000100
   \   00000004   5921               MOVS     R1,#+89
   \   00000006   0160               STR      R1,[R0, #+0]
   \   00000008   ....               LDR      R0,??DataTable1  ;; 0x50000100
   \   0000000A   1621               MOVS     R1,#+22
   \   0000000C   0160               STR      R1,[R0, #+0]
   \   0000000E   ....               LDR      R0,??DataTable1  ;; 0x50000100
   \   00000010   8821               MOVS     R1,#+136
   \   00000012   0160               STR      R1,[R0, #+0]
    421          
    422          	/* Enable external 12M Crystal oscillation. */
    423          	SYSCLK->PWRCON.XTL12M_EN = 1;
   \   00000014   ....               LDR      R0,??DataTable1_1  ;; 0x50000200
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   0143               ORRS     R1,R1,R0
   \   0000001C   ....               LDR      R0,??DataTable1_1  ;; 0x50000200
   \   0000001E   0160               STR      R1,[R0, #+0]
    424          
    425          	/* Enable the 64 clock cycle delay. */
    426          	SYSCLK->PWRCON.WU_DLY = 1;
   \   00000020   ....               LDR      R0,??DataTable1_1  ;; 0x50000200
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   1021               MOVS     R1,#+16
   \   00000026   0143               ORRS     R1,R1,R0
   \   00000028   ....               LDR      R0,??DataTable1_1  ;; 0x50000200
   \   0000002A   0160               STR      R1,[R0, #+0]
    427          
    428          	/* Enable PLL. */
    429          	SYSCLK->PLLCON.PD = 0;
   \   0000002C   ....               LDR      R0,??DataTable1_2  ;; 0x50000220
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   ....               LDR      R1,??DataTable1_3  ;; 0xfffeffff
   \   00000032   0140               ANDS     R1,R1,R0
   \   00000034   ....               LDR      R0,??DataTable1_2  ;; 0x50000220
   \   00000036   0160               STR      R1,[R0, #+0]
    430          	SYSCLK->PLLCON.OE = 0;
   \   00000038   ....               LDR      R0,??DataTable1_2  ;; 0x50000220
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   ....               LDR      R1,??DataTable1_4  ;; 0xfffbffff
   \   0000003E   0140               ANDS     R1,R1,R0
   \   00000040   ....               LDR      R0,??DataTable1_2  ;; 0x50000220
   \   00000042   0160               STR      R1,[R0, #+0]
    431          
    432          	/* Select PLL output as system clock source. */
    433          	SYSCLK->CLKSEL0.HCLK_S = 2;
   \   00000044   ....               LDR      R0,??DataTable1_5  ;; 0x50000210
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   0721               MOVS     R1,#+7
   \   0000004A   8843               BICS     R0,R0,R1
   \   0000004C   0221               MOVS     R1,#+2
   \   0000004E   0143               ORRS     R1,R1,R0
   \   00000050   ....               LDR      R0,??DataTable1_5  ;; 0x50000210
   \   00000052   0160               STR      R1,[R0, #+0]
    434          
    435          	/* Configure SysTick clock source. */
    436          	SYSCLK->CLKSEL0.STCLK_S = 3;
   \   00000054   ....               LDR      R0,??DataTable1_5  ;; 0x50000210
   \   00000056   0068               LDR      R0,[R0, #+0]
   \   00000058   3821               MOVS     R1,#+56
   \   0000005A   8843               BICS     R0,R0,R1
   \   0000005C   1821               MOVS     R1,#+24
   \   0000005E   0143               ORRS     R1,R1,R0
   \   00000060   ....               LDR      R0,??DataTable1_5  ;; 0x50000210
   \   00000062   0160               STR      R1,[R0, #+0]
    437          
    438          	/* Initialize NUC1xx MUC UART0. */
    439          	NUC1xx_UART_Init();
   \   00000064   ........           BL       NUC1xx_UART_Init
    440          }
   \   00000068   01BD               POP      {R0,PC}          ;; return
    441          /*-----------------------------------------------------------*/
    442          

   \                                 In section .text, align 2, keep-with-next
    443          void NUC1xx_UART_Init(void)
    444          {
    445          	/* Set UART Pin. */
    446          	SYS->GPBMFP.UART0_RX = 1;
   \                     NUC1xx_UART_Init:
   \   00000000   ....               LDR      R0,??DataTable1_6  ;; 0x50000034
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0143               ORRS     R1,R1,R0
   \   00000008   ....               LDR      R0,??DataTable1_6  ;; 0x50000034
   \   0000000A   0160               STR      R1,[R0, #+0]
    447          	SYS->GPBMFP.UART0_TX = 1;
   \   0000000C   ....               LDR      R0,??DataTable1_6  ;; 0x50000034
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   0221               MOVS     R1,#+2
   \   00000012   0143               ORRS     R1,R1,R0
   \   00000014   ....               LDR      R0,??DataTable1_6  ;; 0x50000034
   \   00000016   0160               STR      R1,[R0, #+0]
    448          	SYS->GPBMFP.UART0_nRTS = 1;
   \   00000018   ....               LDR      R0,??DataTable1_6  ;; 0x50000034
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   0421               MOVS     R1,#+4
   \   0000001E   0143               ORRS     R1,R1,R0
   \   00000020   ....               LDR      R0,??DataTable1_6  ;; 0x50000034
   \   00000022   0160               STR      R1,[R0, #+0]
    449          	SYS->GPBMFP.UART0_nCTS = 1;
   \   00000024   ....               LDR      R0,??DataTable1_6  ;; 0x50000034
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   0821               MOVS     R1,#+8
   \   0000002A   0143               ORRS     R1,R1,R0
   \   0000002C   ....               LDR      R0,??DataTable1_6  ;; 0x50000034
   \   0000002E   0160               STR      R1,[R0, #+0]
    450          
    451          	/* Reset IP */
    452          	SYS->IPRSTC2.UART0_RST = 1;
   \   00000030   ....               LDR      R0,??DataTable1_7  ;; 0x5000000c
   \   00000032   0068               LDR      R0,[R0, #+0]
   \   00000034   8021               MOVS     R1,#+128
   \   00000036   4902               LSLS     R1,R1,#+9        ;; #+65536
   \   00000038   0143               ORRS     R1,R1,R0
   \   0000003A   ....               LDR      R0,??DataTable1_7  ;; 0x5000000c
   \   0000003C   0160               STR      R1,[R0, #+0]
    453          	SYS->IPRSTC2.UART0_RST = 0;
   \   0000003E   ....               LDR      R0,??DataTable1_7  ;; 0x5000000c
   \   00000040   0068               LDR      R0,[R0, #+0]
   \   00000042   ....               LDR      R1,??DataTable1_3  ;; 0xfffeffff
   \   00000044   0140               ANDS     R1,R1,R0
   \   00000046   ....               LDR      R0,??DataTable1_7  ;; 0x5000000c
   \   00000048   0160               STR      R1,[R0, #+0]
    454          
    455          	/* Enable UART clock */
    456          	SYSCLK->APBCLK.UART0_EN = 1;
   \   0000004A   ....               LDR      R0,??DataTable1_8  ;; 0x50000208
   \   0000004C   0068               LDR      R0,[R0, #+0]
   \   0000004E   8021               MOVS     R1,#+128
   \   00000050   4902               LSLS     R1,R1,#+9        ;; #+65536
   \   00000052   0143               ORRS     R1,R1,R0
   \   00000054   ....               LDR      R0,??DataTable1_8  ;; 0x50000208
   \   00000056   0160               STR      R1,[R0, #+0]
    457          
    458          	/* Select UART clock source */
    459              SYSCLK->CLKSEL1.UART_S = 0;
   \   00000058   ....               LDR      R0,??DataTable1_9  ;; 0x50000214
   \   0000005A   0068               LDR      R0,[R0, #+0]
   \   0000005C   ....               LDR      R1,??DataTable1_10  ;; 0xfcffffff
   \   0000005E   0140               ANDS     R1,R1,R0
   \   00000060   ....               LDR      R0,??DataTable1_9  ;; 0x50000214
   \   00000062   0160               STR      R1,[R0, #+0]
    460              SYSCLK->PWRCON.XTL12M_EN = 1;
   \   00000064   ....               LDR      R0,??DataTable1_1  ;; 0x50000200
   \   00000066   0068               LDR      R0,[R0, #+0]
   \   00000068   0121               MOVS     R1,#+1
   \   0000006A   0143               ORRS     R1,R1,R0
   \   0000006C   ....               LDR      R0,??DataTable1_1  ;; 0x50000200
   \   0000006E   0160               STR      R1,[R0, #+0]
    461              
    462          	/* Select UART clock source */
    463              SYSCLK->CLKSEL1.UART_S = 0;
   \   00000070   ....               LDR      R0,??DataTable1_9  ;; 0x50000214
   \   00000072   0068               LDR      R0,[R0, #+0]
   \   00000074   ....               LDR      R1,??DataTable1_10  ;; 0xfcffffff
   \   00000076   0140               ANDS     R1,R1,R0
   \   00000078   ....               LDR      R0,??DataTable1_9  ;; 0x50000214
   \   0000007A   0160               STR      R1,[R0, #+0]
    464          
    465          	/* Tx FIFO Reset & Rx FIFO Reset & FIFO Mode Enable */
    466            	UART0->FCR.TFR = 1;
   \   0000007C   ....               LDR      R0,??DataTable1_11  ;; 0x40050008
   \   0000007E   0068               LDR      R0,[R0, #+0]
   \   00000080   0421               MOVS     R1,#+4
   \   00000082   0143               ORRS     R1,R1,R0
   \   00000084   ....               LDR      R0,??DataTable1_11  ;; 0x40050008
   \   00000086   0160               STR      R1,[R0, #+0]
    467            	UART0->FCR.RFR = 1;
   \   00000088   ....               LDR      R0,??DataTable1_11  ;; 0x40050008
   \   0000008A   0068               LDR      R0,[R0, #+0]
   \   0000008C   0221               MOVS     R1,#+2
   \   0000008E   0143               ORRS     R1,R1,R0
   \   00000090   ....               LDR      R0,??DataTable1_11  ;; 0x40050008
   \   00000092   0160               STR      R1,[R0, #+0]
    468          
    469          	/* Set Rx Trigger Level */
    470          	UART0->FCR.RFITL = 0;  
   \   00000094   ....               LDR      R0,??DataTable1_11  ;; 0x40050008
   \   00000096   0068               LDR      R0,[R0, #+0]
   \   00000098   F021               MOVS     R1,#+240
   \   0000009A   8843               BICS     R0,R0,R1
   \   0000009C   ....               LDR      R1,??DataTable1_11  ;; 0x40050008
   \   0000009E   0860               STR      R0,[R1, #+0]
    471          
    472          	/* Set Parity & Data bits & Stop bits */
    473          	UART0->LCR.SPE = 0;
   \   000000A0   ....               LDR      R0,??DataTable1_12  ;; 0x4005000c
   \   000000A2   0068               LDR      R0,[R0, #+0]
   \   000000A4   2021               MOVS     R1,#+32
   \   000000A6   8843               BICS     R0,R0,R1
   \   000000A8   ....               LDR      R1,??DataTable1_12  ;; 0x4005000c
   \   000000AA   0860               STR      R0,[R1, #+0]
    474          	UART0->LCR.EPE = 0;
   \   000000AC   ....               LDR      R0,??DataTable1_12  ;; 0x4005000c
   \   000000AE   0068               LDR      R0,[R0, #+0]
   \   000000B0   1021               MOVS     R1,#+16
   \   000000B2   8843               BICS     R0,R0,R1
   \   000000B4   ....               LDR      R1,??DataTable1_12  ;; 0x4005000c
   \   000000B6   0860               STR      R0,[R1, #+0]
    475          	UART0->LCR.PBE = 0;
   \   000000B8   ....               LDR      R0,??DataTable1_12  ;; 0x4005000c
   \   000000BA   0068               LDR      R0,[R0, #+0]
   \   000000BC   0821               MOVS     R1,#+8
   \   000000BE   8843               BICS     R0,R0,R1
   \   000000C0   ....               LDR      R1,??DataTable1_12  ;; 0x4005000c
   \   000000C2   0860               STR      R0,[R1, #+0]
    476          	
    477          	UART0->LCR.WLS = 3;
   \   000000C4   ....               LDR      R0,??DataTable1_12  ;; 0x4005000c
   \   000000C6   0068               LDR      R0,[R0, #+0]
   \   000000C8   0321               MOVS     R1,#+3
   \   000000CA   0143               ORRS     R1,R1,R0
   \   000000CC   ....               LDR      R0,??DataTable1_12  ;; 0x4005000c
   \   000000CE   0160               STR      R1,[R0, #+0]
    478          	UART0->LCR.NSB = 0;
   \   000000D0   ....               LDR      R0,??DataTable1_12  ;; 0x4005000c
   \   000000D2   0068               LDR      R0,[R0, #+0]
   \   000000D4   0421               MOVS     R1,#+4
   \   000000D6   8843               BICS     R0,R0,R1
   \   000000D8   ....               LDR      R1,??DataTable1_12  ;; 0x4005000c
   \   000000DA   0860               STR      R0,[R1, #+0]
    479          	
    480          	/* Set Time-Out */
    481          	UART0->TOR = 0;
   \   000000DC   ....               LDR      R0,??DataTable1_13  ;; 0x40050020
   \   000000DE   0021               MOVS     R1,#+0
   \   000000E0   0160               STR      R1,[R0, #+0]
    482          
    483          	/* Set baudrate 115200bps. */
    484          	UART0->BAUD.DIVX_EN = 1;
   \   000000E2   ....               LDR      R0,??DataTable1_14  ;; 0x40050024
   \   000000E4   0068               LDR      R0,[R0, #+0]
   \   000000E6   8021               MOVS     R1,#+128
   \   000000E8   8905               LSLS     R1,R1,#+22       ;; #+536870912
   \   000000EA   0143               ORRS     R1,R1,R0
   \   000000EC   ....               LDR      R0,??DataTable1_14  ;; 0x40050024
   \   000000EE   0160               STR      R1,[R0, #+0]
    485          	UART0->BAUD.DIVX1 = 1;
   \   000000F0   ....               LDR      R0,??DataTable1_14  ;; 0x40050024
   \   000000F2   0068               LDR      R0,[R0, #+0]
   \   000000F4   8021               MOVS     R1,#+128
   \   000000F6   4905               LSLS     R1,R1,#+21       ;; #+268435456
   \   000000F8   0143               ORRS     R1,R1,R0
   \   000000FA   ....               LDR      R0,??DataTable1_14  ;; 0x40050024
   \   000000FC   0160               STR      R1,[R0, #+0]
    486          	UART0->BAUD.DIVX = 15;
   \   000000FE   ....               LDR      R0,??DataTable1_14  ;; 0x40050024
   \   00000100   0068               LDR      R0,[R0, #+0]
   \   00000102   F021               MOVS     R1,#+240
   \   00000104   0905               LSLS     R1,R1,#+20       ;; #+251658240
   \   00000106   0143               ORRS     R1,R1,R0
   \   00000108   ....               LDR      R0,??DataTable1_14  ;; 0x40050024
   \   0000010A   0160               STR      R1,[R0, #+0]
    487          	UART0->BAUD.DIV = 102;
   \   0000010C   ....               LDR      R0,??DataTable1_14  ;; 0x40050024
   \   0000010E   0068               LDR      R0,[R0, #+0]
   \   00000110   000C               LSRS     R0,R0,#+16
   \   00000112   0004               LSLS     R0,R0,#+16
   \   00000114   6621               MOVS     R1,#+102
   \   00000116   0143               ORRS     R1,R1,R0
   \   00000118   ....               LDR      R0,??DataTable1_14  ;; 0x40050024
   \   0000011A   0160               STR      R1,[R0, #+0]
    488          }
   \   0000011C   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   00010050           DC32     0x50000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   00020050           DC32     0x50000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   20020050           DC32     0x50000220

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   FFFFFEFF           DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   FFFFFBFF           DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   10020050           DC32     0x50000210

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   34000050           DC32     0x50000034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0C000050           DC32     0x5000000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \   00000000   08020050           DC32     0x50000208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \   00000000   14020050           DC32     0x50000214

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \   00000000   FFFFFFFC           DC32     0xfcffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_11:
   \   00000000   08000540           DC32     0x40050008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_12:
   \   00000000   0C000540           DC32     0x4005000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_13:
   \   00000000   20000540           DC32     0x40050020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_14:
   \   00000000   24000540           DC32     0x40050024

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     NUC1xx_UART_Init      0
     main                  8
     prvSetupHardware      8


   Section sizes:

     Function/Label   Bytes
     --------------   -----
     main               24
     prvSetupHardware  106
     NUC1xx_UART_Init  286
     ??DataTable1        4
     ??DataTable1_1      4
     ??DataTable1_2      4
     ??DataTable1_3      4
     ??DataTable1_4      4
     ??DataTable1_5      4
     ??DataTable1_6      4
     ??DataTable1_7      4
     ??DataTable1_8      4
     ??DataTable1_9      4
     ??DataTable1_10     4
     ??DataTable1_11     4
     ??DataTable1_12     4
     ??DataTable1_13     4
     ??DataTable1_14     4

 
 476 bytes in section .text
 
 476 bytes of CODE memory

Errors: none
Warnings: none
